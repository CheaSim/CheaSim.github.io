{"pages":[{"title":"","text":"h31SBbrf8G","link":"/baidu_verify_h31SBbrf8G.html"},{"title":"","text":"iOJjnxByPY","link":"/baidu_verify_iOJjnxByPY.html"},{"title":"同城约cf+Q852975133","text":"一名被发配宁波的nlp chicken 探讨nlp内卷+Q 852975133","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"2018 ICPC南京赛区网络赛","text":"ACM-ICPC 2018 南京赛区网络预赛A. An Olympian Math Problem题意$S=1×1!+2×2!+⋯+(n - 1) \\times (n-1)!(n−1)×(n−1)!$问$Smodn$是多少。 题解思维题，打表题？答案就是$n-1$证明如下。 看到$n-1$很不爽，那就加一个$(n-1)!$就凑好了。 $S+1!+2!+…+(n-1)!=2!+3!+…+n!$ 之后再减掉。 $S=n!-1!$那么对$n$取余$S modn=-1modn=n-1$搞定。 AC代码1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint T;ll n;int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld\\n&quot;,n-1); } return 0;} B. The writing on the wallE. AC Challenge题意做题目，要按照一定顺序做题目，每个题目有两个值$a,b$，表示做了题目后增加$t*a+b$。 题解状态压缩+剪枝+拓扑排序。 因为$n$的数据量小于$20$所以可以使用状态压缩。 $S$表示已经做的题目。 $vs$数组存储已知做题的最大值。如果做同样的题值比较小就减掉。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 30;struct noddde{ int next,to;}G[maxn*maxn*3];int head[maxn],ind[maxn];ll a[maxn],b[maxn];int cnt;void add(int u,int v){ G[cnt].to = v; G[cnt].next = head[u]; head[u] = cnt++;}int n;ll ans = 0;ll vis[maxn];ll vs[1&lt;&lt;22];void dfs(int u,int t,ll temp,int S){ ans = max(ans,temp); if(vs[S] &gt; temp) return; vs[S] = temp; for(int i = head[u];~i;i=G[i].next){ int v = G[i].to; ind[v]--; } rep(i,1,n+1){ if(ind[i] == 0 &amp;&amp; vis[i]==0){ vis[i] = 1; dfs(i,t+1,temp+a[i]*t+b[i],S|(1&lt;&lt;i)); vis[i] = 0; } } for(int i = head[u];~i;i=G[i].next){ int v = G[i].to; ind[v]++; }}int main(){#ifdef LOCAL freopen(&quot;e.in&quot;,&quot;r&quot;,stdin);#endif memset(head,-1,sizeof(head)); scanf(&quot;%d&quot;,&amp;n); rep(i,1,n+1){ int s;scanf(&quot;%lld%lld%d&quot;,&amp;a[i],&amp;b[i],&amp;s); rep(j,0,s){ int u;scanf(&quot;%d&quot;,&amp;u); add(u,i);ind[i]++; } } rep(i,1,n+1){ if(ind[i]==0){ ind[i]++; add(0,i); } } ans = 0; dfs(0,1,0,0); printf(&quot;%lld\\n&quot;,ans); return 0;} G. Lpl and Energy-saving Lamps题意一个人去给所有房间换灯泡，每个月都会获得$m$个灯泡，每个房间有$a_i$个灯泡，之后以能换就换的态度每个月从第一个房间开始换，没有能换的房间就停止，把灯泡留到下一个月。换过灯泡就不用再换了。问给定月份中已经换好的房间数和当月剩下的灯泡数。 题解线段树维护一个区间最小值。 由于线段树遍历是从前往后的，就不用担心顺序问题。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5 + 10;int day[maxn],remain[maxn];int a[maxn],Min[maxn&lt;&lt;2],ask[maxn];int n,m,now,ans;void pushup(int rt){ Min[rt] = min(Min[rt&lt;&lt;1],Min[rt&lt;&lt;1|1]);}void build(int l,int r,int rt){ if(l==r){ Min[rt] = a[l]; return; } int mid = (l+r)&gt;&gt;1; build(lson); build(rson); pushup(rt);}void update(int l,int r,int rt){ if(Min[rt] &gt; now) return; if(l==r){ now -= Min[rt]; ans ++; Min[rt] = INF; return; } int mid = (l+r)&gt;&gt;1; update(lson); update(rson); pushup(rt);}int main(){#ifdef LOCAL freopen(&quot;g.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,1,n+1) scanf(&quot;%d&quot;,a+i); int maxq = 0;int q; scanf(&quot;%d&quot;,&amp;q); rep(i,0,q){ scanf(&quot;%d&quot;,ask+i); maxq = max(maxq,ask[i]); } build(1,n,1); rep(i,1,maxq+1){ now += m; update(1,n,1); day[i] = ans;remain[i] = now; } rep(i,0,q){ printf(&quot;%d %d\\n&quot;,day[ask[i]],remain[ask[i]]); } return 0;} I. Skr题意给定一个由数字构成的字符串，$n\\leq 2000000$。问回文串加起来有多少？ 题解两种做法： 马拉车+hash 回文树+dfs AC代码1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;#define ULL unsigned long long#define ll long longconst int maxn=4000000+40;const int mod=1e9+7;ULL P = 1313131;ULL sqr[maxn/2],has[maxn/2],V[maxn];ll ha[maxn/2],tmp[maxn/2];int Laxt[maxn],Next[maxn],cnt=0; const int MOD = 2000007;bool _insert(ULL Now){ int u=Now%MOD; for(int i=Laxt[u];i;i=Next[i]){ if(V[i]==Now) return true; } Next[++cnt]=Laxt[u]; Laxt[u]=cnt; V[cnt]=Now; return false;}ll ans=0;void _hash(int x,int y){ ULL Now=has[y]-has[x-1]*sqr[y-x+1]; if(!_insert(Now)) { ans+=((ha[y]-ha[x-1]*tmp[y-x+1]%mod)%mod+mod)%mod; ans%=mod; }} int r[maxn];char c[maxn];void _malacher(){ int R=0,Mid=0,Len; scanf(&quot;%s&quot;,c+1); Len=strlen(c+1); sqr[0]=tmp[0]=1; has[0]=ha[0]=0; for(int i=1;i&lt;=Len;i++){ sqr[i]=sqr[i-1]*P; has[i]=has[i-1]*P+c[i]; tmp[i]=tmp[i-1]*10%mod; ha[i]=(ha[i-1]*10+c[i]-'0')%mod; } for(int i=1;i&lt;=Len;++i) { _hash(i,i); if(R&gt;i) r[i]=min(r[2*Mid-i],R-i); while(i+r[i]+1&lt;=Len&amp;&amp;c[i+r[i]+1]==c[i-r[i]-1]){ _hash(i-r[i]-1,i+r[i]+1); r[i]++; } if(i+r[i]&gt;R) { R=i+r[i]; Mid=i; } } cnt=0;Mid=0;R=0; memset(Laxt,0,sizeof(Laxt)); memset(r,0,sizeof(r)); for(int i=2;i&lt;=Len;++i) { if(R&gt;i) r[i]=min(r[2*Mid-i],R-i+1); while(i+r[i]&lt;=Len&amp;&amp;c[i+r[i]]==c[i-r[i]-1]) { _hash(i-r[i]-1,i+r[i]); ++r[i]; } if(i+r[i]-1&gt;R) { R=i+r[i]-1; Mid=i; } } printf(&quot;%lld\\n&quot;,ans);}int main(){ _malacher(); return 0;} AC代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;const int MAXN=2005005;const ll MOD=1000000007ll; ll pow(ll a,ll b){ ll t,y; t=1; y=a; while (b!=0){ if (b&amp;1==1) t=t*y%MOD; y=y*y%MOD; b=b&gt;&gt;1; } return t;} int len[MAXN];int nxt[MAXN][15];int fail[MAXN];int num[MAXN];int cnt[MAXN];int last;int S[MAXN];int tot;int N; int new_node(int l){ cnt[tot]=0; num[tot]=0; len[tot]=l; return tot++;} void init_tree(){ tot=0; new_node(0); new_node(-1); last=0; N=0; S[N]=-1; fail[0]=1;} int get_fail(int x){ while(S[N-len[x]-1]!=S[N]) x=fail[x]; return x;} void add_char(int c){ c-='0'; S[++N]=c; int cur=get_fail(last); if(!nxt[cur][c]){ int now=new_node(len[cur]+2); fail[now]=nxt[get_fail(fail[cur])][c]; nxt[cur][c]=now; num[now]=num[fail[now]]+1; } last=nxt[cur][c]; cnt[last]++;} ll jans=0;ll oans=0; void dfs1(int x,ll fa){ for(int i=1;i&lt;=9;i++){ if(nxt[x][i]){ ll cur; if(len[nxt[x][i]]==1){ jans+=i; cur=i; jans%=MOD; } else{ cur=i*pow(10,(len[nxt[x][i]]-1))%MOD+i+fa*10%MOD; jans=(jans+cur%MOD)%MOD; jans%=MOD; } dfs1(nxt[x][i],cur%MOD); } }} void dfs2(int x,ll fa){ for(int i=1;i&lt;=9;i++){ if(nxt[x][i]){ ll cur; cur=i*pow(10,(len[nxt[x][i]]-1))%MOD+i+fa*10%MOD; oans=(oans+cur%MOD)%MOD; dfs2(nxt[x][i],cur%MOD); } }} char str[MAXN]; int main(){ scanf(&quot;%s&quot;,str); int N1 = strlen(str); init_tree(); for(int i=0;i&lt;N1;i++) add_char(str[i]); dfs1(1,0); dfs2(0,0); printf(&quot;%lld\\n&quot;,(jans%MOD+oans%MOD)%MOD); return 0;} L. Magical Girl Haze题意给定一个图，问从$1$走到$n$如果可以选择$k$条路为$0$，那么最短的路径是多少。 题解分层图最短路+堆优化dijistra 每使用一次道路为0，就进入$step+1$的路径比较。比较好的dp思维。对于pair使用了一个小trick，负值就可以不用手写greater和重载小于了。但是现场赛应该还是手写node算了。 dp转移两种状态. $dp[v][step+1] = min(dp[v][step+1],dp[u][step])$ $dp[v][step] = min(dp[v][step],dp[u][step]+val(u,v))$ AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define mp make_pairtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5 + 10;int T,n,m,k,cnt;struct node{ int to,next,val;}G[maxn&lt;&lt;1];int head[maxn];ll dp[maxn][13],done[maxn][13];void add(int u,int v,ll val){ G[cnt].to = v; G[cnt].next = head[u]; G[cnt].val = val; head[u] = cnt++;}void dijstra(){ priority_queue&lt;pair&lt;ll,pair&lt;int,int&gt; &gt; &gt; pq; pq.push(mp(0,mp(1,0))); dp[1][0] = 0; while(!pq.empty()){ int u = pq.top().se.fi; ll dis = pq.top().fi; int step = pq.top().se.se; pq.pop(); if(done[u][step]) continue; done[u][step] = 1; if(u == n){ printf(&quot;%lld\\n&quot;,-dis);return; } for(int i=head[u];~i;i=G[i].next){ int v = G[i].to;ll val = G[i].val; if(step&lt;k &amp;&amp; !done[v][step+1] &amp;&amp; dp[v][step+1]&lt;dis){ dp[v][step+1] = dis; pq.push(mp(dis,mp(v,step+1))); } if(!done[v][step] &amp;&amp; dp[v][step]&lt;dis+val){ dp[v][step] = dis+val; pq.push(mp(dp[v][step],mp(v,step))); } } }}void init(){ memset(head,-1,sizeof(int)*(n+2)); cnt = 0; memset(done,0,sizeof(done)); rep(i,1,n+1) rep(j,0,k+1) dp[i][j] = -1e16;}int main(){#ifdef LOCAL freopen(&quot;l.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); init(); rep(i,0,m){ int u,v;ll val;scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;val); add(u,v,-val); } dijstra(); } return 0;}","link":"/acm/2018/09/03/2018-ICPC%E5%8D%97%E4%BA%AC%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E8%B5%9B.html"},{"title":"2018 Multi-University Training Contest 8 D.Parenth","text":"2018 Multi-University Training Contest 8 D.Parentheses Matrix传送门 题目大意一个由左括号和右括号组成的矩阵，定义矩阵的权值是矩阵中匹配的行数和列数的和。 题解一道比较典型的构造题。 如果行数或者列数是奇数那么矩阵显然是奇数的行或列匹配不了。 (()) (()) (()) 当情况很多有两个变量的时候我们可以假设一个变量小于另一个变量，假设$h\\leq m$。 构造过程还是题解比较清晰。 首先，第一行、最后一列中最多只有一个能够匹配，第一列、最后一行也只有一个能够匹配（考 虑右上角和左下角的括号选取方法），故答案不会超过 w+h−2。 当 h = 2 时，每一列可以构造一对匹配，这样答案已经到达上界。 当 h = 4 时，可以如下构造： ( ( ( ( ( ( ) ) ) ) ) ) ( ( ( ( ( ( ) ) ) ) ) ) 这样答案是 w+h−3。 若存在更优的答案，则必有一个边界能够匹配，不妨设是第一列。这样，就已 经有除第一行以外的两行（右括号开头的行）不匹配了，而第一行和最后一列中至少有一个不匹配， 因此最优解不会超过 w+h−3。 当 h≥6 时，可以如下构造： ( ( ( ( ( ( ( ( ( ) ( ) ( ) ( ) ( ( ) ( ) ( ) ) ( ( ( ( ) ) ) ) ( ( ) ( ) ( ) ) ) ) ) ) ) ) ) ) 答案是 w+h−4。同理可证明不存在更优的方法。 在实际操作的时候如果$h&gt;m$可以将矩阵反转一下。就ok了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint t,h,w;char g[300][300];int main(){#ifdef LOCAL freopen(&quot;d.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;t); while(t--){ bool flag = 0; scanf(&quot;%d%d&quot;,&amp;h,&amp;w); if(h&amp;1){ rep(i,0,h){ rep(j,0,w){ g[i][j] = (j&lt;w/2 ? '(' : ')'); } } }else if(w&amp;1){ rep(i,0,h){ rep(j,0,w){ g[i][j] = (i&lt;h/2 ? '(' : ')'); } } } else{ if(h&gt;w){ int temp = h; h = w; w = temp; flag = 1; } if(h==2){ rep(i,0,w){ g[0][i] = '('; g[1][i] = ')'; } }else if(h == 4){ rep(i,0,w){ g[0][i] = '('; g[1][i] = (i&lt;w/2 ? ')' : '('); g[2][i] = (i&lt;w/2 ? '(' : ')'); g[3][i] = ')'; } }else{ rep(i,0,h){ rep(j,0,w){ if(i==0 || j==0) g[i][j] = '('; else if(i == h-1 || j == w-1) g[i][j] = ')'; else if((i^j)&amp;1) g[i][j] = ')'; else g[i][j] = '('; } } } } if(flag){ rep(j,0,w){ rep(i,0,h){ putchar(g[i][j]); } puts(&quot;&quot;); } }else{ rep(i,0,h){ rep(j,0,w){ putchar(g[i][j]); } puts(&quot;&quot;); } } } return 0;}","link":"/acm/2018/08/24/2018-Multi-University-Training-Contest-8-D-Parenth.html"},{"title":"4月计划","text":"4月9日 背单词 数学全书复习 cf两道题目 4月10日上午满课，下午2点可以开始学习。 背一篇作文，熟悉到能够默写。 cf两道题目 数学10道小题 —3道 linux作业完成 makefile搞定一下，顺便把原来历史遗留的编译原理大作业用makefile写一下。pro~ 结果看知乎看到六点，英语也没背，就去做了个ccpc2050热身赛的题目。 4月17日 周三上午下午各一节课。有点难受。上午三四节的时间摸鱼。 下午3.40左右开始正式学习 背单词 cf.div2 D和E solve 数学20题，先看笔记后做题 至少看一节视频，并做笔记。 汤神！！！","link":"/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/2019/04/10/4%E6%9C%88%E8%AE%A1%E5%88%92.html"},{"title":"51Nod-1593 公园晨跑","text":"51Nod-1593 公园晨跑题意给定一个环，环上有$n$个点，每个点有一个权值$h$代表着如果从$i$到$j$的话，你必须加上$2h_i+2h_j$。并且加上他们之间的距离$L$。并且在环上会有一个区间被占用导致只能从另外一个方向走。 题解线段树维护区间最大最小值的坐标和特判相同处理。 首先，面对环和方向性，我们可以把环拆成链式。形成一个$[1,n] \\cup [1.n]$的区间对于$X,Y$的查找可以看成两种情况， 一种是$X\\leq Y$，那么我们寻找的范围就是$[Y+1,X+n-1]$。 对于$X&gt;Y$的情况，我们寻找的范围就是$[Y+1,X-1]$。 定义$d[x]$为$x$点到第一个点的距离(线性)。 对于给定的两个点$X,Y$，我们获得的权值是确定的，为$d[Y]-d[X]+2h[X]+2h[Y]$，我们可以将这个算式分为$X$部分和$Y$部分。于是我们就可以将式子转化为 $target = (d[Y]+2h[Y]) - (d[X]-2h[X])$ 这个式子求最大值，就是对于每个点求第一部分的最大值和第二部分的最小值。之后由于$X != Y$，所以对于线段树维护的是区间内最大最小值的坐标。当坐标相同时，寻找次一级的最小值或者次一级的最大值。 AC代码(要加入读入优化)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const ll INF = 1e11;//headconst int maxn = 2e5 + 10;ll h[maxn],d[maxn],A[maxn],B[maxn];int mmax[maxn&lt;&lt;2],mmin[maxn&lt;&lt;2];template &lt;class T&gt;bool read(T &amp;x){ char c; bool op = 0; while(c = getchar(), c &lt; '0' || c &gt; '9') if(c == '-') op = 1; else if(c == EOF) return 0; x = c - '0'; while(c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; if(op) x = -x; return 1;}inline int Max(int a,int b){ return A[a] &gt; A[b] ? a : b;}inline int Min(int a,int b){ return B[a] &lt; B[b] ? a : b;}inline ll Mmax(ll a,ll b){ return a&gt;b?a:b;}int m,n;void pushup(int rt){ mmax[rt] = Max(mmax[rt&lt;&lt;1],mmax[rt&lt;&lt;1|1]); mmin[rt] = Min(mmin[rt&lt;&lt;1],mmin[rt&lt;&lt;1|1]);}void build(int l,int r,int rt){ if(l==r){ mmax[rt] = l; mmin[rt] = l; return ; } int mid = (r+l)&gt;&gt;1; build(lson);build(rson); pushup(rt);}int query_max(int L,int R,int l,int r,int rt){ if(L &lt;= l &amp;&amp; r &lt;= R) return mmax[rt]; int mid = (l+r) &gt;&gt; 1; ll res = 0; if(L &lt;= mid) res = Max(res,query_max(L,R,lson)); if(mid &lt; R) res = Max(res,query_max(L,R,rson)); return res;}int query_min(int L,int R,int l,int r,int rt){ if(L &lt;= l &amp;&amp; r &lt;= R) return mmin[rt]; int mid = (l+r) &gt;&gt; 1; ll res = 0; if(L &lt;= mid) res = Min(res,query_min(L,R,lson)); if(mid &lt; R) res = Min(res,query_min(L,R,rson)); return res;}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,2,n+2) read(d[i]),d[n+i] = d[i]; rep(i,2,n*2+1) d[i] += d[i-1]; rep(i,1,n+1){ ll hh;read(hh); h[i] = h[i+n] = hh; } A[0] = -INF;B[0] = INF; rep(i,1,n+n+1){ A[i] = 2*h[i] + d[i]; B[i] = d[i] - 2*h[i]; } build(1,n*2,1); while(m--){ int l,r;read(l);read(r); if(l&lt;=r){ int st = query_max(r+1,l+n-1,1,2*n,1); int ed = query_min(r+1,l+n-1,1,2*n,1); ll ans; if(st == ed){ int st1 = Max(query_max(st+1,l+n-1,1,2*n,1),query_max(r+1,st-1,1,2*n,1)); int ed1 = Min(query_min(ed+1,l+n-1,1,2*n,1),query_min(r+1,ed-1,1,2*n,1)); ans = Mmax(A[st] - B[ed1],A[st1] - B[ed]); }else ans = A[st] - B[ed]; printf(&quot;%lld\\n&quot;,ans); }else{ int st = query_max(r+1,l-1,1,2*n,1); int ed = query_min(r+1,l-1,1,2*n,1); ll ans; if(st == ed){ int st1 = Max(query_max(st+1,l-1,1,2*n,1),query_max(r+1,st-1,1,2*n,1)); int ed1 = Min(query_min(ed+1,l-1,1,2*n,1),query_min(r+1,ed-1,1,2*n,1)); ans = Mmax(A[st] - B[ed1],A[st1] - B[ed]); }else ans = A[st] - B[ed]; printf(&quot;%lld\\n&quot;,ans); } } return 0;} reference:https://blog.csdn.net/ZLH_HHHH/article/details/74887389","link":"/acm/2018/08/27/51Nod-1593-%E5%85%AC%E5%9B%AD%E6%99%A8%E8%B7%91.html"},{"title":"[77c Beavermuncher-0xFF树形dp+贪心","text":"C. Beavermuncher-0xFF题意给你一颗树，树上的每个节点有$n$个海狸。现在你在节点$root$上你前往下一个节点的条件是下一个节点上面至少有一个海狸，之后你到这个节点之后，你就会吃掉这个海狸。问最多能吃掉多少只海狸。 题解贪心+树形dp ac代码","link":"/acm/2018/11/11/77c-Beavermuncher-0xFF%E6%A0%91%E5%BD%A2dp-%E8%B4%AA%E5%BF%83.html"},{"title":"9.9-9.15计划","text":"一周计划 9.9 - 9.15数学 完成线性代数部分，一天一章李永乐强化 每天回顾错题以及一元函数积分的习题 5题 英语 单词达标。 三天阅读模拟+完型+新题型 第一天集中做， 第二第三天精读 三天中最后一天背一篇范文。 政治《知识点精讲精练》《讲真题》《1000题》 一天一章，如果学累了看视频，看完一章立刻做完1000题中对应单元 课余时间看徐涛视频 专业课 一天半章 数据结构选择题，争取这周选择题结束，并且摘错题。 C语言教材无聊的时候看一下。","link":"/%E8%80%83%E7%A0%94/2019/09/12/9-9-9-15%E8%AE%A1%E5%88%92.html"},{"title":"A. Rikka with Nash Equilibrium","text":"A. Rikka with Nash Equilibrium题解：神仙dp题 将数字从大到小一次排列，从大往小取. 构造一个三维$dp[now][j][k]​$,表示放入$now​$数字的时候有$i​$行和$j​$列有数字下的情况。为了防止数字成为平衡位置，每次放置的位置都要放置在之前放置元素所在的列或者行上，如果不这么放置的话，他就会成为剩下当前行和当前列最大的(就没能有比他大的数字了)。 初始化，因为第一个数字可以任意存放所以$dp[0][1][1]=m*n$。 转移方程: 该点放置位置上行和列都有元素，那就是有$i$列和$j$行可以存放。剩下的位置是$j*k-i+1$ ，$dp[next][j][k]+=dp[now][j][k]*(jk-i+1)$ 该点放置位置上列已经有元素了，但是行上没有元素，从位置的行数减一转移加了一行$dp[next][j][k]+=dp[now][j-1][k]*j(n-i+1)$ 同理如果行有元素的话。$dp[next][j][k]+=dp[now][j][k-1]*i(m-j+1)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 88;int t,m,n;ll mod;ll dp[2][maxn][maxn];inline ll add(ll a, ll b){ return (a+b&gt;mod)?(a+b)%mod:a+b;}inline ll mul(ll a,ll b){ return a*b&gt;mod?(a*b)%mod:a*b;}int main(){#ifdef LOCAL freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d%d%lld&quot;,&amp;n,&amp;m,&amp;mod); memset(dp,0,sizeof(dp)); dp[0][1][1] = n*m; int now = 0; rep(i,2,m*n+1){ int nxt = now^1; memset(dp[nxt],0,sizeof(dp[nxt])); rep(j,0,n+1){ rep(k,0,m+1){ if(dp[now][j][k]){ ll tot = j*k - i + 1; dp[nxt][j][k] = add(dp[nxt][j][k],dp[now][j][k]*tot); dp[nxt][j+1][k] = add(dp[nxt][j+1][k],mul(dp[now][j][k],1ll*k*(n-j))); dp[nxt][j][k+1] = add(dp[nxt][j][k+1],mul(dp[now][j][k],1ll*j*(m-k))); //cout&lt;&lt;dp[now][j][k]; } } } now = nxt; } printf(&quot;%lld\\n&quot;,dp[now][n][m]); } return 0;}","link":"/acm/2018/08/24/A-Rikka-with-Nash-Equilibrium.html"},{"title":"ACM-ICPC 2018 徐州赛区网络预赛","text":"ACM-ICPC 2018 徐州赛区网络预赛A. Hard to prepare题意$n$个人围成环，每个人可以选择$[0,2^k-1]$中的一个数字，要求相邻两人不能同或为0。 题解递归。 可以YY出，第一个人有$2^k$种选择，之后第2到第$n-1$个人有$2^k-1$种选择，最后一个人可能可以选$2^k-2$，也可能可以选$2^k-1$。这取决于倒数第二个人是否跟第一个人选一样的。这时候我们就可以加上如果第一个人和倒数第二个人选择相同，并且，最后一个人多选了那$2^k-1-(2^k-2)$种，那么他们三个点变成一个点来选择了。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,k;const ll mod = 1e9+7;ll pow3(ll a,ll b){ ll ans = 1; while(b){ if(b&amp;1) ans = ans*a%mod; a = a*a%mod; b&gt;&gt;=1; } return ans;}ll k2,kk2,kk1;ll solve(int n,int k){ if(k==1) return 2; if(n==1) return k2; if(n==2) return k2*kk1%mod; ll res = (k2*kk2%mod)*pow3(kk1,n-2)%mod; res = (res+solve(n-2,k))%mod; return res;}int main(){#ifdef LOCAL freopen(&quot;4.in&quot;,&quot;r&quot;,stdin);#endif int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); k2 = pow3(2,k); kk1 = (k2-1+mod)%mod; kk2 = (k2-2+mod)%mod; printf(&quot;%lld\\n&quot;,solve(n,k)); } return 0;} B.BE,GE or NE题意两个人玩游戏，给出$[0,3]$个选项和一个$m$初始值，两个人依次选择，有以下三种选择 选择将值$+a$ 选择将值$-b$ 选择将值倒过来 $m=-m$ 两个人一个想将值变大，一个想让值变小，两个人都知晓所有情况和选项，在最优情况下，问谁赢。 题解博弈论dp+记忆化搜索 因为数据量很小，范围也在200之间，所以记忆化状态回复的很多。 $dp[pos][val]$表示在pos位置数值是val,之后dp代表的是最优可以赢还是输还是平，分别用2,1,0代表。 之后对于边界值要处理一下。数组存不了负值，我们统一加100处理。 妈的。我看到这个以为是纯博弈论直接人傻了。之后想着能不能记忆化搜索，但是看到$n=1000$还以为他喵的会爆，但是这道题的情况限制在范围$-100到100$，所以情况很少。所以可以直接记忆化，不过对于答案的选择和状态转移我可能还是不会太轻松地做出来，带int的dfs我还是不怎么熟悉，这按道理应该是算是博弈论dp了。从最优状态转移到最优状态。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%mod;a=a*a%mod;}return res;}ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}// headint n,m,k,l;const int maxn = 1e3 + 10;int a[maxn],b[maxn],c[maxn];int dp[maxn][220];// opint dfs(int pos,int val){ if(pos == n){ if(val &gt;= k){ return 2; }else if(val &gt; l){ return 1; }else{ return 0; } } if(dp[pos][val] != -1) return dp[pos][val]; if(pos%2==0){ int res = 0; int mmin = min(200,val+a[pos]); int mmax = max(0,val-b[pos]); if(a[pos]) res = max(res,dfs(pos+1,mmin)); if(b[pos]) res = max(res,dfs(pos+1,mmax)); if(c[pos]) res = max(res,dfs(pos+1,200-val)); return dp[pos][val] = res; }else{ int res = 2; int mmin = min(200,val+a[pos]); int mmax = max(0,val-b[pos]); if(a[pos]) res = min(res,dfs(pos+1,mmin)); if(b[pos]) res = min(res,dfs(pos+1,mmax)); if(c[pos]) res = min(res,dfs(pos+1,200-val)); return dp[pos][val] = res; }}int main(){#ifdef LOCAL freopen(&quot;b.in&quot;,&quot;r&quot;,stdin);#endif // LOCAL rep(i,0,maxn) rep(j,0,220) dp[i][j] = -1; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;l); l += 100; k += 100; m += 100; rep(i,0,n){ scanf(&quot;%d%d%d&quot;,a+i,b+i,c+i); } int op = dfs(0,m); if(op==2) puts(&quot;Good Ending&quot;); else if(op==1) puts(&quot;Normal Ending&quot;); else puts(&quot;Bad Ending&quot;); return 0;}","link":"/acm/2018/09/10/ACM-ICPC-2018-%E5%BE%90%E5%B7%9E%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B.html"},{"title":"ALBERT 更小但是更慢？","text":"ALBERT 更小但是更慢？最近由于参加阅读理解比赛，所以大量测试各种模型，惊奇地发现原本现在阅读理解比赛中SOTA的模型居然是不起眼并且以小模型闻名的ALBERT。这让我对这个“小”模型产生了好奇。从而写一下这份的论文笔记。 摘要模型越大下游效果越强是众所周知的道理，但是由于硬件设备和显存所限，所以模型不能无限制得放大。这篇文章提出了一个全面领先BERT模型的ALBERT，在比BERT-LARGE参数小的情况下超过了它。 有何区别1. embedding 参数减少在从one-hot embedding到hidden size embedding有一个$V \\times H$的全连接层，这里使用了一个trick，加了一个hidden layer，从而使得全连接层变成了$V\\times E + E\\times H$。这样子我们就可以用一个很大的$H$了，比如在xxlarge上就是$H=4096$。 2.层间参数共享很简单，就是原来模型类似于$F(x) = f_n(f_{n-1}(…f_1(x)))$，但是现在变成了$F(x)=f(f(…f(x)))$。我也在想，虽然$f(x)$是一个非线性的，但这种形式是不是可以有函数去拟合$F(x)$，毕竟重复$f(x)$这不能优化吗？ 去压缩ALBERT模型的大小。 3. SOP提出了一个新的self supervised learning 的 objective，既SOP(sentence ordering objectives)。类似于BERT预测两个句子是否是连续的，ALBERT需要预测打乱句子的顺序。 并在在对比中，SOP对于RACE也就是阅读理解任务提高了2.3个点，很哇塞 实验实验部分具体暂且不表。我理解的有几点 额外的领域内预训练是有益的，但是领域外可能会有害 dropout在模型不会over-fit的情况下其实可以忽略，在batch normalization和dropout可能会损害模型的性能。 hidden size 4096 有可能是ALBERT 性能强的主要原因。 虽然层间参数共享，理论上可以无限深，但是实验发现24层并没有12层效果好。特别宽也没有特别好，这都是玄学调参，很难人工判断。 按理来说fffff(x) 可能会导致每层之间的输出过于相似，但在这里实验发现，并没有。难道是embed layer就很强了？ 猜测 改进点 稀疏矩阵优化，attention 魔改 SOP是否可以泛用。","link":"/%E8%AE%BA%E8%A7%A3/2020/11/18/ALBERT-%E6%9B%B4%E5%B0%8F%E4%BD%86%E6%98%AF%E6%9B%B4%E6%85%A2%EF%BC%9F.html"},{"title":"Appleman_and_Tree","text":"Appleman and Tree链接 如果觉得我的题解看不懂可以去看 大佬的题解 题目大意将一颗树节点染成白色或者黑色，减去几条变使得每个联通分支都有一个黑色节点，问有多少种减边方案。 题解树状dp+dfs 下次看到两种状态加点的。dp应该想到用2维。 定义$dp[i][j]$表示点$i$在以点$i$为根的子树去掉点$i$所在的联通快有黑点$1$和无黑点$0$的方案数 假设点$u$，首先如果$u$是黑色，那么$$dp[i][1]=1$$，否则$dp[i][0]=1$。 点$u$加入一个子树$v$。假设原来$u$没有黑点。 如果加入的$v$是有黑点的，有两种选择，切断边$u$还是没有黑点，方案数$dp[u][0]=dp[u][0]*dp[v][1]$，不切断边$u$就产生了黑点$dp[u][1]=dp[u][0]*dp[v][1]$ 如果加入的$v$是无黑点的，只能选择不切断。方案数$dp[u][0]=dp[u][0]*dp[v][0]$ 点$$u$$加入一个子树$v$。假设原来$u$有黑点。 如果加入的$v$是有黑点的，只能选择切断，方案数$dp[u][1]=dp[u][1]*dp[v][1]$ 如果加入的点$v$是无黑点的，只能选择切断，因为不能产生无黑点的联通分支，方案数$dp[u][1]=dp[u][1]*dp[v][0]$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5 + 5;const ll mod = 1e9 + 7;struct node{ int to,next;}G[maxn&lt;&lt;1];int cnt;ll dp[maxn][2];int head[maxn];void add(int from,int to){ G[cnt].to = to; G[cnt].next = head[from]; head[from] = cnt++;}int n;void dfs(int u,int fa){ for(int i = head[u];~i;i=G[i].next){ int v = G[i].to; if(v == fa) continue; dfs(v,u); dp[u][1] = dp[u][1]*dp[v][1]%mod + dp[u][0]*dp[v][1]%mod + dp[u][1]*dp[v][0]%mod; dp[u][1] %= mod; dp[u][0] = dp[u][0]*dp[v][0]%mod + dp[u][0]*dp[v][1]%mod; dp[u][0] %= mod; }}int main(){#ifdef LOCAL freopen(&quot;B.in&quot;,&quot;r&quot;,stdin);#endif memset(head,-1,sizeof(head)); scanf(&quot;%d&quot;,&amp;n); rep(i,1,n){ int v; scanf(&quot;%d&quot;,&amp;v); add(i,v);add(v,i); } rep(i,0,n){ scanf(&quot;%d&quot;,&amp;dp[i][1]); if(dp[i][1]==0) dp[i][0] = 1; } dfs(0,-1); cout&lt;&lt;dp[0][1]&lt;&lt;endl; return 0;}","link":"/acm/2018/08/19/Appleman-and-Tree.html"},{"title":"Codeforces 833B - The Bakery","text":"Codeforces 833B - The Bakery题意将一段数字分成最多50个区间，每个区间的价值是区间内不同数字的个数，问怎么样分区间使得价值总和最大。 题解$dp$加线段树。 $dp[i][j]$表示第$j$个坐标分成$i$块最大的价值。 转移方程 $dp[i][j] = max(dp[i][j],dp[i-1][x] + restofx)$，其中$x$是从1到$j$。 因为每次要获得剩下的x中数字不同的个数，暴力的做法是$O(n^2*k)$， ac代码","link":"/%E7%BA%BF%E6%AE%B5%E6%A0%91/2018/09/21/Codeforces-833B-The-Bakery.html"},{"title":"Codeforces Round #499 (Div. 2)","text":"Codeforces Round #499 (Div. 2)](http://codeforces.com/contest/1011)A. Stages题意给定一段序列，每个字母代表这一个权值，比如$a$代表$1$。之后问从中挑选出一个序列，要求$a[i]$和$a[i+1]$之间相隔一个字母，问从任意顺序选择$k$个字母，最少可以有多少权值。 题解贪心，其实如果取最大值的话， 我就有点不会了。但是取最小值可以贪心的对所有位置都取能取的最小值。 AC代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,k;const int maxn = 60;char s[maxn];int a[maxn];int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;n,&amp;k); scanf(&quot;%s&quot;,s); int len = strlen(s); rep(i,0,n) a[i] = s[i] -'a'+1; sort(a,a+len); int ans = 0;int t = 0;int si = -3; rep(i,0,len){ if(si&lt;a[i]-1 &amp;&amp; t&lt;k){ ans +=a[i]; t++; si = a[i]; } } if(t==k){ printf(&quot;%d\\n&quot;,ans); }else{ puts(&quot;-1&quot;); } return 0;} B. Planning The Expedition题意每个人每天都要吃一个特定种类(由你分配)的食物，你现在有$k$种食物，每个食物都有对应的数量，问怎么分配可以在当前食物下过存活尽量多的天数。 题解二分枚举答案(坑爹cf，$m&lt;100$二分都不用)。因为答案是递减的。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint m,n;const int maxn = 110;int a[maxn],b[maxn];bool cmp(int a,int b){ return a&gt;b;}int cnt,ans;void dfs(int day,int idx,int p){ if(p &lt;= 0){ ans = max(ans,day); return; } if(idx ==cnt) return; for(int i=1;i&lt;=a[idx];i++){ if(a[idx] / i &lt; day) continue; dfs(day,idx+1,p-i); }}int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,1,m+1){ int x;scanf(&quot;%d&quot;,&amp;x); a[x]++; } ans = 0; sort(a+1,a+m+1,cmp); rep(i,1,101) if(a[i]==0) {cnt = i;break;} for(ans = 1;ans&lt;=100;ans++){ int peo = 0; rep(i,1,10){ peo += a[i]/ans; } if(peo &lt;n){ break; } } printf(&quot;%d\\n&quot;,ans-1); return 0;} C.Fly题意每次降落和出发都需要消耗燃料，问最少带多少燃料可以来一次旅行。 题解小学奥数题，反向做即可。 AC代码1 D. Rocket题意猜数字，你问至多$60$次数字，他给出你问的数字是大了还是笑了，他有一个循环答题方案，比如第一次打错，第二次答对，循环少于$30$次。让你问出答案。 题解循环至多$30$次暗示了你可以故意说一些已知的问题来试他。比如问-1是大了还是小了。之后就是简单的二分了。 心路历程：第一次做交互题，输入输出完全搞不懂。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,m;bool vis[100];int query(int x){ int y; cout&lt;&lt;x&lt;&lt;endl; fflush(stdout); cin&gt;&gt;y; return y;}int main(){#ifdef LOCAL //freopen(&quot;4.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;m,&amp;n); rep(i,0,n){ int x = query(1); if(x == 0){ cout&lt;&lt;1&lt;&lt;endl; return 0; } if(x&lt;0) vis[i] = 1; } int mid = 0;int cnt = 0; int l,r; l = 1,r = m; while(l&lt;=r){ mid = (l+r)&gt;&gt;1; int y = query(mid); if(vis[cnt]) y = -y; if(y==1) l = mid+1; else if(y==-1)r = mid-1; else{ cout&lt;&lt;mid&lt;&lt;endl; return 0; } cnt = (cnt+1)%n; } return 0;}","link":"/cf1500/2018/09/02/Codeforces-Round-499-Div-2.html"},{"title":"Codeforces Round #542","text":"Codeforces Round #542A. Be Positive题意给定一个数组$a_1,a_2,…,a_n$，让你到一个数字，是的数组内的所有数字处以这个数字之后，数组内大于0的数字超过$\\cfrac{n}{2}$的上界。 题解由于没有要求整除，所以直接看负数多还是正数多，哪个超过上届，就用$-1或者1$ ac代码12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n;const int maxn = 1e3+10;int a[maxn];int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;n); int cnt1=0,cnt2=0; rep(i,0,n){ scanf(&quot;%d&quot;,a+i); if(a[i]&gt;0) cnt1++; if(a[i]&lt;0) cnt2++; } int ans = 0; if(n%2) n++; if(cnt1&gt;=n/2) ans = 1; if(cnt2&gt;=n/2) ans = -1; printf(&quot;%d&quot;,ans); return 0;} B. Two Cakes题意两个人要买$n$层蛋糕，他们必须从$1$开始买到$n$，之后给定$2n$个蛋糕店，他们从$1$这个点出发，之后去买蛋糕。其中一旦一个人从一家蛋糕店买了蛋糕，那么另外一个人就不能在那家蛋糕店买蛋糕。问两个人花费的最少步数是多少？ 题解由于每一步只有两种可能，一个人去$x+1$中的一家蛋糕店，另外一个人去另一家。每一步的选择都只有两种，且无后效性。所以我们用贪心来解决。每一步的时候都选择花费步数最少的选择。 ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5+10;int n;struct node{ int idx,val; bool operator&lt;(const node &amp;x){ return val &lt; x.val; }}a[maxn&lt;&lt;1];int vis[maxn*2];int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;n); rep(i,0,2*n){ int x; scanf(&quot;%d&quot;,&amp;x); a[i].idx = i+1; a[i].val = x; } sort(a,a+2*n); int cnt = 0; int now1 = 1, now2 = 1; ll ans = 0; for(int i=0;i&lt;2*n;i+=2){ int temp = INF; int x1 = abs(now1 - a[i].idx) + abs(now2 - a[i+1].idx); int x2 = abs(now2 - a[i].idx) + abs(now1 - a[i+1].idx); if(x1&gt;x2){ now2 = a[i].idx; now1 = a[i+1].idx; }else{ now1 = a[i].idx; now2 = a[i+1].idx; } ans += 1ll * min(x1,x2); } printf(&quot;%lld\\n&quot;,ans); return 0;} C. Connect题意Alice要从一个陆地到另外一块陆地，需要建造一座大桥，问桥的花费要最少。 桥的花费是欧几里得距离的平方 只能建造一座桥 可能不需要建造桥 题解由于只建造一座桥，所以我们可以枚举起始点的陆地和终点的陆地，之后挑选出最近的点。 由于数据小，随便做。 ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n;int stx,sty,edx,edy;int dir[4][2] = {1,0, -1,0, 0,1, 0,-1};const int maxn = 100;int vis[maxn][maxn];char mx[maxn][maxn];vector&lt;pII &gt; st;vector&lt;pII &gt; ed;void bfs(int x,int y,bool sign){ vis[x][y] = 1; queue&lt;pair&lt;int,int&gt; &gt;q; q.push(make_pair(x,y)); while(!q.empty()){ int xx = q.front().first; int yy = q.front().second; q.pop(); if(sign) st.push_back(make_pair(xx,yy)); else ed.push_back(make_pair(xx,yy)); rep(i,0,4){ int xxx = xx + dir[i][0]; int yyy = yy + dir[i][1]; if(xxx&lt;0 || xxx &gt;=n || yyy&lt;0 || yyy&gt;=n) continue; if(mx[xxx][yyy] == '1') continue; if(vis[xxx][yyy]) continue; vis[xxx][yyy] = 1; q.push(make_pair(xxx,yyy)); } }}int main(){#ifdef LOCAL freopen(&quot;3.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%d%d%d%d&quot;,&amp;stx,&amp;sty,&amp;edx,&amp;edy); stx--;sty--;edx--;edy--; rep(i,0,n){ scanf(&quot;%s&quot;,mx+i); } int ans = INF; bfs(stx,sty,1); bfs(edx,edy,0); int len1 = st.size(); int len2 = ed.size(); rep(i,0,len1){ rep(j,0,len2){ int x1 = st[i].first; int y1 = st[i].second; int x2 = ed[j].first; int y2 = ed[j].second; ans = min(ans,(x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)); } } printf(&quot;%d\\n&quot;,ans); return 0;} D2. Toy Train题意Alice开火车，他火车的轨道是确定的，之后火车开的方向也是确定的，火车的轨迹是一个圈，轨迹上有很多站点，每个站点上有糖果。 火车在站点上只可以拿起一个糖果 火车在站点上可以放下无限个糖果 目标是将所有站点上的糖果放到指定的站点所花费的时间最小。 题解由于每一个站点都是独立的。你只需要管他是怎么拿起来的。所以每一个站点如果有$x$个糖果，那么从他开始至少要$x-1$圈加上一个最短的距离。所以我们可以枚举每一个站点所需要的最远距离。 假设从$i$起始点到$j$站点。那么我们开始的距离是$dis(i,j)=(j-i+n)\\mod n$。 之后我们需要$x-1$圈。$(x-1)\\times n$ 之后我们需要从那个点到最近的放置点.$dis(j,z) = (z-j+n)\\mod n$ 之后两层循环即可。 ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e3+10;const int maxm = 2e2+10;int n,m;vector&lt;int&gt; candys[maxn];int ans[maxn];int main(){#ifdef LOCAL freopen(&quot;4.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,0,m){ int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); candys[x-1].push_back(y-1); } int mmax = 0; rep(i,0,n){ mmax = max(mmax,(int)candys[i].size()); } // ans rep(i,0,n){ int ans = 0; rep(j,0,n){ if(candys[j].size()==0)continue; int temp = (j-i+n)%n; int tx = INF; for(auto &amp;x: candys[j]){ tx = min(tx,(x-j+n)%n); } ans = max(ans, ((int)candys[j].size()-1)*n + tx + temp); } printf(&quot;%d &quot;,ans); } return 0;}","link":"/cf/2019/03/02/Codeforces-Round-542.html"},{"title":"[Codeforces Round #546 (Div. 2)题解]","text":"Codeforces Round #546 (Div. 2)D题题目读错把爷给整自闭了，此篇题解除了D都只有代码了 A. Nastya Is Reading a Book做法暴力 ac代码12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n;vector&lt;int&gt; ve;int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;n); rep(i,0,n){ int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); ve.push_back(r); } int page; scanf(&quot;%d&quot;,&amp;page); int idx = lower_bound(ve.begin(),ve.end(),page) - ve.begin(); printf(&quot;%d\\n&quot;,n-idx); return 0;} B. Nastya Is Playing Computer Games题解找规律。 两个一组要六次。 ac代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif int n,a; scanf(&quot;%d%d&quot;,&amp;n,&amp;a); int ans = 0; if(n&amp;1) ans+=3,ans += (n-1)*3; else ans += n*3; int mmin = min(n-a,a-1); ans += mmin; printf(&quot;%d\\n&quot;,ans); return 0;} C. Nastya Is Transposing Matrices题解只有从左下到右上的有用。找规律。 我写得坐标变换有点绕。 ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,m;const int maxn = 5e2+10;int mx1[maxn][maxn], mx2[maxn][maxn];int main(){#ifdef LOCAL freopen(&quot;3.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,0,n) rep(j,0,m) scanf(&quot;%d&quot;,mx1[i]+j); rep(i,0,n) rep(j,0,m) scanf(&quot;%d&quot;,mx2[i]+j); bool ans = true; n = max(n,m); rep(i,0,n){ map&lt;int,int&gt;mmp; rep(j,0,i+1){ mmp[mx1[i-j][j]]++; } rep(j,0,i+1){ mmp[mx2[i-j][j]]--; if(mmp[mx2[i-j][j]] == 0) mmp.erase(mx2[i-j][j]); } if(mmp.size()&gt;0) ans = false; if(!ans) break; } rep(i,0,n){ map&lt;int,int&gt;mmp; rep(j,0,n-i){ mmp[mx1[n-j][i+j]]++; } rep(j,0,n-i){ mmp[mx2[n-j][i+j]]--; if(mmp[mx2[n-j][i+j]] == 0) mmp.erase(mx2[n-j][i+j]); } if(mmp.size()&gt;0) ans = false; if(!ans) break; } if(ans) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); return 0;} D. Nastya Is Buying Lunch题意Nastya去排队，队伍中有这样一个规律。 已知有$m$对$(i,j)$，他们如果是相邻的话，并且$i$在$j$的前面，那么他们就可以调换位置。 问Nastya能够往前调换多少次位置，已知Nastya在最后一名。 题解一开始我是看错题意，以为是可以隔空调换，直接想着用图论找一个环或者是找一个树来做。没有想到必须要相邻才能换，那么我们就可以这样想，我们的答案最多就只有$Nastya能够往前交换的人的数量$。之后我们尽可能的就是将不能交换的人往前面移动，能交换的人往后面移动。之后由于是一个一个相邻的同学移动，所以如果从前开始尽量往后移动的话，有可能会有的同学到达不到Nasyta的范围了。从后往前交换，那么我们就是将不可换的同学尽量地想前面推，之后如果前面的同学先交换到后面，那么对河Nasyta可以到达的来说，他也是一定能交换到Nasyta到达的点的。 举个栗子: 4 4 1 2 3 4 2 4 1 4 1 2 1 3 ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,m;const int maxn = 3e5+10;int idx[maxn];set&lt;int&gt; st[maxn];int a[maxn];int vis[maxn];int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,1,n+1){ int x; scanf(&quot;%d&quot;,&amp;x); a[i] = x; idx[x] = i; } rep(i,0,m){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); st[x].insert(y); if(y == a[n]) vis[x] = 1; } per(i,1,n-1){ if(vis[a[i]] == 0) continue; int t = i; while(t&lt;n-1 &amp;&amp; st[a[t]].find(a[t+1]) != st[a[t]].end()){ swap(a[t],a[t+1]); t++; } } int ans = 0; per(i,1,n){ if(vis[a[i]] == 0) break; ans++; } printf(&quot;%d&quot;,ans); return 0;}","link":"/cf/2019/03/18/Codeforces-Round-546-Div-2-%E9%A2%98%E8%A7%A3.html"},{"title":"DNA Sequence","text":"DNA Sequence题意给定$m$个指定串，寻找长度为$n$的不含指定串的字符串。 题解AC自动机+dp+矩阵快速幂。 如果要不含病毒串，那么我们相当于在每个状态中不能指向那个病毒终点串。对于每个状态来说，可以选择的就是4个字母去掉下一个状态是病毒的字母。 $dp[i] += dp[j] (j是非病毒终点)$ 初始化$dp[i]$为可以选择的字母。相当于$i$状态加上状态$j$乘上字母数。可以构造一个矩阵mx。$mx[i][j]$表示$i$到$j$的字母数，矩阵的$n$次方之后就是经过$n$个状态转化后的值。 举个例子，比如我们是AC,AT,AG,AA这四个病毒串，那么root = 0,A是1,C=2,T=3,A=4。有五个状态。 当我们状态为0的时候，有两种选择。我们到状态0的选择字母可以选3个’C’’T’’G’。到状态1可以选1个’A’。之后到状态1没有选择了，因为全是病毒串。所以我们的矩阵是 3 1 0 0 之后矩阵乘就完事了。 我感觉讲得有点不清楚。。。 +2 TLE因为矩阵的大小是有build的trie树决定的，所以越小越好用ac.tot来表示矩阵的大小，也就是状态的大小。 +10 矩阵的大小其实是状态的大小，状态的大小是 输入的病毒串长度*病毒串的次数。最大tot为这么大。 +1 因为转移的状态只有四种，所以maxson为4就好了，大了的话创造矩阵的时候会出现问题。 ###ac代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxson = 4;const ll mod = 100000;int n,m;const int MAX = 110;int tot = 0;struct Matrix{ ll mx[MAX][MAX]; int n; Matrix(){memset(mx,0,sizeof(mx)); n = MAX;} Matrix operator +(const Matrix &amp;b)const{ Matrix res; rep(i,0,MAX) rep(j,0,MAX) res.mx[i][j] = (mx[i][j]+b.mx[i][j])%mod; return res; } Matrix operator *(const Matrix &amp;b) const{ Matrix res; rep(i,0,tot) rep(j,0,tot) { rep(k,0,tot){ res.mx[i][j] += mx[i][k]*b.mx[k][j]; } res.mx[i][j] %= mod; } return res; } void debug(){ rep(i,0,n){ rep(j,0,n){ cout&lt;&lt;mx[i][j]&lt;&lt;' '; } cout&lt;&lt;endl; } }}U,V;Matrix pow3(Matrix f,int n){ Matrix res; rep(i,0,MAX) res.mx[i][i] = 1; while(n){ if(n&amp;1) res = res*f; n&gt;&gt;=1; f = f*f; } return res;}struct Trie{ int next[20*20][maxson],fail[20*20],flag[20*20]; int root,tot; int encode[256]; int newnode(){ rep(i,0,maxson) next[tot][i] = -1; flag[tot++] = 0; return tot-1; } void init(){ tot = 0; root = newnode(); encode['A'] = 0; encode['T'] = 1; encode['C'] = 2; encode['G'] = 3; memset(flag,0,sizeof(flag)); } void insert(char *s,int id){ int len = strlen(s); int now = root; rep(i,0,len){ int k = encode[s[i]]; if(next[now][k] == -1) next[now][k] = newnode(); now = next[now][k]; } flag[now] = id; } void build(){ queue&lt;int&gt; q; fail[root] = root; rep(i,0,maxson){ if(next[root][i] == -1){ next[root][i] = root; }else{ fail[next[root][i]] = root; q.push(next[root][i]); } } while(!q.empty()){ int now = q.front(); q.pop(); if(flag[fail[now]]) flag[now] = 1; rep(i,0,maxson){ if(next[now][i] == -1){ next[now][i] = next[fail[now]][i]; }else{ fail[next[now][i]] = next[fail[now]][i]; q.push(next[now][i]); } } } } Matrix build_mx(){ Matrix res; rep(i,0,tot) rep(j,0,maxson){ if(flag[i] != 1 &amp;&amp; flag[next[i][j]] != 1 ){ res.mx[i][next[i][j]] ++; } } return res; } void debug(){ for (int i = 0; i &lt; tot; i++){ printf(&quot;id = %3d,fail = %3d,end = %3d,chi = [&quot;, i, fail[i], flag[i]); for (int j = 0; j &lt; maxson; j++) printf(&quot;%2d&quot;, next[i][j]); printf(&quot;]\\n&quot;); } }}ac;char s[30];int main(){#ifdef LOCAL freopen(&quot;3.in&quot;,&quot;r&quot;,stdin);#endif // LOCAL scanf(&quot;%d%d&quot;,&amp;n,&amp;m); ac.init(); rep(i,0,n){ scanf(&quot;%s&quot;,s); ac.insert(s,1); } ac.build(); tot = ac.tot; Matrix res1 = ac.build_mx(); Matrix res = pow3(res1,m); ll ans = 0; res1.debug(); rep(i,0,ac.tot){ ans += res.mx[0][i]; } ans = ans % mod; printf(&quot;%d\\n&quot;,ans); return 0;}","link":"/ac%E8%87%AA%E5%8A%A8%E6%9C%BA/2019/05/04/DNA-Sequence.html"},{"title":"[HDOJ5592] ZYB&#39;s Premutation","text":"[HDOJ5592] ZYB’s Premutation题意ZYB有一个序列所有的逆序数前缀和，$a_1,a_2,a_3,…,a_n$，他们各个都表示从1到$i$的逆序数的前缀和。 题解树状数组+二分 首先我们可以倒着看，对于最后一个数字，他的逆序数减前面的逆序数就代表着前面大于他的个数。所以我们就可以把问题转化为，已知数字$a_i$在前$i$个中的位置，求$a_i是多少。 我们可以用树状数组来维护，$sum(i)$表示到$i$代表着$i$是第几个数字，每当一个数字用过之后，他后面的数字都要-1，因为他们的排序相当于减少了一个，第四个数字变成第三个数字。 +n 没有想到这个序列是单调的，所以可以二分。居然想的是怎么让整个数组往前挪。 ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e4 + 1000;int T,n;int a[maxn],b[maxn],ans[maxn],bit[maxn];int lowbit(int x){ return x&amp;-x;}int add(int x,int val){ for(int i=x;i&lt;=n;i+=lowbit(i)){ bit[i] += val; }}int query(int x){ int s = 0; for(int i=x;i;i-=lowbit(i)){ s += bit[i]; } return s;}int solve(int l,int r,int x){ int ans = 0; while(l&lt;=r){ int mid = l+r&gt;&gt;1; int temp = query(mid); if(temp &gt;= x){ r = mid-1; ans = mid; }else{ l = mid+1; } } return ans;}int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d&quot;,&amp;n); memset(bit,0,sizeof(bit)); memset(ans,0,sizeof(ans)); rep(i,1,n+1) add(i,1); rep(i,1,n+1) scanf(&quot;%d&quot;,a+i); rep(i,1,n+1) b[i] = a[i] - a[i-1]; per(i,1,n+1){ int pos = i-b[i]; ans[i] = solve(1,n,pos); add(ans[i],-1); } rep(i,1,n+1){ printf(&quot;%d%c&quot;,ans[i],i==n?'\\n':' '); } } return 0;}","link":"/acm/2018/09/18/HDOJ5592-ZYB-s-Premutation.html"},{"title":"IDEA 配置struts2+tomcat","text":"使用IDEA配置Struts2Struts2版本选择由于笔者学校环境有限，教的是版本是2.3版本，所以先去官网上下载2.3的最新版本。","link":"/uncategorized/2018/09/20/IDEA-%E9%85%8D%E7%BD%AEstruts2-tomcat.html"},{"title":"JavaBean和Hibernate","text":"javabean学习笔记参考https://www.cnblogs.com/Qian123/p/5277425.html JavaBean简介javabeans就是符合某种特定规范的Java类，功能区分很明确，并且有如下设计原则 公有类，无参的共有构造方法，属性私有，有getter和setter。 Jsp联动JavaBean和JSP有关的动作标签有 123&lt;jsp:useBean&gt;&lt;/jsp:useBean&gt;&lt;jsp:setProperty&gt;&lt;/jsp:setProperty&gt;&lt;jsp:getProperty&gt;&lt;/jsp:getProperty&gt; 如何使用普通的使用可以当做一个普通的java类在jsp中插入java代码来使用。 具体分析就是： 1、创建一个web project项目。2、在src文件下，创建一个包，在包中创建一个类，满足设计原则即可3、在index.jsp页面中通过import导入之前创建的类（import=”包名.类名”）4、通过使用new创建Javabean实例(创建对象)5、使用set方法赋值6、使用get方法取值 使用jsp动作标签useBean123&lt;body&gt; &lt;jsp:useBean id=&quot;myUsers&quot; class=&quot;com.Users&quot; scope=&quot;page&quot;/&gt;&lt;/body&gt; 其中java类名是java类的全名要有package setPropertyHibernateORM对象关系映射 当我们工作在一个面向对象的系统中时，存在一个对象模型和关系数据库不匹配的时候，在java中他有一个对象关联图。 hibernate将java类映射到数据表中， SessionSession用于获取与数据库的物理连接，由于Session对象是轻量级的，并且每次与数据库进行交互都要实例化，持久太对象被保存，并通过Session对象检索找回。 因为Session对象不是线程安全的，应该根据需求被创建或者销毁。他的主要功能是映射实体类的实例提供创建，读取和删除操作。 典型的事务语法。 1234567891011121314Session session = factory.openSession();Transaction tx = null;try { tx = session.beginTransaction(); // do some work ... tx.commit();}catch (Exception e) { if (tx!=null) tx.rollback(); e.printStackTrace(); }finally { session.close();} 个人认为比较重要的方法 1234567891011Transaction beginTransaction()//开始工作单位，并返回关联事务对象。 Connection close()//通过释放和清理 JDBC 连接以结束该会话。 Query createQuery(String queryString)//为给定的 HQL 查询字符创建查询的新实例。 SessionFactory getSessionFactory()//获取创建该会话的 session 工厂。 持久化类在 Hibernate 中，其对象或实例将会被存储在数据库表单中的 Java 类被称为持久化类。若该类遵循一些简单的规则或者被大家所熟知的 Plain Old Java Object (POJO) 编程模型，Hibernate 将会处于其最佳运行状态。以下所列就是持久化类的主要规则，然而，在这些规则中，没有一条是硬性要求。 所有将被持久化的 Java 类都需要一个默认的构造函数。 为了使对象能够在 Hibernate 和数据库中容易识别，所有类都需要包含一个 ID。此属性映射到数据库表的主键列。 所有将被持久化的属性都应该声明为 private，并具有由 JavaBean 风格定义的 getXXX 和 setXXX 方法。 Hibernate 的一个重要特征为代理，它取决于该持久化类是处于非 final 的，还是处于一个所有方法都声明为 public 的接口。 所有的类是不可扩展或按 EJB 要求实现的一些特殊的类和接口。 POJO 的名称用于强调一个给定的对象是普通的 Java 对象，而不是特殊的对象，尤其不是一个 Enterprise JavaBean。 他并不是一个javabean 12345678910111213141516171819202122232425262728293031323334353637public class Employee { private int id; private String firstName; private String lastName; private int salary; public Employee() {} public Employee(String fname, String lname, int salary) { this.firstName = fname; this.lastName = lname; this.salary = salary; } public int getId() { return id; } public void setId( int id ) { this.id = id; } public String getFirstName() { return firstName; } public void setFirstName( String first_name ) { this.firstName = first_name; } public String getLastName() { return lastName; } public void setLastName( String last_name ) { this.lastName = last_name; } public int getSalary() { return salary; } public void setSalary( int salary ) { this.salary = salary; }} 关键点 对于s: jstl标签中 查询不能用createSQLquery得用createquery 获得的查询才是正确的查询。属于可以直接放到上面去的。 个人理解 hibernate把数据读入 之后将数据传输给javabean，之后依靠javabean将数据显示在jsp页面上， 上课笔记Hibernate就是实现ORM的一个框架 1234567&lt;id name=&quot;id&quot; type=&quot;long&quot;&gt; &lt;column name=&quot;id&quot; /&gt; &lt;generator class=&quot;increment&quot; /&gt;&lt;/id&gt;&lt;property name=&quot;xxx&quot; type=&quot;string&quot;&gt; &lt;column name=&quot;xxxx&quot; length=&quot;30&quot;/&gt;&lt;/property&gt; xxx 是成员中的成员变量 xxxx 是列在数据库中的名字。 id 是主键的意思。 看xml文件要采用剥皮的方式，一层一层看进去。 链接一种数据库的时候只需要一个SessionFactory。但是如果你要进行数据迁移的时候，就需要两个会话工厂。 如果对象是和数据库一直是一样的，那就是持久态。Persistent 如果对象是还没有提交到数据库中，就是临时态，Transient 如果是对象不和数据库一致 就是游离态 Detached 把对象删除了 Removed 可以使用save()函数将Transient状态转化为Persistent 当session.close()以后你再设置对象的状态就是Detached状态了。 通过Criteria查询 QBC Query By Criteria123Criteria criteria = session.createCriteria(Student.class).add(Restrictions.like(&quot;id&quot;,new Integer(1))) 新建一个约束(查询条件) id=1 (Student.class)强制类型转换 把他变成了Student。 HQL Hibernate Query Language可以通过HQL来查询。 HQL使用了类来查询 1String hql = &quot;from Student&quot;; 因为Hibernate框架的支持所以只需发要这样写就可以直接查询了。 字段操作基于Hibernate的操作有几种操作 Session HQL Criteria SQL 解释函数的意义。 12Query query = session.createQuery(hql); query 是流数据，是二进制数据，所以要强制类型转化。 带参数的HQL语句 123456String hql = &quot;select * from Employee emp where emp.id=:id and emp.name=:name&quot;;Query query = session.createQuery(hql).addEntity(Employee.class);query.setParameter(&quot;id&quot;,1);query.setParameter(&quot;name&quot;,&quot;fff&quot;);this.dataObject = (List&lt;Employee&gt;) query.list();","link":"/uncategorized/2018/11/11/JavaBean%E5%92%8CHibernate.html"},{"title":"LCA专项练习","text":"LCA专项练习前提提要由于A,B太水了，就不放了。 前几题先试试用trajan能不能全杀，之后再看在线算法。 易错点统计 如果两个点相同，那么他们的祖先节点居然会变成0。。可能是我的模板写法有点问题。可以在判断vis[u]=2的时候加上如果u=now也是找到了公共祖先。 i=fa[j]; 应该是fa[j] = i; 如果要加入假设边的话，G[maxn&lt;&lt;2]得开4倍大小，不然会已知TLE。。 有时候两种不同的写法不能混淆。 两个点相同又错了。ST表写法的时候也得特判的时候还是要考虑一下，因为有的题目不是单纯的距离之差。 C - Distance Queries题意一棵树，求两点之间最短距离。 题解裸LCA+dfs求距离 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 4e4+100;struct Query{ int to,id; Query(){} Query(int a,int b){ to = a;id = b; }};vector&lt;Query&gt; query[maxn];struct node{ int to,next,val;}G[maxn&lt;&lt;2];int n,m,cnt;int head[maxn],vis[maxn],fa[maxn],ans[maxn],dis[maxn];void add(int u,int v,int val){ G[cnt].to = v; G[cnt].next = head[u]; G[cnt].val = val; head[u] = cnt++;}void init(){ memset(head,-1,sizeof(head)); memset(vis,0,sizeof(vis)); memset(ans,0,sizeof(ans)); memset(dis,0,sizeof(dis)); rep(i,1,n+1) query[i].clear(); rep(i,1,n+1) fa[i] = i; cnt = 0;}void dfs1(int u,int f){ for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(v==f) continue; dis[v] = dis[u] + G[i].val; dfs1(v,u); }}int find(int x){ if(x!=fa[x]) fa[x] = find(fa[x]); return fa[x];}void dfs(int now){ vis[now] = 1; for(int i=head[now];~i;i=G[i].next){ int v = G[i].to; if(vis[v]) continue; dfs(v); fa[v] = now; } for(int i = 0;i&lt;query[now].size();i++){ Query node = query[now][i]; int u = node.to; int id = node.id; if(vis[u]==2){ ans[id] = find(u); } } vis[now] = 2;}int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){ init(); vector&lt;pair&lt;int,int&gt; &gt; ask; rep(i,0,m){ int u,v,val;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;val); char s[10]; scanf(&quot;%s&quot;,s); add(u,v,val); add(v,u,val); } dfs1(1,-1); int t;scanf(&quot;%d&quot;,&amp;t); rep(i,0,t){ int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); query[u].push_back(Query(v,i)); query[v].push_back(Query(u,i)); ask.push_back(make_pair(u,v)); } dfs(1); rep(i,0,t){ int x = ask[i].fi,y = ask[i].se; if(x==y){ puts(&quot;0&quot;); continue; } printf(&quot;%d\\n&quot;,dis[x]-dis[ans[i]]+dis[y]-dis[ans[i]]); } } return 0;} 修订版。在LCA里面特判。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 4e4+100;struct Query{ int to,id; Query(){} Query(int a,int b){ to = a;id = b; }};vector&lt;Query&gt; query[maxn];struct node{ int to,next,val;}G[maxn&lt;&lt;2];int n,m,cnt;int head[maxn],vis[maxn],fa[maxn],ans[maxn],dis[maxn];void add(int u,int v,int val){ G[cnt].to = v; G[cnt].next = head[u]; G[cnt].val = val; head[u] = cnt++;}void init(){ memset(head,-1,sizeof(head)); memset(vis,0,sizeof(vis)); memset(ans,0,sizeof(ans)); memset(dis,0,sizeof(dis)); rep(i,1,n+1) query[i].clear(); rep(i,1,n+1) fa[i] = i; cnt = 0;}void dfs1(int u,int f){ for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(v==f) continue; dis[v] = dis[u] + G[i].val; dfs1(v,u); }}int find(int x){ if(x!=fa[x]) fa[x] = find(fa[x]); return fa[x];}void dfs(int now){ vis[now] = 1; for(int i=head[now];~i;i=G[i].next){ int v = G[i].to; if(vis[v]) continue; dfs(v); fa[v] = now; } for(int i = 0;i&lt;query[now].size();i++){ Query node = query[now][i]; int u = node.to; int id = node.id; if(vis[u]==2 || u==now){ ans[id] = find(u); } } vis[now] = 2;}int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){ init(); vector&lt;pair&lt;int,int&gt; &gt; ask; rep(i,0,m){ int u,v,val;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;val); char s[10]; scanf(&quot;%s&quot;,s); add(u,v,val); add(v,u,val); } dfs1(1,-1); int t;scanf(&quot;%d&quot;,&amp;t); rep(i,0,t){ int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); query[u].push_back(Query(v,i)); query[v].push_back(Query(u,i)); ask.push_back(make_pair(u,v)); } dfs(1); rep(i,0,t){ int x = ask[i].fi,y = ask[i].se; printf(&quot;%d\\n&quot;,dis[x]-dis[ans[i]]+dis[y]-dis[ans[i]]); } } return 0;} D - Connections between cities题意分成未知数目颗树，问其中两点是否有路径，路径的最短长度是多少。 题解LCA+假点。 但是这道题的内存有点卡，导致不能用vector存询问，还是用两个链式前向星还行。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,m,c,cnt,tot;const int maxn = 1e4+1000;struct node{ int next,to,val;}G[maxn&lt;&lt;2];int head[maxn],fa[maxn],vis[maxn],ans[maxn*200],dis[maxn],headq[maxn];void add(int u,int v,int val){ G[cnt].to = v; G[cnt].next = head[u]; G[cnt].val = val; head[u] = cnt++;}struct Query{ int next,to;}query[maxn*200];int find(int x){ if(x!=fa[x]) fa[x] = find(fa[x]); return fa[x];}void addq(int u,int v){ query[tot].to = v; query[tot].next = headq[u]; headq[u] = tot++;}void dfs(int now){ vis[now] = 1; for(int i=headq[now];~i;i=query[i].next){ int v = query[i].to; if(vis[v]){ if(v==now){ ans[i/2] = 0; continue; } if(find(v)==0) ans[i/2] = -1; else ans[i/2] = dis[now]+dis[v]-2*dis[find(v)]; } } for(int i=head[now];~i;i=G[i].next){ int v = G[i].to; if(vis[v]) continue; dis[v] = dis[now] + G[i].val; dfs(v); fa[v] = now; }}void init(){ memset(head,-1,sizeof(int)*(n+2)); memset(headq,-1,sizeof(int)*(n+2)); memset(vis,0,sizeof(int)*(n+1)); rep(i,1,n+1) fa[i] = i; cnt = 0; tot = 0;}void Union(int a,int b){ int i = find(a), j = find(b); if(i==j) return; fa[i] = j;}template &lt;typename T&gt; inline bool read (T &amp;ret) { char c; int sgn; if (c = getchar(), c == EOF) return 0; //EOF while (c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9') ) { if((c = getchar()) == EOF) return 0; } sgn = (c == '-') ? -1 : 1; ret = (c == '-') ? 0 : (c - '0'); while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + (c - '0'); ret *= sgn; return 1;}int main(){#ifdef LOCAL freopen(&quot;3.in&quot;,&quot;r&quot;,stdin);#endif while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;c)){ init(); rep(i,0,m){ int u,v,val;read(u);read(v);read(val); add(u,v,val); add(v,u,val); Union(u,v); } rep(i,1,n+1){ if(fa[i] == i) fa[i] = 0; add(0,i,0); add(i,0,0); } rep(i,0,c){ int u,v; read(u); read(v); addq(u,v); addq(v,u); } rep(i,1,n+1) fa[i] = i; dfs(0); rep(i,0,c){ if(ans[i]==-1){ puts(&quot;Not connected&quot;); continue; } printf(&quot;%d\\n&quot;,ans[i]); } } return 0;} F - Tree题意对于一棵树有如下两种操作 将$v$,$v$两个点之间所有的点包括这两个点的权值全部加$val$ 将$v$,$v$两个点之间所有的边的权值全部加$val$ 题解lca+标记递推 我们定义$add[x][0]$为在$x$点上往后递推的点值，那么对于两个$u,v$来说我们要让这条链上的所有点都加$val$。 1234add[u][0] += val;add[v][0] += val;add[x][0] -= val;des[x] -= val; 其中$x$是他们的LCA，而且为了使得到了他们的LCA不继续增加这个值，我们定义一个数组$des[]$，递推的时候就加上这个数组在递推，就可以使得在LCA的时候不递推到LCA的祖先节点了。 树链剖分题解树链剖分可以处理点权和边权，不过这是我第一次看到一起处理的。 trick: 把点用数组存起来，到边的时候就用孩子节点来表示孩子节点到父亲节点的边。 ac代码G - One and One StoryH - CD操作题意一个加一点背景的LCA，往父节点走要+1，从祖先节点到任意子节点也只需要加1。 题解LCA，我用了ST表+RMQ，跑的飞快。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5 + 10;int cnt,n,m;int head[maxn];int fa[maxn];struct node{ int next,to;}G[maxn&lt;&lt;1];void addedge(int u,int v){ G[cnt].to = v; G[cnt].next = head[u]; head[u] = cnt++;}struct ST{ int tot; int first[maxn&lt;&lt;1],R[maxn&lt;&lt;1],order[maxn&lt;&lt;1],dp[maxn&lt;&lt;1][20],dis[maxn]; void init(int root){ tot = 0; dfs(root,0,-1); ST_init(tot); } void ST_init(int n){ rep(i,1,n+1) dp[i][0] = i; for(int j=1;(1&lt;&lt;j)&lt;=n;j++){ for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++){ int a = dp[i][j-1],b = dp[i+(1&lt;&lt;(j-1))][j-1]; dp[i][j] = R[a]&lt;R[b]?a:b; } } } int LCA(int u,int v){ int x = first[u],y = first[v]; if(x&gt;y) swap(x,y); int res = RMQ(x,y); return order[res]; } int RMQ(int l,int r){ int k = 0; while((1&lt;&lt;(k+1))&lt;=r-l+1) k++; int a = dp[l][k],b = dp[r-(1&lt;&lt;k)+1][k]; return R[a]&lt;R[b]?a:b; } void dfs(int u,int deep,int f){ R[++tot] = deep; dis[u] = deep; order[tot] = u; first[u] = tot; for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(v==f) continue; dfs(v,deep+1,u); order[++tot] = u; R[tot] = deep; } }}st;int find(int x){ return x==fa[x]?x:fa[x] = find(fa[x]);}int ind[maxn];char s[60];void init(){ cnt = 0; memset(head,-1,sizeof(head)); memset(ind,0,sizeof(ind));}int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(); map&lt;string,int&gt; mp; int tot = 0; rep(i,0,n-1){ int u,v; scanf(&quot;%s&quot;,s); if(mp[s]==0) mp[s] = ++tot,u = tot; else u = mp[s]; scanf(&quot;%s&quot;,s); if(mp[s]==0) mp[s] = ++tot,v = tot; else v = mp[s]; addedge(v,u); ind[u]++; } int root = 0; rep(i,1,n+1) if(ind[i]==0){ root = i; break; } st.init(root); rep(i,0,m){ int u,v,ans; scanf(&quot;%s&quot;,s); u = mp[s]; scanf(&quot;%s&quot;,s); v = mp[s]; int rt = st.LCA(u,v); int x = st.dis[u] - st.dis[rt]; int y = st.dis[v] - st.dis[rt]; if(rt==u) ans = 1; else if(rt == v) ans = x; else ans = x+1; if(u==v) ans = 0; printf(&quot;%d\\n&quot;,ans); } } return 0;}","link":"/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/2018/09/28/LCA%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0.html"},{"title":"LCA学习笔记","text":"LCA学习笔记祖先的定义如果学习树结构就会明白除了根节点以外每个节点都有一个父节点，所以我们定义祖先为父节点的父节点，然后我们给出最近公共祖先的定义 一棵树祖先中到两个点距离最近的节点。 能够解决LCA问题的方式有很多，所以作为一个ACM选手，肯定是我全都要 解决方案欧拉序树的欧拉序是对树进行dfs的一种序列，他有两条性质 在每个节点进和出都加入序列 只要到达每一个节点就把他加入序列 那么我们寻找他们的最近公共祖先就可以从第一次出现第一个节点和第一次出现的第二个节点之间节点中深度最大的节点。 HDOJ[2586]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define pb push_backtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 4e4+200;const int maxm = 2e2+10;int dis[maxn];int n,m;struct node{ int next,to,val;}G[maxn&lt;&lt;1];int head[maxn];int cnt;vector&lt;int&gt; order;void init(){ cnt = 0; memset(head,-1,sizeof(head)); order.clear();}void add(int u,int v,int val){ G[cnt].next = head[u]; G[cnt].to = v; G[cnt].val = val; head[u] = cnt++;}void dfs(int u,int fa,int val){ order.pb(u); dis[u] = val; for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(v==fa) continue; dfs(v,u,val+G[i].val); order.pb(v); }}int find(int p1,int p2){ int mmin = INF,res; if(p1&gt;p2){ int temp = p1; p1 = p2; p2 = temp; } rep(i,p1,p2+1){ if(dis[order[i]] &lt; mmin){ mmin = dis[order[i]]; res = i; } } return res+1;}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(); rep(i,0,n-1){ int u,v,val; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;val); add(u,v,val); add(v,u,val); } dfs(1,1,0); int len = order.size(); rep(i,0,m){ int x,y; int p1=-1,p2=-1; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); rep(j,0,len){ if(p1==-1&amp;&amp;x==order[j]) p1 = j; if(p2==-1&amp;&amp;y==order[j]) p2 = j; if(p1!=-1 &amp;&amp; p2!=-1) break; } int lca = find(p1,p2); //cout&lt;&lt;dis[lca]&lt;&lt;' '&lt;&lt;dis[x]&lt;&lt;' '&lt;&lt;dis[y]&lt;&lt;endl; int ans = dis[x]-dis[lca]+dis[y]-dis[lca]; printf(&quot;%d\\n&quot;,ans); } } return 0;} Trajan算法首先Trajan是一个离线算法，在一次遍历中把所有询问一次解决，时间复杂度$O(n+q)$。 大佬题解 我也想自己写啊，但是就是不会啊，自己想是不可能自己想的，只要抄抄别人的博客才能维持生活。 任选择一个点作为根节点，从根节点开始 遍历该节点的所有子节点，并标记这些子节点$v$已经被访问过 如果$v$还有子节点，返回2，否则就进入下一步 合并$v$到$u$。 寻找与当前点$u$有询问关系的点$v$ 若是$v$已经被访问过了，则可以确定$u$和$v$的最近公共祖先为$v$被合并的父亲节点$fa[u]$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint T,n,cnt;const int maxn = 1e4+10;struct node{ int next,to;}G[maxn&lt;&lt;1];int head[maxn],fa[maxn],vis[maxn],ans[maxn];void init(){ cnt = 0; memset(head,-1,sizeof(head)); memset(fa,0,sizeof(fa)); memset(vis,0,sizeof(vis)); rep(i,1,n+1) fa[i] = i;}void add(int u,int v){ G[cnt].to = v; G[cnt].next = head[u]; head[u] = cnt++;}int find(int x){ if(fa[x]!=x) fa[x] = find(fa[x]); return fa[x];}struct Query{ int to,id; Query(){} Query(int _to,int _id){ to = _to; id = _id; }};vector&lt;Query&gt; query[maxn];void dfs(int now){ int u,v; vis[now] = 1; for(int i=head[now];~i;i=G[i].next){ v = G[i].to; if(vis[v]) continue; dfs(v); fa[v] = now; } for(int i = 0;i&lt;query[now].size();i++){ Query node = query[now][i]; u = node.to; int id = node.id; if(vis[u] == 2){ ans[find(u)] ++; } } vis[now] = 2;}int vvis[maxn];int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif while(~scanf(&quot;%d&quot;,&amp;n)){ memset(head,-1,sizeof(head)); cnt = 0; memset(vis,0,sizeof(vis)); memset(vvis,0,sizeof(vvis)); memset(ans,0,sizeof(ans)); rep(i,1,n+1) query[i].clear(); rep(i,1,n+1) fa[i] = i; int root = 0; rep(i,0,n){ int u,x,v;scanf(&quot;%d&quot;,&amp;u); scanf(&quot;%*c%*c%d%*c&quot;,&amp;x); rep(i,0,x){ scanf(&quot;%d&quot;,&amp;v); add(u,v); vvis[v] = 1; } } rep(i,1,n+1){ if(vvis[i]==0){ root = i; break; } } int m;scanf(&quot;%d&quot;,&amp;m); char ch; rep(i,0,m){ ch = getchar(); while(ch!='(') ch = getchar(); int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); query[u].push_back(Query(v,i)); query[v].push_back(Query(u,i)); while(ch!=')') ch = getchar(); } dfs(root); rep(i,1,n+1){ if(ans[i]){ printf(&quot;%d:%d\\n&quot;,i,ans[i]); } } } return 0;} RMQ算法(ST表)其实这个方法也就是欧拉序加上RMQ，在第一个解决方案中我们使用枚举来寻找他们的LCA，这也导致时间复杂度变成了$O(n^2)$。而寻找固定区间内的最小值是一个很普遍的问题，也就是RMQ。而解决RMQ有很多种$O(logn)$的方法， 线段树、树状数组 ST表 他们均可以有效地解决区间最值问题。 例题[hdoj5044]使用方法为 RMQ+正负tag 详情见我刷的LCA专题训练。 Reference:https://blog.csdn.net/czl_233/article/details/78368927 http://www.cppblog.com/menjitianya/archive/2015/12/10/212447.html http://www.cnblogs.com/JVxie/p/4854719.html","link":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2018/09/25/LCA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"Linux学习笔记","text":"Linux这个学期上了Linux，顺便做点笔记。 看的书是 《Linux就是这个范儿》 还挺有意思的。 实验(Linux进程管理和通信)","link":"/Linux/2019/04/09/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"PAT练习","text":"PAT练习为了拿PAT的50元代金券，刷一刷牛客网上的PAT真题。 点我连接 Rational Sum题意求一百个分数的和。 题解大整数秒了。 其实我想用python，现在acm区域赛都让用python了 ac代码##Read Number in Chinese 题意给定一个数字，用中文拼音输出他。 题解模拟。 如果是负数，输出”Fu” 每四位分隔一下，都是一样的。 ac代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headchar s[20];string chinese[10] = {&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;};ll n;int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%s&quot;,s); int t = 0; int sz = strlen(s); if(s[0] == '-') t = 1; per(i,t,sz) s[i+10-sz] = s[i]; rep(i,t,10-sz+t) s[i] = '0'; vector&lt;string&gt; ans; if(s[0] == '-') ans.push_back(&quot;Fu&quot;); bool flag = true; int idx = 0; rep(i,1,10) if(s[i] &gt; '0'){ idx = i; break; } rep(i,1,10) s[i] -= '0'; if(s[1] != 0){ ans.push_back(chinese[s[1]]); ans.push_back(&quot;Yi&quot;); } if(s[2] != 0){ ans.push_back(chinese[s[2]]); ans.push_back(&quot;Qian&quot;); }else{ if(s[1] &amp;&amp; (s[3] || s[4] || s[5])) ans.push_back(&quot;ling&quot;); } if(s[3] != 0){ flag = true; ans.push_back(chinese[s[3]]); ans.push_back(&quot;Bai&quot;); }else{ if(s[4] != 0 || s[5] != 0) ans.push_back(&quot;ling&quot;); } if(s[4] != 0){ flag = true; ans.push_back(chinese[s[4]]); ans.push_back(&quot;Shi&quot;); }else{ if(s[5] != 0) ans.push_back(&quot;ling&quot;); } if(s[5] != 0){ ans.push_back(chinese[s[5]]); }else if((s[2] == 0 &amp;&amp; s[3] == 0 &amp;&amp; s[4] == 0) &amp;&amp; (s[6] || s[7] || s[8] || s[9])) ans.push_back(&quot;ling&quot;); if(s[2] || s[3] || s[4] || s[5]) ans.push_back(&quot;Wan&quot;); // gewei flag = true; if(s[6] != 0){ ans.push_back(chinese[s[6]]); ans.push_back(&quot;Qian&quot;); }else{ if(idx &lt;= 5 &amp;&amp; (s[7] || s[8] || s[9])) ans.push_back(&quot;ling&quot;); } if(s[7] != 0){ ans.push_back(chinese[s[7]]); ans.push_back(&quot;Bai&quot;); }else{ if(s[8] != 0 || s[9] != 0) ans.push_back(&quot;ling&quot;); } if(s[8] != 0){ ans.push_back(chinese[s[8]]); ans.push_back(&quot;Shi&quot;); }else{ if(s[9] != 0) ans.push_back(&quot;ling&quot;); } if(s[9] != 0) ans.push_back(chinese[s[9]]); if(ans.size() == 0) ans.push_back(&quot;ling&quot;); bool lingling = true; rep(i,0,ans.size()){ if(ans[i] == &quot;ling&quot; &amp;&amp; lingling &amp;&amp; ans.size()&gt;1) { continue; } if(ans[i] != &quot;ling&quot; &amp;&amp; ans[i] != &quot;Fu&quot;) lingling = false; else lingling = true; cout&lt;&lt;ans[i]; if(i==ans.size()-1) cout&lt;&lt;'\\n'; else cout&lt;&lt;' '; } return 0;} List Grades (25)题意给定最多100个人，给他们排序，输出指定成绩区间内的人名和ID。 题解模拟，sort ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headstruct node{ string name; string id; int grade; bool operator&lt;(const node&amp; x) const{ return grade &gt; x.grade; } node(){} node(string a,string b,int g){ name = a; id = b; grade = g; }};int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif vector&lt;node&gt; ve; int n; scanf(&quot;%d&quot;,&amp;n); rep(i,0,n){ string a,b; int g; cin&gt;&gt;a&gt;&gt;b&gt;&gt;g; ve.push_back(node(a,b,g)); } sort(ve.begin(),ve.end()); int st,ed; scanf(&quot;%d%d&quot;,&amp;st,&amp;ed); bool flag = false; rep(i,0,n) if(ve[i].grade &lt;= ed &amp;&amp; ve[i].grade &gt;= st) flag = true; int cnt = 0; while(cnt &lt; n &amp;&amp; ve[cnt].grade &gt; ed) cnt++; while(cnt &lt; n &amp;&amp; ve[cnt].grade &gt;= st){ cout&lt;&lt;ve[cnt].name&lt;&lt;' '&lt;&lt;ve[cnt].id&lt;&lt;' '&lt;&lt;'\\n'; cnt++; } if(!flag) puts(&quot;NONE&quot;); return 0;} Tree Traversals Again (25)题意用栈表示一个树的先根遍历，求这颗二叉树的后跟遍历。 题解dfs模拟一下即可。 ac代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headchar s[30];struct node{ int id; node *left = NULL,*right = NULL;};void addnode(node * root,int n,int f){ if(f){ root-&gt;left = new node(); root-&gt;left-&gt;id = n; }else{ root-&gt;right = new node(); root-&gt;right-&gt;id = n; }}void dfs(node* u){ int n; scanf(&quot;%s&quot;,s); // left if(s[1] == 'u'){ cin&gt;&gt;n; addnode(u,n,1); dfs(u-&gt;left); } scanf(&quot;%s&quot;,s); if(s[1] == 'u'){ cin&gt;&gt;n; addnode(u,n,0); dfs(u-&gt;right); }else{ return; }}void post_order(node * rt){ if(rt-&gt;left != NULL){ post_order(rt-&gt;left); } if(rt-&gt;right != NULL){ post_order(rt-&gt;right); } printf(&quot;%d &quot;,rt-&gt;id);}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif node * root = new node(); int n;scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s %d&quot;,s,&amp;n); root-&gt;id = n; dfs(root); post_order(root); return 0;}","link":"/pat/2019/05/04/PAT%E7%BB%83%E4%B9%A0.html"},{"title":"[POJ3264]Balanced Lineup","text":"[POJ3264]Balanced Lineup题意给一个数列，求数列中$l,r$范围内最大值和最小值的差。 题解st表模板题。求两次rmq即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e4 + 10;int n,q;int st[maxn][32-__builtin_clz(maxn)];int st2[maxn][32-__builtin_clz(maxn)];int h[maxn];int ST(){ int l = 31 - __builtin_clz(n); rep(i,0,n) {st[i][0] = h[i];st2[i][0] = h[i];} rep(j,0,l) rep(i,0,n-(1&lt;&lt;j)+1){ st[i][j+1] = max(st[i][j],st[i+(1&lt;&lt;j)][j]); st2[i][j+1] = min(st2[i][j],st2[i+(1&lt;&lt;j)][j]); }}int max_rmq(int l,int r){ int k = 31 - __builtin_clz(r-l+1); return max(st[l][k],st[r-(1&lt;&lt;k)+1][k]);}int min_rmq(int l,int r){ int k = 31 - __builtin_clz(r-l+1); return min(st2[l][k],st2[r-(1&lt;&lt;k)+1][k]);}int main(){#ifdef LOCAL freopen(&quot;shui.in&quot;,&quot;r&quot;,stdin);#endif while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;q)){ rep(i,0,n) scanf(&quot;%d&quot;,&amp;h[i]); ST(); while(q--){ int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); l--,r--; printf(&quot;%d\\n&quot;,max_rmq(l,r)-min_rmq(l,r)); } } return 0;}","link":"/acm/2018/08/24/POJ3264-Balanced-Lineup.html"},{"title":"SSH中的SH配置","text":"IDEA+Hibernate+Struts2笔者能力有限，只能用老版Hibernate和老版Struts2. 我们在IDEA中选择Struts2中的2.3版本我是直接下了jar包加入进去的，还有自动下载Hibernate3.6中的。之后进行配置。 之后再加入connector我用的是Mysql5.7版本所以用了对应的connector。 之后选择左下角的persistence，右键下面的一个文件之后generate Mapping。 之后选择链接服务器 记得?useSSL=false。之后配置一下hibernate.cfg.xml中的文件,其中username和password和前面四个是自己设置的。 还要选择mapping的class和resource 123456789101112&lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/test?useSSL=false&lt;/property&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;connection.password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- DB schema will be updated if needed --&gt; &lt;!-- &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; --&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;mapping class=&quot;hibernate.StudentEntity&quot;/&gt; &lt;mapping resource=&quot;hibernate/StudentEntity.hbm.xml&quot;/&gt; 之后把jstl中的jar包加入到tomcat文件夹中。这样就不用每次配置了。 之后在preference中搜索dtds 1http://java.sun.com/jsp/jstl/core url填写这个 之后再搜索你下载好的jstl中的c.tld文件 慢慢找就在里面 下载链接 http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package hibernate;import javax.persistence.*;import java.util.Objects;@Entity@Table(name=&quot;student&quot;)public class StudentEntity { @Id @GeneratedValue private int id; @Column(name=&quot;name&quot;) private String name; @Column(name=&quot;address&quot;) private String address; public StudentEntity(){} public StudentEntity(int id,String name,String address){ this.id = id; this.name = name; this.address = address; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; StudentEntity that = (StudentEntity) o; return id == that.id &amp;&amp; Objects.equals(name, that.name) &amp;&amp; Objects.equals(address, that.address); } @Override public int hashCode() { return Objects.hash(id, name, address); }}\u001a\u001a\u001a 123456789101112131415161718192021222324252627282930313233343536373839package com.listAction;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import hibernate.Student;import com.googlecode.s2hibernate.struts2.plugin.annotations.SessionTarget;import com.googlecode.s2hibernate.struts2.plugin.annotations.TransactionTarget;import org.hibernate.Session;import org.hibernate.Transaction;public class StudentDAO { @SessionTarget Session session; @TransactionTarget Transaction transaction; @SuppressWarnings(&quot;unchecked&quot;) public List&lt;Student&gt; getStudents() { List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(); try { students = session.createQuery(&quot;from student&quot;).list(); for (Iterator iter = students.iterator(); iter.hasNext();) { Object[] o = (Object[])iter.next(); System.out.println(o[0]+&quot;,&quot;+o[1]); } } catch(Exception e) { e.printStackTrace(); } return students; } public void addStudent(Student student) { session.save(student); }} 12345678910111213141516171819202122232425262728293031323334353637383940package com.listAction;import java.util.ArrayList;import java.util.List;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;import hibernate.Student;public class AddStudent extends ActionSupport implements ModelDriven&lt;Student&gt;{ Student student = new Student(); List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(); StudentDAO dao = new StudentDAO(); @Override public Student getModel() { return student; } public String execute() { dao.addStudent(student); return &quot;success&quot;; } public String listStudents() { students = dao.getStudents(); return &quot;success&quot;; } public Student getStudent() { return student; } public void setStudent(Student student) { this.student = student; } public List&lt;Student&gt; getStudents() { return students; } public void setStudents(List&lt;Student&gt; students) { this.students = students; }} 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;package name=&quot;default&quot; extends=&quot;hibernate-default&quot;&gt; &lt;!--defaultStackHibernate里面的拦截器会识别出@SessionTarget，@TransactionTarget等标注， 然后将hibernate注入进去--&gt; &lt;action name=&quot;addStudent&quot; method=&quot;execute&quot; class=&quot;com.listAction.AddStudent&quot;&gt; &lt;result name=&quot;success&quot; type=&quot;redirect&quot;&gt; listStudents &lt;/result&gt; &lt;/action&gt; &lt;action name=&quot;listStudents&quot; method=&quot;listStudents&quot; class=&quot;com.listAction.AddStudent&quot;&gt; &lt;result name=&quot;success&quot;&gt;index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import hibernate.Student;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.junit.Before;import org.junit.Test;import java.util.Iterator;import java.util.List;public class DAOtest { SessionFactory sessionFactory = null; Session session = null; Transaction tx = null; @Before public void init() { sessionFactory = new Configuration(). configure(&quot;hibernate.cfg.xml&quot;). buildSessionFactory(); session = sessionFactory.openSession(); tx = session.beginTransaction(); } //增加 @Test public void insert() { Student ue = new Student(); ue.setName(&quot;Anny&quot;); ue.setId(123321); ue.setAddress(&quot;wodediercichangshi&quot;); session.save(ue); tx.commit(); } //修改 @Test public void update() { Student user = (Student) session.get(Student.class, new Integer(2)); user.setName(&quot;Penny&quot;); session.update(user); tx.commit(); session.close(); } //查找 @Test public void getById() { Student user = (Student) session.get(Student.class, new Integer(8)); tx.commit(); session.close(); System.out.println(&quot;ID号：&quot; + user.getId() + &quot;；用户名：&quot; + user.getName() + &quot;；密码：&quot; + user.getAddress() ); } //删除 @Test public void delete() { Student user = (Student) session.get(Student.class, new Integer(6)); if(user != null){ session.delete(user); } tx.commit(); session.close(); } @Test public void gogogo(){ List&lt;Student&gt; students = session.createSQLQuery(&quot;select *from student&quot;).list(); for (Iterator iter = students.iterator(); iter.hasNext();) { Object[] o = (Object[])iter.next(); System.out.println(o[0]+&quot;,&quot;+o[1]); } }}","link":"/%E6%90%AC%E7%A0%96/2018/11/08/SSH%E4%B8%AD%E7%9A%84SH%E9%85%8D%E7%BD%AE.html"},{"title":"ST表学习笔记","text":"ST表学习笔记功能ST表示用来求解给定区间RMQ的最值问题。 预处理复杂度:$O(nlongn)$，查询复杂度$O(1)$。 详解原理将原数组分成以2幂次的区间块，用$mn[i][j]$表示从$j$到$j-2^i-1$的最小值，最小值显然等于$$min(前半段最小值,后半段中最小值)$$从而得到递推式子 $$min[i][j]=min(mn[i-1][j],mn[i-1][j+2^{i-1}])$$ 预处理代码123456789p[0] = 1;rep(i,1,20) p[i] = 1&lt;&lt;i;Log[0] = -1;rep(i,1,200000) Log[i] = Log[i/2] + 1;rep(i,1,n) mn[0][i] = a[i];rep(i,1,n+1) rep(j,1,n+1) if(j+p[i]-1 &lt;= n) mn[i][j] = min(mn[i-1][j],mn[i-1][j+p[i-1]]); 查询定理1:$$2^{log(a)}&gt;a/2$$ 查询$x$到$y$的最小值可以假设$len=y-x+1,t=log(len)$，根据定理1，$2^t&gt;len/2$，那么位置过了一半之后最小值的可能就落在了$x$后面的$2^t$和$y$前面的$2^t$。式子为$$mmin = min(mn[t][x],mn[t][y-2^t+1])$$ 实现12int t = Log[y-x+1];int ans = min(mn[t][x],mn[t][y-p[t]+1]); Reference:https://blog.csdn.net/hanks_o/article/details/77547380","link":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2018/08/19/ST%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"TCP,UDP,Socket学习笔记","text":"Linux自学网络What is Socket 系统调用 TCP UDP 是否连接 面上连接 面上非连接 传输可靠性 可靠 不可靠 应用场合 传输大量的数据，对可靠性要求较高的场景 传输少量数据，对可靠性要求不高的场景 速度 慢 快","link":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2019/04/23/TCP-UDP-Socket%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"The 2018 ACM-ICPC Asia Qingdao Regional Contest, Online","text":"The 2018 ACM-ICPC Asia Qingdao Regional Contest, Online（青岛网络赛）B.Red Black Tree题意题解ac代码J.Press the Button题意题解ac代码H Traveling on the Axis题意BOB走在$[1,n]$的路上，每两个点中间都有一个红绿灯，每一秒钟， BOB先观察红绿灯是否绿，绿就走，红就停。 红灯变绿，绿灯变红 $t(p,q)$就是$p$走到$q所需要的时间。 问： BOB从 $\\sum^{n-1}{p=0} \\sum{q=p+1}^nt(p,q)$的时间总和。 题解对于第$i$个单独的红绿灯我们可以证明他对答案的贡献是 ​ $(i)(len-i+1)(t(i))$ 我们对于两个灯进行分析。 01 第一个零要2s，第二个一要1s 10 第一个一要1s，第二个零要1s 00 第一个零要2s，第二个一要2s 11 第一个一要1s，第二个一要2s 综上可以发现， 该灯初始为0，那么他当头的时候贡献为2，如果不当头那么他的贡献就为1，除非跟前者相同。 该灯初始为1，那么他和前一个灯相同时贡献为2，就算变成0了，不在头上的话贡献也为1. 我他妈sb了，不应该看着一段一段的区间，应该把红绿灯作为每一次状态的扩展，从红绿灯这$n$个出发开始计算，不应该考虑一个一个的单位为1的区间。 AC代码12345678910111213141516171819202122232425// CSL 代码#include &lt;bits/stdc++.h&gt;using namespace std; const int N = 1 &lt;&lt; 17;char s[N];typedef long long ll; int main(){ int T; scanf(&quot;%d&quot;, &amp;T); while (T--) { scanf(&quot;%s&quot;, s); ll ans = 0; int n = strlen(s); for (int i = 0; i &lt; n; i++) ans += 1LL * (i + 1) * (n - i); for (int i = 0; s[i]; i++) { if (s[i] == '0') ans += n - i; if (i &amp;&amp; (s[i] == s[i - 1])) ans += 1LL * i * (n - i); //要跟包含前者的可能，要两个相同才能这么加。 } printf(&quot;%lld\\n&quot;, ans); }} 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5 + 10;char s[maxn];int main(){#ifdef LOCAL freopen(&quot;h.in&quot;,&quot;r&quot;,stdin);#endif int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%s&quot;,s); int len = strlen(s); ll ans = 0; ll w = 0; if(s[0]=='1') ans = w = 1; else ans = w = 2; rep(i,1,len){ if(s[i]==s[i-1]) w += i*2; else w += i*1; if(s[i]=='1') w += 1; else w += 2; ans += w; } printf(&quot;%lld\\n&quot;,ans); } return 0;} reference: https://blog.csdn.net/tianyizhicheng/article/details/82728350","link":"/acm/2018/09/17/The-2018-ACM-ICPC-Asia-Qingdao-Regional-Contest-Online.html"},{"title":"[UVA11174] Stand in a line","text":"Stand in a line题意给定$n-1​$组关系，节点$a​$不能站在节点$b​$的前面，使得$n​$站成一行，问有多少种站法。 题解树形dp + 组合数学 先建树，把没有父亲的节点都并入$0$节点，这样我们就有一颗完整的树了。 寻找规律，假设$f[i]$为以$i$为根节点的方案数，那么当每增加一颗子树的时候，他的组合是相当于有一个有拓扑排序方案和另外一个拓扑排序方案相组合。 我们可以这样想像，假设拓扑排序是不存在的，这些点的排序忽略，那么点可以看做是同样颜色的点，那么$x_1,x_2$个数的点排列的排列数为$(x_1+x_2)! /(x_1! * x_2!)$。而这些点其实是不一样的，他们有自身的拓扑排序顺序，于是答案就是$f(x_1) f(x_2) (x_1+x_2)!/(x1! * x_2!)$。 于是乎，我们先处理好每个节点的子节点(包含他自身)，可以用拓扑排序直接做，不用递归，当然也可以递归，于是就是相当于从子树开始处理，把所有子树的节点数的阶乘除掉就可以了。 简单写一下从递推到通向。$c_i$表示是$root$的子节点，$s(i)$表示$i$节点的子节点数。 $f(root) = f(c1)f(c2)…f(c_k)*((s(root)-1)!/s(c_1)!/s(c_2)!/…/s(c_k)!)$ $f(c_1)=f(x_1)f(x_2)…f(x_z)*((s(c_1)-1)!/s(x_1)!/s(x_2)!/…/s(x_z)!)$ $s(c_1)和s(c_1-1)$可以约掉。而且到叶子节点$f(x_1)$都变成$1$了$s(x_1)$也变成了0. $f(root)=(s(root)-1)!/s(1)/s(2)/…/s(n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 4e4 + 10;const ll mod = 1e9 + 7;int T,n,m,cnt;struct node{ int to,next;}G[maxn&lt;&lt;1];int head[maxn],vis[maxn],sz[maxn],q[maxn],pre[maxn];ll fac[maxn],f[maxn];void add(int u,int v){ G[cnt].to = v; G[cnt].next = head[u]; head[u] = cnt++;}void init(){ cnt = 0; rep(i,0,n+1){ vis[i] = 0; head[i] = -1; sz[i] = 0; pre[i] = 0; f[i] = 1; }}ll pow3(ll a,ll b){ ll res = 1; while(b){ if(b&amp;1) res = res*a%mod; a = a*a % mod; b&gt;&gt;=1; } return res;}int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); fac[0] = 1; rep(i,1,maxn){ fac[i] = fac[i-1]*i%mod; } while(T--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(); rep(i,0,m){ int u,v;scanf(&quot;%d%d&quot;,&amp;v,&amp;u); add(u,v);vis[v] = 1; } rep(i,1,n+1) if(!vis[i]) add(0,i); memset(vis,0,sizeof(vis)); vis[0] = 1; int l=0,r=0; q[0] = 0;vis[0] = 1; while(l&lt;=r){ int u = q[l++]; for(int i = head[u];~i;i=G[i].next){ int v = G[i].to; if(vis[v]) continue; pre[v] = u; vis[u] = 1; q[++r] = v; } } per(i,1,n+1){ sz[q[i]]++; sz[pre[q[i]]] += sz[q[i]]; } sz[0]++; ll res = 0; ll cnt = fac[n]; rep(i,1,n+1) cnt = cnt*pow3(sz[i],mod-2)%mod; printf(&quot;%lld\\n&quot;,cnt); } return 0;} Reference:https://blog.csdn.net/xiao_k666/article/details/78609562","link":"/acm/2018/08/30/UVA11174-Stand-in-a-line.html"},{"title":"[acm]hash学习笔记","text":"hash学习hash是一种比较常见的处理字符串的手法。在acm题目中，经常使用hash来处理字符串。比如判断一个子串在一个字符串中出现过几次。就可以使用hash来处理。 hash主要的方法就是把不同的字符串对应到不同的数字，之后通过数组来确定字符串是否出现过，从而减少检索字符串的时间。 常见的hash方法 12345678910111213typedef unsigned long long ull;ull base[maxn],has[maxn];void init(){ base[0] = 1; rep(i,1,maxn) base[i] = base[i-1] * 131; scanf(&quot;%s&quot;,s); int len = strlen(s); has[len] = 0; per(i,0,len) has[i] = has[i+1]*131 + (s[i]-'a'+1);}ull get_hash(int i,int L){ return has[i] - has[i+L]*base[L];} 练习hdoj4821 String题目大意就是求$S$子串中， 长为$M*L$ 其中每一段连续的$L$长度的子串都各不相同。 就是使用hash来做。但是我TLE了。因为暴力了每一段的hash值。 其实由于如果$S$的长度很长的话。其中很多段子段的hash值是被反复求的。所以我们在求完一段$M$个的字符串之后，就可以按照这个把第一段去除。之后选择后一段。这样重复下去。 Wa1:等于号想清楚了在判定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headtypedef unsigned long long ull;const int maxn = 1e5+10;ull xp[maxn],Hash[maxn];void init(){ xp[0] = 1; rep(i,1,maxn) xp[i] = xp[i-1] * 175;}ull get_Hash(int i,int L){ return Hash[i] - Hash[i+L] * xp[L];}int n,m;char s[maxn];int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif init(); // m = length of L while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){ scanf(&quot;%s&quot;,s); int len = strlen(s); Hash[len] = 0; per(i,0,len){ Hash[i] = Hash[i+1]*175+(s[i]-'a'+1); } int ans = 0; for(int i=0;i&lt;m &amp;&amp; i&lt;=len-m*n;i++){ map&lt;ull,int&gt; mx; for(int j=i;j&lt;i+m*n;j+=m){ ull temp = get_Hash(j,m); mx[temp] ++; } if(mx.size() == n) ans++; for(int j = i+n*m;j+m&lt;=len;j+=m){ ull temp = get_Hash(j-n*m,m); mx[temp]--; if(mx[temp] == 0) mx.erase(temp); temp = get_Hash(j,m); mx[temp]++; if(mx.size() == n) ans++; } } printf(&quot;%d\\n&quot;,ans); } return 0;} hdoj4080 Stammering Aliens题目大意是找到字符串$S$中，出现次数大于$m$次并且最长的字符串。 我是用hash做的，不过时间是4800ms，差点超时。用别人后缀数组＋二分，200ms可以过。。 就酱吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;typedef unsigned long long ull;const int INF = 0x3f3f3f3f;//headconst int maxn = 4e4+10;ull base[maxn],has[maxn];void init(){ base[0] = 1; rep(i,1,maxn) base[i] = base[i-1] * 131;}ull get_hash(int i,int L){ return has[i] - has[i+L] * base[L];}int m,n;char s[maxn];int check(int len){ map&lt;ull,int&gt; mx; int ans = -1; rep(i,0,n-len+1) { ull temp = get_hash(i,len); mx[temp] ++; if(mx[temp] &gt;= m){ ans = i; } } return ans;}int right_most = 0;int res = 0;void solve(int l,int r){ int mid; while(l&lt;=r){ mid = l+r&gt;&gt;1; int temp = check(mid); if(temp != -1){ l = mid + 1; res = mid; right_most = temp; }else{ r = mid - 1; } }}int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif init(); while(scanf(&quot;%d&quot;,&amp;m) &amp;&amp; m){ scanf(&quot;%s&quot;,s); n = strlen(s); has[n] = 0; per(i,0,n) has[i] = has[i+1] * 131 + s[i] - 'a' + 1; right_most = 0; res = 0; solve(1,n+1); if(res == 0){ puts(&quot;none&quot;); }else{ printf(&quot;%d %d\\n&quot;,res,right_most); } } return 0;} reference: https://blog.csdn.net/u012965373/article/details/38929637 https://blog.csdn.net/ck_boss/article/details/47066727","link":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2019/03/09/acm-hash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"[cf-767D]Cartons of milk","text":"Cartons of milk题意每天喝$k$瓶牛奶，每瓶牛奶都有$s$的保质日期，现在我有$n$瓶牛奶，去商场最多可以买多少瓶牛奶。 条件是每天都要喝$k$瓶牛奶，在最有情况下所有牛奶都不会过期。 题解贪心，反正所有牛奶的贡献都是1，所以保质期越后面的越好。 计算能买多少瓶就是从第一天开始遍历，能买到就买对应的期限的牛奶。 +1： 中间一个变量爆了int +1: 有两个变量$n,m$，sort的时候用了$n$，应该用$m$。 ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,m,k;const int maxn = 1e6+10;const int maxm = 1e7+10;int vis[maxm];int mx[maxm];struct node{ int id; int val; bool operator&lt;(const node &amp;x)const{ return val&gt;x.val; }}a[maxn];int main(){#ifdef LOCAL freopen(&quot;3.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); bool flag = false; rep(i,0,n){ int x;scanf(&quot;%d&quot;,&amp;x); vis[x]++; } rep(i,0,m){ int x;scanf(&quot;%d&quot;,&amp;x); mx[x]++; a[i].val = x; a[i].id = i+1; } sort(a,a+m); int ans = 0; ll now = k; rep(i,0,maxm){ if(vis[i] &gt; now){ flag = true; break; }else{ int temp = min(now-vis[i],(ll)mx[i]); int t = vis[i] + temp; ans += temp; now += k-t; } } if(flag) puts(&quot;-1&quot;); else{ printf(&quot;%d\\n&quot;,ans); rep(i,0,ans){ printf(&quot;%d &quot;,a[i].id); } puts(&quot;&quot;); } return 0;}","link":"/acm/2018/11/17/cf-767D-Cartons-of-milk.html"},{"title":"[cf-767b]The Queue","text":"The Queue题意题意有点复杂，懒得写了。 题解贪心。 注意的点就是，可以在还没有开始就进入队列进行排队，所以计算的时候虽然是一样的，但还是要注意一下。 特殊情况就是对于在ed以后的人来说，他们就不算了，不算人。 +1 p数组 忘记开long long了。 +1 如果加入时间超过进入时间了就不行了。 ac代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headll st,ed,t;int n;const int maxn = 1e5+10;ll p[maxn];int main(){#ifdef LOCAL freopen(&quot;4.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%lld%lld%lld&quot;,&amp;st,&amp;ed,&amp;t); scanf(&quot;%d&quot;,&amp;n); rep(i,0,n) scanf(&quot;%lld&quot;,p+i),p[i]-=st; ed -= st; ll ans = 1e13; ll wait = 1e14; int cnt = 0; rep(i,0,n){ if( (ll)(i+1)*t&gt;ed || p[i]+t&gt;ed) break; cnt++; if(p[i] &gt; (ll)(i)*t &amp;&amp; p[i]+t&lt;=ed){ ans = p[i]-1; cout&lt;&lt;ans+st&lt;&lt;'\\n'; return 0; }else{ ll temp = (ll)(i)*t - p[i]; if(wait &gt; temp){ wait = temp; ans = p[i]-1ll; } } } ll temp = (ll)(cnt+1)*t; if(temp&lt;=ed) ans = temp-t; printf(&quot;%lld\\n&quot;,ans+st); return 0;}","link":"/acm/2018/11/17/cf-767b-The-Queue.html"},{"title":"[cf541D]Gourmet choice (缩点+dfs)","text":"Gourmet choice题意给定$n$个蛋糕和$m$个蛋糕，和他们之间的大小关系。问给所有的蛋糕一个可能最小的值，使得关系成立。 题解首先由于有$=$的存在，有一些蛋糕的值是要一样的。所以我们需要把题目中的相等的点给缩到一起。 之后用dfs把值给确定下来。 其中缩点用到的技巧很厉害。 ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 2e3+10;vector&lt;int&gt; e[maxn];// m is behind of the nint fa[maxn];int Find(int x){ return fa[x] == x ? x : fa[x] = Find(fa[x]);}void Union(int i,int j){ int x = Find(i); int y = Find(j); if(x!=y) fa[x] = y;}int ind[maxn],use[maxn],vis[maxn];char mx[maxn][maxn];int n,m;// flag means the 矛盾bool flag;int dp[maxn];void dfs(int x,int dep){ if(flag) return ; dp[x] = max(dp[x],dep); for(auto to:e[x]){ if(vis[to]) { flag = true; return ; } if(dep+1&gt;dp[to]){ vis[to] = 1; dfs(to,dep+1); vis[to] = 0; } }}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,0,n){ scanf(&quot;%s&quot;,mx+i); } rep(i,0,n+m) fa[i] = i; rep(i,0,n) rep(j,0,m) if(mx[i][j] == '=') Union(i,n+j); rep(i,0,n) rep(j,0,m){ int x = Find(i); int y = Find(j+n); if(mx[i][j] == '&lt;'){ e[x].push_back(y); ind[y] ++; use[x] = 1; }else if(mx[i][j] == '&gt;'){ e[y].push_back(x); ind[x] ++; use[y] = 1; }else{ use[x] = 1; } } bool fflag = false; rep(i,0,n+m){ if(use[i] &amp;&amp; ind[i] == 0){ fflag = true; vis[i] = 1; dfs(i,1); vis[i] = 0; } } if(fflag == false || flag){ puts(&quot;No&quot;); }else{ puts(&quot;Yes&quot;); rep(i,0,n) printf(&quot;%d &quot;,dp[Find(i)]); puts(&quot;&quot;); rep(i,n,m+n) printf(&quot;%d &quot;,dp[Find(i)]); } return 0;}","link":"/cf/2019/03/05/cf541D-Gourmet-choice-%E7%BC%A9%E7%82%B9-dfs.html"},{"title":"[cf545]A-D题解","text":"Codeforces Round #545 (Div. 2)ps 小生不才，比赛时只做出3道。后面补了一道。 Sushi for Two题意给定一个只含有1或者2的数组，让你找出一个子数组，子数组要求是$n个1 和 m个2$并要求$min(n,m)$最大。 题解暴力模拟. ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5+10;int a[maxn];int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif vector&lt;int&gt; ve; int n; scanf(&quot;%d&quot;,&amp;n); int cnt1 = 0,cnt2 = 0; int ans = 0; rep(i,0,n) scanf(&quot;%d&quot;,a+i); int cnt = 0; while(cnt&lt;n){ cnt1= 0; cnt2 = 0; while(a[cnt] == 1){ cnt++; cnt1++; } ve.push_back(cnt1); while(a[cnt] == 2){ cnt++; cnt2++; } ve.push_back(cnt2); } int len = ve.size(); rep(i,0,len-1){ ans = max(ans,2*min(ve[i],ve[i+1])); } printf(&quot;%d\\n&quot;,ans); return 0;} Circus题意给定$n$个人，其中每个人可能会表演小丑也可能会表演杂技演员。要求把$n$个人分成两堆。要求 第一队只能表演小丑，第二队只能表演杂技演员 第一队中小丑的个数和第二队中杂技演员的个数相等 两队的人数相同。 题解暴力枚举，因为人可以分为四类。所以我们可以枚举出其中两类的分配，之后通过条件舍掉一些答案，得到正确答案。 ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e3+10;int idx[maxn][maxn];int col_idx[maxn][maxn];int mx[maxn][maxn];int n,m;int cnt_row[maxn];int cnt_col[maxn];int ans[maxn][maxn];int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,0,n) rep(j,0,m){ scanf(&quot;%d&quot;,mx[i] + j); } rep(i,0,n){ vector&lt;int&gt; ve; rep(j,0,m) ve.push_back(mx[i][j]); sort(ve.begin(),ve.end()); rep(j,0,m-1){ if(ve[j] == ve[j+1]) cnt_row[i]++; } } rep(j,0,m){ vector&lt;int&gt; ve; rep(i,0,n) ve.push_back(mx[i][j]); sort(ve.begin(),ve.end()); rep(i,0,n-1){ if(ve[i] == ve[i+1]) cnt_col[j]++; } } rep(i,0,n){ vector&lt;int&gt; ve; rep(j,0,m) ve.push_back(mx[i][j]); sort(ve.begin(),ve.end()); auto iter = unique(ve.begin(),ve.end()); ve.erase(iter,ve.end()); rep(j,0,m) idx[i][j] = lower_bound(ve.begin(),ve.end(),mx[i][j]) - ve.begin(); } rep(j,0,m){ vector&lt;int&gt; ve; rep(i,0,n) ve.push_back(mx[i][j]); sort(ve.begin(),ve.end()); auto iter = unique(ve.begin(),ve.end()); ve.erase(iter,ve.end()); rep(i,0,n) col_idx[i][j] = lower_bound(ve.begin(),ve.end(),mx[i][j]) - ve.begin(); } rep(i,0,n) rep(j,0,m){ int x = idx[i][j]; int y = col_idx[i][j]; int temp = 0; if(x&gt;y){ temp = max(m - cnt_row[i], n + abs(x-y) - cnt_col[j]); }else{ temp = max(n - cnt_col[j], m + abs(x-y) - cnt_row[i]); } ans[i][j] = temp; } rep(i,0,n) rep(j,0,m) { printf(&quot;%d%c&quot;,ans[i][j],j==m-1?'\\n':' '); } return 0;} C. Skyscrapers题意较为简单，自己看吧。 题解离散化+一些技巧。 因为横竖上最大值会因为中间而改变，所以答案是在 $$max(n-cnt[i],m+abs(x-y)-cnt[j])$$ 中产生的。其中$cnt[i]$表示行的重复个数，$cnt[j]$表示列的重复个数。$x,y$表示在行和列中的排名。 我做的有一点烦 ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e3+10;int idx[maxn][maxn];int col_idx[maxn][maxn];int mx[maxn][maxn];int n,m;int cnt_row[maxn];int cnt_col[maxn];int ans[maxn][maxn];int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,0,n) rep(j,0,m){ scanf(&quot;%d&quot;,mx[i] + j); } rep(i,0,n){ vector&lt;int&gt; ve; rep(j,0,m) ve.push_back(mx[i][j]); sort(ve.begin(),ve.end()); rep(j,0,m-1){ if(ve[j] == ve[j+1]) cnt_row[i]++; } } rep(j,0,m){ vector&lt;int&gt; ve; rep(i,0,n) ve.push_back(mx[i][j]); sort(ve.begin(),ve.end()); rep(i,0,n-1){ if(ve[i] == ve[i+1]) cnt_col[j]++; } } rep(i,0,n){ vector&lt;int&gt; ve; rep(j,0,m) ve.push_back(mx[i][j]); sort(ve.begin(),ve.end()); auto iter = unique(ve.begin(),ve.end()); ve.erase(iter,ve.end()); rep(j,0,m) idx[i][j] = lower_bound(ve.begin(),ve.end(),mx[i][j]) - ve.begin(); } rep(j,0,m){ vector&lt;int&gt; ve; rep(i,0,n) ve.push_back(mx[i][j]); sort(ve.begin(),ve.end()); auto iter = unique(ve.begin(),ve.end()); ve.erase(iter,ve.end()); rep(i,0,n) col_idx[i][j] = lower_bound(ve.begin(),ve.end(),mx[i][j]) - ve.begin(); } rep(i,0,n) rep(j,0,m){ int x = idx[i][j]; int y = col_idx[i][j]; int temp = 0; if(x&gt;y){ temp = max(m - cnt_row[i], n + abs(x-y) - cnt_col[j]); }else{ temp = max(n - cnt_col[j], m + abs(x-y) - cnt_row[i]); } ans[i][j] = temp; } rep(i,0,n) rep(j,0,m) { printf(&quot;%d%c&quot;,ans[i][j],j==m-1?'\\n':' '); } return 0;} D. Camp Schedule题意给定两串字符串$s,t$。要求把$s$重新排列使得$s$中的子串里，$t$出现的次数尽可能多。 题解kmp 我们可以想象一下，如果要$s$中要有尽量多的$t$，那么首先我们在$s$的最前面是一个$t$。之后我们需要加入后续的数字，使得尽可能多的像$t$。这和kmp的思想是很相似的。就是我们在最后一个字母失配之后，我们应该跳转到的那个字母开始，继续匹配就可以匹配成一个字符串了。 举个栗子吧。 111000 101 这个例子中，我们先在$s$的前面放一个$101$。 之后我们需要配一个字母，使得尽量减少失配的字符串的长度，所以我们加入$len[next]$，也就是$0$。之后我们加入$1$形成了$10101$这样就产生了两个$t$。之后我们模拟这样子的行为就可以了。 ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e5+10;char s[maxn],t[maxn];int nxt[maxn];void getnxt(char *str){ int len = strlen(str); int i = 0, j = -1; nxt[0] = -1; while(i&lt;len){ if(j==-1 || str[i] == str[j]){ i++,j++; nxt[i] = j; }else{ j = nxt[j]; } }}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%s&quot;,s); scanf(&quot;%s&quot;,t); getnxt(t); int len = strlen(t); int sz = 0; int cnt0 = 0,cnt1 = 0; int len1 = strlen(s); rep(i,0,len1){ if(s[i] == '1') cnt1++; else cnt0++; } int i = 0; bool flag = true; while(flag &amp;&amp; cnt0 &gt; 0 &amp;&amp; cnt1 &gt; 0){ for(i;i&lt;len;i++){ if(t[i] == '1' &amp;&amp; cnt1-- &gt; 0) printf(&quot;1&quot;); else if(t[i] == '0' &amp;&amp; cnt0-- &gt; 0) printf(&quot;0&quot;); else { flag = false;break; } } i = nxt[len]; } while(cnt0--&gt;0) printf(&quot;0&quot;); while(cnt1--&gt;0) printf(&quot;1&quot;); return 0;}","link":"/cf/2019/03/09/cf545-A-D%E9%A2%98%E8%A7%A3.html"},{"title":"[cf548]Edgy Trees","text":"Codeforces Round #548 (Div. 2)C.Edgy Trees题意给一个树，树上的边分为黑色或者红色，现在我们定义一个序列[𝑎1,𝑎2,…,𝑎𝑘] 我们按照次序经过序列中的每一个点(最短路径) 如果进过至少一条黑边，那这个序列就是好的。 题解至少一条的反义词就是一条都没有，这道题就是找没有黑边的子树。之后答案就是每个子树中的个数的$k$次方。 想着树形dp做，想了很久都没有写出来。 ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst ll mod = 1e9+7;const int maxn = 1e5+10;int cnt,n,k;int head[maxn];struct node{ int next,to,val;}G[maxn&lt;&lt;1];void addedge(int u,int v,int val){ G[cnt].next = head[u]; G[cnt].to = v; G[cnt].val = val; head[u] = cnt++;}void init(){ memset(head,-1,sizeof(head)); cnt = 0;}int vis[maxn];int t = 0;void dfs(int u,int fa){ t ++; vis[u] = 1; for(int i = head[u];~i;i=G[i].next){ int v = G[i].to; if(v == fa) continue; if(vis[v]) continue; if(G[i].val == 0)dfs(v,u); }}ll pow3(ll a,ll b){ ll res = 1; ll x = a; while(b){ if(b&amp;1) res = res * x % mod; b &gt;&gt;= 1; x = x*x%mod; } return res;}int main(){#ifdef LOCAL freopen(&quot;3.in&quot;,&quot;r&quot;,stdin);#endif init(); scanf(&quot;%d%d&quot;,&amp;n,&amp;k); rep(i,0,n-1){ int u,v,val; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;val); addedge(u,v,val); addedge(v,u,val); } ll ans = pow3(n,k); ll last = 0; rep(i,1,n+1){ if(vis[i]==0) dfs(i,-1); ll temp = t - last; last = t; ans = (ans + mod - pow3(temp,k)) % mod; } printf(&quot;%lld\\n&quot;,ans); return 0;}","link":"/cf/2019/03/29/cf548-Edgy-Trees.html"},{"title":"[cf706C]Hard Problem","text":"706C - Hard problem题意题意很简单，就是给定$n$串字符串，对每一串字符串只有一种操作，翻转。之后每翻转一个字符串需要消耗$c_i$的能量，问至少需要多少能量是的，这$n$个字符串是以字典序排列的。 ps:相等也算按字典序 题解dp，定义一个二维数组$dp[i][j]$。其中$i$表示第$i$个字符串中选择$j$产生字典序的最少能量消耗。$j$只有1和0，表示翻转或者不翻转，之后就是四种情况下去。具体可以看代码. ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headll n,m,q;ll d;const int maxn = 210;ll num[maxn];ll dp[maxn][12][22];ll a[maxn];ll MOD(ll x,ll mod){ ll tx = x % mod; if(tx&lt;0) tx += mod; return tx;}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif int T; scanf(&quot;%d&quot;,&amp;T); rep(test_case,1,T+1){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;q); rep(i,1,n+1) scanf(&quot;%lld&quot;,num+i); printf(&quot;Case %d:\\n&quot;,test_case); while(q--){ scanf(&quot;%lld%lld&quot;,&amp;d,&amp;m); rep(i,1,n+1) a[i] = MOD(num[i],d); memset(dp,0,sizeof(dp)); rep(i,0,n) dp[i][0][0] = 1; rep(i,1,n+1){ rep(j,1,m+1){ rep(k,0,d) dp[i][j][k] = dp[i-1][j][k]; rep(k,0,d){ dp[i][j][(k+a[i])%d] += dp[i-1][j-1][k]; } } } printf(&quot;%lld\\n&quot;,dp[n][m][0]); } } return 0;}","link":"/dp/2019/03/03/cf706C-Hard-Problem.html"},{"title":"codeforces 1600-2200 题目刷","text":"F. Graph Without Long Directed Paths题意给定一个无向图，里面没有重边也没有circle也就是自反。问把这个无向图变成有向图，怎么变才能使得图中的路径没有超过2的，就是可以穿过两条边的路径。 输出是 每条边是正向还是反向。 题解一开始想着只能有树的格式，但是其实是找一个偶数环。如果有奇数环就一定无法实现路径小于2，偶数环都可以实现。之后将每个点指定为1或者0。之后如果1到0就把边置为1，0到1就把边置为0。详情请看代码。 ac代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 2e5+10;struct node{ int next,to;}G[maxn&lt;&lt;2];int head[maxn];int cnt;void init(){ cnt = 0; memset(head,-1,sizeof(head));}void addedge(int u,int v){ G[cnt].to = v; G[cnt].next = head[u]; head[u] = cnt++;}int n,m;map&lt;pair&lt;int,int&gt;,int&gt; mx;int vis[maxn];bool flag = false;void dfs(int u,int fa,int f){ vis[u] = f; for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(v == fa) continue; mx[make_pair(u,v)] = f; mx[make_pair(v,u)] = f^1; if(vis[v] == -1){ }else{ if(vis[v]^vis[u]) continue; else { flag = true; continue; } } dfs(v,u,f^1); }}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif init(); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); vector&lt;pair&lt;int,int&gt; &gt; ve; rep(i,0,m){ int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v); addedge(v,u); ve.push_back(make_pair(u,v)); } memset(vis,-1,sizeof(vis)); dfs(1,-1,1); if(flag) { puts(&quot;NO&quot;); }else{ puts(&quot;YES&quot;); for(auto &amp;x : ve){ printf(&quot;%d&quot;,mx[x]); } puts(&quot;&quot;); } return 0;} E. Median String题意问两个字符串$s,t$。他们字典序中间的那个字符串是什么。 举个栗子: a 和 e的中间字符串就是c。 题解就是模拟大数加和大数除法。将字符串看成26进制的数字。 ac代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 2e5+10;char s[maxn];char t[maxn];char ans[maxn];char temp[maxn];int n;int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s+1); scanf(&quot;%s&quot;,t+1); int flag = 0; per(i,1,n+1){ int tt = (s[i] + t[i] - 'a'*2 + flag); flag = 0; if(tt &gt;= 26) flag = 1; temp[i] = (tt%26+'a'); } int ttt = 1; if(flag) temp[0] = 'b'; if(flag) ttt=0; flag = 0; rep(i,ttt,n+1){ int tt = (temp[i] - 'a' + flag*26); flag = 0; if(tt%2==1) flag = 1; tt /=2; ans[i] = (tt+'a'); } printf(&quot;%s&quot;,ans+1); return 0;}","link":"/1600/2019/04/10/codeforces-1600-2200-%E9%A2%98%E7%9B%AE%E5%88%B7.html"},{"title":"codeforcesPoints","text":"codeforcesPoints题意给出几个点，让你求出在某个点的右边和上面最接近他的点是哪一个点。 题解线段树+set应用 对$x$进行离散化处理，对于每一个$x$进行建一个set，用线段树维护$x$之间的$y$的最大值。对于给出点的右上点，我们可以用二分来set搜索，还有在线段树中优先搜索左边靠近给出点的点。 这是我第一次看到离散化的线段树应用。哭泣 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;inline int Max(int a,int b){return a&gt;b?a:b;}//headconst int maxn = 2e5 + 20;int maxy[maxn&lt;&lt;2],mark[maxn],x[maxn],y[maxn];set&lt;int&gt; s[maxn];int n,m;char op[20];vector&lt;int&gt; v;void build(int l,int r,int rt){ if(l==r){ maxy[rt] = -1; return; }else{ int mid = (l+r)&gt;&gt;1; build(lson); build(rson); }}void pushup(int rt){ maxy[rt] = Max(maxy[rt&lt;&lt;1],maxy[rt&lt;&lt;1|1]);}void update(int pos,int val,int l,int r,int rt){ if(l==r){ maxy[rt] = val; return; } int mid = (l+r)&gt;&gt;1; if(pos &lt;= mid) update(pos,val,lson); else update(pos,val,rson); pushup(rt);}int query(int L,int R,int val,int l,int r,int rt){ if(maxy[rt] &lt;= val) return -1; if(l==r) return l; int mid = (l+r)&gt;&gt;1; int ans = -1; if(L &lt;= mid &amp;&amp; maxy[rt&lt;&lt;1] &gt; val){ ans = query(L,R,val,lson); if(ans != -1) return ans; } if(R &gt; mid &amp;&amp; maxy[rt&lt;&lt;1|1] &gt; val) ans = query(L,R,val,rson); return ans;}int main(){#ifdef LOCAL freopen(&quot;points.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;n); rep(i,0,n){ scanf(&quot;%s%d%d&quot;,op,&amp;x[i],&amp;y[i]); if(op[0] == 'a') mark[i] = 1; else if(op[0] == 'r') mark[i] = 2; else mark[i] = 3; if(op[0] == 'a') v.push_back(x[i]); } sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end()); m = v.size(); rep(i,0,n){ if(mark[i] == 1 || mark[i] == 2){ int pos = lower_bound(v.begin(),v.end(),x[i]) - v.begin()+1; if(mark[i] == 1) s[pos].insert(y[i]); else s[pos].erase(y[i]); int val; if(s[pos].empty()) val = -INF; else val = *(--s[pos].end()); update(pos,val,1,m,1); }else{ int pos = upper_bound(v.begin(),v.end(),x[i]) - v.begin()+1; int z = query(pos,m,y[i],1,m,1); if(z == -1 || pos == m+1){ puts(&quot;-1&quot;); continue; } int ans = *(s[z].upper_bound(y[i])); printf(&quot;%d %d\\n&quot;,v[z-1],ans); } } return 0;}","link":"/cf1500/2018/08/18/codeforcesPoints.html"},{"title":"[dp+graph] CodeForces - 721C","text":"[dp+graph] CodeForces - 721C 题意给定一个有向无环图DAG，之后问从点$1$走到点$n$中，在一定的费用要求下，最多能经过多少个点。并给出经过的点。 题解$n \\leq 5000$ 我们可以考虑一下二维dp，定义一个dp数组 $dp[i][j]$代表着在$i$这个点到终点，经过$j$个点所需要花费的最少时间。 之后利用dfs进行更新。因为是深度优先，所以经过的点不用在遍历一遍。 对于记录经过的点，可以用一个二维数组代表，第$j$个点的时候下一个点是什么。 错误的思想。 WA14定义两个数组，一个记录已知这个点到达$n$最少耗-费的时间，一个记录已知这个点到达$n$最多的点数。之后利用这两个数组进行剪枝，但是已知wa14的点，我也不知道为什么。可能是dfs的顺序有关。 ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e3+10;int n,m,T,cnt;int head[maxn],vis[maxn];struct node{ int to,next; ll val;}G[maxn];void init(){ memset(head,-1,sizeof(head)); cnt = 1;}void addedge(int u,int v,int val){ G[cnt].to = v; G[cnt].val = val; G[cnt].next = head[u]; head[u] = cnt++;}int dp[maxn][maxn], bef[maxn][maxn];void dfs(int u){ vis[u] = 1; if(u==n) return; for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(vis[v]==0) dfs(v); rep(j,1,n){ if(dp[v][j] + G[i].val &lt; dp[u][j+1]){ dp[u][j+1] = dp[v][j] + G[i].val; bef[u][j+1] = v; } } }}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;T); init(); memset(dp,0x3f,sizeof(dp)); rep(i,1,m+1){ int u,v,val; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;val); addedge(u,v,val); } dp[n][1] = 0; dfs(1); int idx = 1; per(i,1,n+1){ if(dp[1][i] &lt;= T){ printf(&quot;%d\\n&quot;,i); idx = i; break; } } printf(&quot;1 &quot;); int cnt = 1; while(idx &gt; 1){ printf(&quot;%d &quot;,bef[cnt][idx]); cnt = bef[cnt][idx--]; } return 0;}","link":"/cf/2019/05/04/dp-graph-CodeForces-721C.html"},{"title":"echarts+ajax+struts2 实现数据图表动态加载并显示","text":"echarts+ajax+struts2 实现数据图表动态加载并显示echarts百度出品的良心可视化数据js库。 简单小例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;%-- Created by IntelliJ IDEA. User: cheasim Date: 2019/5/7 Time: 10:33 AM To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;图表分析&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/echarts/4.2.1-rc1/echarts-en.common.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;%--新建一个dom 存放图表--%&gt;&lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 option = { backgroundColor: '#2c343c', visualMap: { show: false, min: 80, max: 600, inRange: { colorLightness: [0, 1] } }, series : [ { name: '访问来源', type: 'pie', radius: '55%', data:[ {value:235, name:'视频广告'}, {value:274, name:'联盟广告'}, {value:310, name:'邮件营销'}, {value:335, name:'直接访问'}, {value:400, name:'搜索引擎'} ], roseType: 'angle', label: { normal: { textStyle: { color: 'rgba(255, 255, 255, 0.3)' } } }, labelLine: { normal: { lineStyle: { color: 'rgba(255, 255, 255, 0.3)' } } }, itemStyle: { normal: { color: '#c23531', shadowBlur: 200, shadowColor: 'rgba(0, 0, 0, 0.5)' } } } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/%E5%BC%80%E5%8F%91/2019/05/07/echarts-ajax-struts2-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%B9%B6%E6%98%BE%E7%A4%BA.html"},{"title":"hash专题练习","text":"hash专题","link":"/hash/2019/03/05/hash%E4%B8%93%E9%A2%98%E7%BB%83%E4%B9%A0.html"},{"title":"[hdoj1540]Tunnel Warfare","text":"Tunnel Warfare题意在一条线上有二种操作 删掉一个点 恢复一个点 求某一个点和与之相连点的个数。 题解线段树设左右标志或者是树状数组二分 HDOJ可以线段树+二分。 Cnm hdoj 多组数据不给提示 如果是树状数组500ms，线段树+二分1500ms。 POJ卡了线段树+二分。HDOJ没有写多组输入害得我WA成sb了。 垃圾HDOJ还造假数据，毁坏多个碉堡。也是服了。 WA代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e4+10;int sum[maxn&lt;&lt;3],vis[maxn],last[maxn];int n,q;void pushup(int rt){ sum[rt] = sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];}void build(int l,int r,int rt){ if(l==r){ sum[rt] = 1; return; } int mid = l+r&gt;&gt;1; build(lson); build(rson); pushup(rt);}void update(int val,int p,int l,int r,int rt){ if(l==r &amp;&amp; l==p){ sum[rt] = val; return; } int mid = l+r&gt;&gt;1; if(p &lt;= mid) update(val,p,lson); if(mid &lt; p) update(val,p,rson); pushup(rt);}int query(int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ return sum[rt]; } int mid = l+r&gt;&gt;1; int ans = 0; if(L &lt;= mid) ans += query(L,R,lson); if(mid &lt; R) ans += query(L,R,rson); return ans;}bool check(int l,int r){ if(query(l,r,1,n,1) == r-l+1) return true; return false;}int solve1(int l,int r,int rt){ int mid;int st = n; while(l&lt;=r){ mid = l+r&gt;&gt;1; if(check(mid,r)) r = mid-1,st = mid; else l = mid+1; } return st;}int solve2(int l,int r,int rt){ int mid ;int ed = n; while(l&lt;=r){ mid = l+r&gt;&gt;1; if(check(l,mid)) l = mid+1,ed = mid; else r = mid-1; } return ed; //cout&lt;&lt;ed&lt;&lt;' ';}int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;q)){ build(1,n,1); rep(i,1,n+1) vis[i] = 1; int top = 0; while(q--){ char op[20]; scanf(&quot;%s&quot;,op); if(op[0] == 'D'){ int x; scanf(&quot;%d&quot;,&amp;x); update(0,x,1,n,1); last[top++] = x; }else if(op[0] == 'R'){ int x =last[--top]; update(1,x,1,n,1); }else{ int x;scanf(&quot;%d&quot;,&amp;x); if(query(x,x,1,n,1)==0){ puts(&quot;0&quot;); continue; } printf(&quot;%d\\n&quot;,solve2(x,n,x)-solve1(1,x,x)+1); } } } return 0;} AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,m;const int maxn = 5e4+20;int bit[maxn];int lowbit(int x){ return x&amp;-x;}int query(int x){ int ans = 0; for(int i = x;i;i-=lowbit(i)){ ans += bit[i]; } return ans;}int query(int l,int r){ return query(r)-query(l-1);}void add(int x,int val){ for(int i=x;i&lt;=n;i+=lowbit(i)){ bit[i] += val; }}int solve_left(int l,int r){ int mid = l+r&gt;&gt;1;int ans = r; while(l&lt;=r){ mid = l+r&gt;&gt;1; if(query(mid,r)==r-mid+1) r = mid-1,ans = mid; else l = mid+1; } return ans;}int solve_right(int l,int r){ int mid,ans = l; while(l&lt;=r){ mid = l+r&gt;&gt;1; if(query(l,mid)==mid-l+1) l=mid+1,ans = mid; else r = mid-1; } return ans;}int vis[maxn];int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF){ stack&lt;int&gt; st; memset(bit,0,sizeof(bit)); memset(vis,0,sizeof(vis)); rep(i,1,n+1) add(i,1); while(m--){ char op[20];scanf(&quot;%s&quot;,op); if(op[0]=='D'){ int x;scanf(&quot;%d&quot;,&amp;x); st.push(x); if(vis[x]) continue; vis[x] = 1; add(x,-1); }else if(op[0]=='Q'){ int x;scanf(&quot;%d&quot;,&amp;x); if(query(x,x)==0) puts(&quot;0&quot;); else printf(&quot;%d\\n&quot;,solve_right(x,n)-solve_left(1,x)+1); }else{ add(st.top(),1); vis[st.top()] = 0; st.pop(); } } } return 0;}","link":"/acm/2018/09/07/hdoj1540-Tunnel-Warfare.html"},{"title":"[hdoj1556]Color the ball","text":"Color the ball题意给定$n$次操作，吧$l,r$区间内+1，最后问每个点是多少。 题解树状数组骚操作。 既然我单点更新只能更新一个点，那么我就更新$l$点加上1，之后$r+1$的点减1，那么我对于在区间中的点，求得就是他之前$l$出现的次数。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n;const int maxn = 1e5 + 10;int bit[maxn];int lowbit(int x){return x&amp;-x;}void update(int x,int val){ for(int i=x;i&lt;=n;i+=lowbit(i)){ bit[i] += val; }}int sum(int x){ int res = 0; for(int i=x;i;i-=lowbit(i)){ res += bit[i]; } return res;}int main(){#ifdef LOCAL freopen(&quot;3.in&quot;,&quot;r&quot;,stdin);#endif while(scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n){ memset(bit,0,sizeof(int)*(n+1)); rep(i,0,n){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); update(a,1);update(b+1,-1); } rep(i,1,n+1){ printf(&quot;%d%c&quot;,sum(i),i==n?'\\n':' '); } } return 0;}","link":"/acm/2018/08/30/hdoj1556-Color-the-ball.html"},{"title":"[hdoj2260]Difficulty control(dfs)","text":"Difficulty Control题意中文题目不说了。 题解dfs+剪枝 剩下的加不到最优值剪掉 已经加过了最优值剪掉 我在大二的时候TLE了20次的题目终于在队友的指导之下完成了。 ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headll n,m;const int maxn = 30;ll num[maxn];vector&lt;int&gt; ve;ll ans = INT_MAX;int tans[maxn];int temp[maxn];void dfs(int x,ll now){ if(abs(now-m) &lt; ans &amp;&amp; x == n){ ans = abs(now-m); memcpy(tans,temp,sizeof(temp)); } ll tt = 0; if(now-m &gt; ans) return; rep(i,x,n) tt += num[ve[i]]; if(tt + now + ans &lt; m ) return ; if(x==n) { return ; } temp[ve[x]] = 1; dfs(x+1,now + num[ve[x]]); temp[ve[x]] = 0; dfs(x+1,now);}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif while(cin&gt;&gt;n&gt;&gt;m){ ve.clear(); memset(temp,0,sizeof(temp)); memset(tans,0,sizeof(tans)); rep(i,0,n){ ll x; char ch; cin&gt;&gt;ch&gt;&gt;x; ve.push_back(ch-'A'); num[ch-'A'] = x; } sort(ve.begin(),ve.end()); ans = INT_MAX; dfs(0,0); vector&lt;int&gt; reans; rep(i,0,26) if(tans[i]) reans.push_back(i+'A'); int len = reans.size(); printf(&quot;%d\\n&quot;,len); rep(i,0,len){ printf(&quot;%c%c&quot;,reans[i],i==len-1?'\\n':' '); } } return 0;}","link":"/dfs/2019/03/06/hdoj2260-Difficulty-control-dfs.html"},{"title":"[hdoj4614]Vases and Flowers","text":"Vases and Flowers题意Alice去一排$n$的花盆中种花，有两种操作 从$a$开始种花，如果该花盆有花就跳到下一个花盆。直到没有花种或者到了$n$盆 $[a,b]$区间的所有花都扔掉。 询问 1操作中开始种花的盆和停止种花的盆 2操作中丢掉的花 题解线段树，$sum$表示花的个数，用$lazy$来懒惰标记。 妈的，我线段树还是不够熟悉，居然使用了$update(p,n,1)$这样子的形式，以为每个区间的$rt$都是随机的，其实线段树的区间都是固定的，你只能通过$lson,rson$来寻找每一个区间，不能自己xjb改区间。 寻找p开始位置的时候，需要思考一下。image一下中点和左端与p的关系就好了。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e5 + 10;int m,n,T;int now,ed,st;bool flag = 0;int sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2];void pushup(int rt){ sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1];}void pushdown(int rt,int len){ if(lazy[rt] == 0){ lazy[rt&lt;&lt;1] = lazy[rt&lt;&lt;1|1] = 0; sum[rt&lt;&lt;1] = sum[rt&lt;&lt;1|1] = 0; lazy[rt] = -1; } if(lazy[rt] == 1){ lazy[rt&lt;&lt;1] = lazy[rt&lt;&lt;1|1] = 1; sum[rt&lt;&lt;1] = len-len/2; sum[rt&lt;&lt;1|1] = len/2; lazy[rt] = -1; }}void build(int l,int r,int rt){ lazy[rt] = -1; if(l==r){ sum[rt] = 0; return ; } int mid = l+r&gt;&gt;1; build(lson);build(rson); pushup(rt);}void update(int p,int l,int r,int rt){ if(now == 0) return; if(r-l+1 == sum[rt]) return; if(sum[rt] == 0 &amp;&amp; now &gt;= r-l+1 &amp;&amp; l&gt;=p){ sum[rt] = r-l+1; now -= (r-l+1); lazy[rt] = 1; if(!flag) st = l,flag = 1,ed = r; else ed = r; return; } pushdown(rt,r-l+1); int mid = l+r&gt;&gt;1; if(p &lt;= mid) update(p,lson); update(p,rson); pushup(rt);}void update(int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ now += sum[rt]; sum[rt] = 0; lazy[rt] = 0; return; } pushdown(rt,r-l+1); int mid = l+r&gt;&gt;1; if(L &lt;= mid) update(L,R,lson); if(mid &lt; R) update(L,R,rson); pushup(rt);}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); build(1,n,1); rep(i,0,m){ int op,a,b; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;a,&amp;b); if(op==1){ a++; now = b;st = ed = a; flag = 0; update(a,1,n,1); if(now==b){ puts(&quot;Can not put any one.&quot;); }else{ ed--;st--; printf(&quot;%d %d\\n&quot;,st,ed); } }else{ now = 0; a++;b++; update(a,b,1,n,1); printf(&quot;%d\\n&quot;,now); } } puts(&quot;&quot;); } return 0;}","link":"/%E7%BA%BF%E6%AE%B5%E6%A0%91/2018/09/07/hdoj4614-Vases-and-Flowers.html"},{"title":"[hdoj4616] Game","text":"Game题意给一颗树，已知每个点有权值和陷阱，你不能往回走，如果走过$c$个陷阱或者无路可走就结束，可以从任一点开始走，问能获得多少权值。 题解树形dp。 $dp[i][j][0/1]$是在以$i$为终点，经过$j$个陷阱，$1$代表起点有陷阱，$0$代表起点没有陷阱。转移方程 $dp[u][j][0]=max(dp[u][j][0],dp[v][j][0]+val[v])$ $dp[u][j][1]=max(dp[u][j][1],dp[v][j][1]+val[v])$ 其中$j&gt;0$因为起点有陷阱。 答案就是枚举每个根节点中子树进入和出去，特判一下链的组成 起点为trap和起点不为trap组成，路线是从trap出发到另一个起点。 起点都不是trap，那么这时候就要求$j_1+j_2&lt;c$，因为路线走到一半就可能到了trap为$c$卡主，不能走了。 两个起点都为trap,那么无所谓只需要$j_1+j_2 \\leq c$就可以了。 心路历程：我一开始想的是二维dp转移方程，但是只能对一个根节点求值，因为子节点也有可能走根节点那条路径，没有想到树形dp对于求解问题这么灵活，答案不一定一定是dp数组中的元素，而可以是通过拼接数组中元素来构成答案。而且我想法是从根节点走到叶子节点，而不是从子树节点出发到根节点，还是too young啊。之后我拼接了自己的垃圾二维dp，发现因为在迷宫中你碰到$c$个陷阱之后就不能走了，但是我这个二维数组不能转移方程。我两条链拼接的时候会多加几个节点，因为左右两个链如果加起来为$c$之后，其中一条链到了trap点，就不能再走了。所以才要三维数组。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e4 + 10;struct node{ int next,to;}G[maxn&lt;&lt;1];int head[maxn],trap[maxn],val[maxn],dp[maxn][4][2];int cnt,T,n,c,ans;void add(int u,int v){ G[cnt].to = v; G[cnt].next = head[u]; head[u] = cnt++;}void init(){ cnt = 0; memset(head,-1,sizeof(int)*(n+2)); memset(trap,0,sizeof(int)*(n+2)); memset(dp,0,sizeof(dp)); ans = 0;}void dfs1(int u,int fa){ dp[u][trap[u]][trap[u]] = val[u]; for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(fa == v) continue; dfs1(v,u); for(int j=0;j&lt;=c;j++){ for(int k=0;k+j&lt;=c;k++){ ans = max(ans,dp[u][j][1]+dp[v][k][1]); if(j) ans = max(ans,dp[u][j][1]+dp[v][k][0]); if(k) ans = max(ans,dp[u][j][0]+dp[v][k][1]); if(j+k&lt;c) ans = max(ans,dp[u][j][0]+dp[v][k][0]); } } for(int j=0;j+trap[u]&lt;=c;j++){ dp[u][j+trap[u]][0] = max(dp[u][j+trap[u]][0],dp[v][j][0]+val[u]); if(j) dp[u][j+trap[u]][1] = max(dp[u][j+trap[u]][1],dp[v][j][1]+val[u]); } }}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;c); init(); rep(i,0,n) scanf(&quot;%d%d&quot;,&amp;val[i],&amp;trap[i]); rep(i,0,n-1){ int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add(u,v);add(v,u); } dfs1(0,-1); printf(&quot;%d\\n&quot;,ans); } return 0;}","link":"/acm/2018/08/31/hdoj4616-Game.html"},{"title":"[hdoj4622]Reincarnation 字符串hash+dp","text":"Reincarnation题意区间查询不同字符串的数量。 题解字符串hash+dp思想 我们从$1-len$枚举子串的长度，如果该区间内子串就加1。由于可能会有重复所以记录长度为$x$的子串最后一次出现的$L$。如果子串出现过那么$dp[L][R]-1$。 定义$dp[l][r]$为在$[l,r]$区间内不同子串的数量那么可以得到递推公式 $dp[i][j]=dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1]$ 相当于把一个区间拆成三部分，$[l+1][r],[l][r-1],[l+1][r-1]$，这三个区间合并就是前两个集合个数相加之后减掉这两个集合并的部分元素的个数。 妙啊！ 之后在预处理枚举出每一种长度的子串，从1循环到Len，如果发生重复那么可以将之前出现的+1操作的$L$到现在操作的$R$减少一个，那么这个区间的不同子串的个数就减少了一个。而且由于是递推的所以所有$[1,2,3,4,5]-L,R$都会减少1. 由于$n\\leq 2000$所以可以使用$O(n^2)$的做法。 主要是dp要想明白，如果一旦确定了递推情况，就不用管细枝末节的东西了，直接在区间上减少就可以了，使得每次dp都是正确的。 ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 2e3+10;typedef unsigned long long ull;int n;char s[maxn];ull base[maxn],has[maxn],pos[maxn];ull bas = 131;const int mod = 1e5+7;struct Hash_table{ int head[mod+2],num; ull edgenum[maxn]; int next[maxn],close[maxn]; void init(){ num = 0; memset(head,-1,sizeof(head)); } int add(ull val,int id){ int u = val % mod; for(int i=head[u];~i;i=next[i]){ if(val == edgenum[i]){ int temp = close[i]; close[i] = id; return temp; } } edgenum[num] = val; close[num] = id; next[num] = head[u]; head[u] = num++; return -1; }}H;int dp[maxn][maxn];int main(){#ifdef LOCAL freopen(&quot;3.in&quot;,&quot;r&quot;,stdin);#endif int T;scanf(&quot;%d&quot;,&amp;T); base[0] = 1; rep(i,1,maxn) base[i] = base[i-1]*bas; while(T--){ scanf(&quot;%s&quot;,s+1); int len = strlen(s+1); memset(dp,0,sizeof(dp)); rep(i,1,len+1) has[i] = has[i-1]*bas + s[i] - 'a' + 1; for(int x=1;x&lt;=len+1;x++){ H.init(); for(int i=1;i+x-1&lt;=len;i++){ int pos = H.add(has[i+x-1]-base[x]*has[i-1],i); dp[i][x+i-1]++; if(pos != -1) dp[pos][x+i-1]--; } } per(i,1,len+1) rep(j,i,len+1) dp[i][j] += dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1]; int q;scanf(&quot;%d&quot;,&amp;q); while(q--){ int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\\n&quot;,dp[x][y]); } } return 0;}","link":"/acm/2018/10/22/hdoj4622-Reincarnation-%E5%AD%97%E7%AC%A6%E4%B8%B2hash-dp.html"},{"title":"[hdoj4628]Pieces","text":"HDU - 6071题意将一个字符串每次减少一个子回文串，例子avdffd可以减少dd，就是subsequence。问最少减少几个回文子串可以使得字符串消失。 题解因为数据量只有16，所以是状压dp。 将每个字符串的位置状态压缩，之后再将回文子串先预处理出来，每次都判断一下是否可以减少回文子串，之后就是状压dp的基本操作了。 有一个检验是否可以减去的好方法 123if((S&amp;x)==x) dfs(S^x);//表示了x是可以减掉的。 之后预处理的时候将状压的值进行check更加方便。 好久没做状压dp了，居然可以return dp[]这样做，惊奇！ ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headchar s[30];int len;int vis[1&lt;&lt;18];bool check(int x){ char str[20] = &quot;&quot;;int cnt = 0; rep(i,0,len){ if(((x&gt;&gt;i)&amp;1)==1) str[cnt++] = s[i]; } rep(i,0,cnt/2){ if(str[i] != str[cnt-i-1]) return false; } return true;}int Set[1&lt;&lt;18];int tot;int dfs(int S){ if(vis[S]&lt;INF) return vis[S]; rep(i,0,tot) if((S&amp;Set[i]) == Set[i]){ vis[S] = min(dfs(S^Set[i]),vis[S]); } return ++vis[S];}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%s&quot;,s);len = strlen(s); tot = 0; int S = (1&lt;&lt;len) - 1; memset(vis,127,sizeof(vis)); vis[0] = 0; rep(i,1,S+1){ if(check(i)) Set[tot++] = i; } printf(&quot;%d\\n&quot;,dfs(S)); } return 0;}","link":"/acm/2018/10/11/hdoj4628-Pieces.html"},{"title":"[hdoj4661] Message Passing","text":"HDOJ 4661: Message Passing题意每个人拥有一个信息，也可以传给另外一个人他拥有的所有信息。现在给定一个联络树，问至少多少次传递可以让所有人拥有所有信息。 题解可以看出至少要$(n-1)*2$次传递，因为每个人都至少传出一次，传入一次。而怎么可以最少传递呢？我们可以假设根为中心，先将所有信息传递给他，之后再从他传递回来。这里有一点很巧妙，传入和传出的可能种类是一样的，所以我们只需要计算一次传入，平方后便是该点为中心的方案数。 因为子节点必须先传给父节点信息以免漏传，所以传入的方案数是满足一种拓扑排序的。那么可以看我之前的一篇博客，计算拓扑排序对一个点进行计算的。 那么怎么从已知的父节点的$f(root)$传递到子节点$f(v)$呢？ $s(i)$表示以$i$为根节点的子节点数目。 我们假设子节点$s(v)=q$，那么如果子节点变成根节点后，子节点的$s(v)=n$，而原来的父节点$f(u)$变成了$n-q$个子节点数目了。于是通过公式 $f(root)=(f(root)-1)!/s(1)/s(2)/…/s(n)$ 我们可以推导出$f(v) = f(u) * s(q)/s(n-q)$ 搞定! AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e6 + 10;const ll mod = 1e9 + 7;struct node{ int to,next;}G[maxn&lt;&lt;1];int head[maxn],pre[maxn],q[maxn],vis[maxn];ll f[maxn],sz[maxn],fac[maxn];int cnt,n,T;void add(int u,int v){ G[cnt].to = v; G[cnt].next = head[u]; head[u] = cnt++;}void init(){ cnt = 0; rep(i,0,n+1){ head[i] = -1; q[i] = 0; f[i] = 1; vis[i] = 0; sz[i] = 0; }}ll pow3(ll a,ll b){ ll res = 1; while(b){ if(b&amp;1) res = res*a%mod; a = a*a%mod; b&gt;&gt;=1; } return res;}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); fac[0] = 1; rep(i,1,maxn){ fac[i] = fac[i-1]*i % mod; } while(T--){ scanf(&quot;%d&quot;,&amp;n); init(); rep(i,0,n-1){ int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add(u,v);add(v,u); } int l = 0,r = 0;vis[1] = 1;q[0] = 1; while(l&lt;=r){ int u = q[l++]; for(int i = head[u];~i;i=G[i].next){ int v = G[i].to; if(vis[v]) continue; pre[v] = u; vis[v] = 1; q[++r] = v; } } per(i,1,n){ sz[q[i]] ++; sz[pre[q[i]]] += sz[q[i]]; } sz[1] ++; ll cnt = fac[n]; rep(i,1,n+1) cnt = (cnt*pow3(sz[i],mod-2))%mod; ll ans = 0; ans = cnt*cnt %mod;f[1] = cnt; rep(i,1,n){ ll cur = f[pre[q[i]]]; cur = cur*sz[q[i]] %mod; cur = cur*pow3(n-sz[q[i]],mod-2)%mod; f[q[i]] = cur; ans = (ans + cur*cur%mod) % mod; } printf(&quot;%lld\\n&quot;,ans); } return 0;}","link":"/acm/2018/08/30/hdoj4661-Message-Passing.html"},{"title":"[hdoj5505]GT and numbers","text":"GT and numbers题意题目意思比较绕，就是给定一个$N$和$M$问至少要多少次下列的操作可以使得$N$等于$M$。 将N乘上一个它的因子(注意$N$也会变)。 题解由于我们要求$N$转化成$M$，那么其实就是他们的素因子变成相同。 $N = 2^{a_1} * 3^{a_2}5^{a_3}…$ $M = 2^{b_1}*3^{b_2}5^{b_3}…$ 那么我们就可以看出 如果要让$a_1=b_1,a_2=b_2,a_3=b_3…$我们需要在他们差距最大的那个素因子中他们相差的倍数的。 $log_2(倍数)$ tip 由于2e63 爆了long long 。所以要用unsigned long long。 ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef unsigned long long ll;const int INF = 0x3f3f3f3f;//headll n,m;int prime[1100000],primesize,phi[11000000];bool isprime[11000000];void getlist(int listsize){ memset(isprime,1,sizeof(isprime)); isprime[1]=false; for(int i=2;i&lt;=listsize;i++) { if(isprime[i])prime[++primesize]=i; for(int j=1;j&lt;=primesize&amp;&amp;i*prime[j]&lt;=listsize;j++) { isprime[i*prime[j]]=false; if(i%prime[j]==0)break; } }}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif int T; scanf(&quot;%d&quot;,&amp;T); getlist(4000000); while(T--){ scanf(&quot;%llu%llu&quot;,&amp;n,&amp;m); ll ans = 0; bool flag = false; for(ll i=1;prime[i]&lt;=n;i++){ ll cnt1= 0,cnt2 = 0; ll t = prime[i]; while(n%t==0) n/=t,cnt1++; while(m%t==0 &amp;&amp; m) m/=t,cnt2++; if(cnt1&gt;cnt2 ||(cnt1==0 &amp;&amp; cnt2&gt;0)){ flag = true; break; } if(cnt1 == 0) continue; ll temp = cnt2/cnt1; if(temp*cnt1&lt;cnt2) temp++; ans = max(temp,ans); } if(m&gt;1) flag = true; if((n==1 &amp;&amp; n!=m) || flag){ puts(&quot;-1&quot;); }else{ if(ans==0){ puts(&quot;0&quot;); continue; } ll temp = 1; int res = 0; while(temp&lt;ans) temp&lt;&lt;=1,res++; printf(&quot;%d\\n&quot;,res); } } return 0;}","link":"/acm/2018/11/16/hdoj5505-GT-and-numbers.html"},{"title":"[hdoj5521]Meeting","text":"Meeting题意将图分成$m$个块，每个块中的点到块中点的需要的时间为$E_i$。Bessie在点1，Elsie在点$n$，问他们在最短的时间走到可以到哪一个点会和。点可以在不同的块中。 题解如果想要每个点都建边，无疑会爆空间。我们可以看出每个点都分配到几个块，而每个块又有几个点。那么我们可以将块看做点，连接着块中的点，这样每个块的边从$O(n^2)$变成了$O(n)$。 我tmWA了20发，就是因为以前都是将点做标记，但是这次是块也要做标记，不然每块会浪费很多时间。而且因为只要该点是最优的，那么该块也是最优的了(因为该点到该块的距离为0)。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#pragma comment(linker,&quot;/STACK:1024000000,1024000000&quot;)using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;#define pb push_backconst int maxn = 1e5 + 10;ll val[maxn];ll cnt1[maxn],cnt2[maxn];inline int read(){ int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}//headint T,n,m;ll ans[maxn];int vis[maxn];struct node{ ll t; int id; node(){} node(ll a,int b):t(a),id(b){} bool operator&lt;(const node&amp;x) const{ return t &gt; x.t; }};void bfs(int rt,ll *cnt,vector&lt;int&gt;B[],vector&lt;int&gt;E[]){ cnt[rt] = 0; priority_queue&lt;node &gt; q; memset(vis,0,sizeof(vis)); int use[maxn]; memset(use,0,sizeof(use)); q.push(node(0,rt)); while(!q.empty()){ int u = q.top().id; q.pop(); for(auto bk:B[u]){ if(use[bk]) continue; use[bk] = 1; for(auto v: E[bk]){ if(cnt[u]+val[bk]&gt;=cnt[v]) continue; cnt[v] = cnt[u] + val[bk]; q.push(node(cnt[v],v)); } } }}int main(){#ifdef LOCAL freopen(&quot;m.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); rep(test_case,1,T+1){ memset(cnt1,127,sizeof(cnt1)); memset(cnt2,127,sizeof(cnt2)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); vector&lt;int&gt; B[n+1]; vector&lt;int&gt; E[m+1]; rep(i,1,n+1) B[i].resize(5); rep(i,1,m+1) E[i].resize(5); rep(i,1,m+1){ val[i] = read(); int s = read(); rep(j,0,s){ int x = read(); E[i].pb(x);B[x].pb(i); } } bfs(1,cnt1,B,E); bfs(n,cnt2,B,E); ll mmin = 0xfffffff; rep(i,1,n+1){ ans[i] = max(cnt1[i],cnt2[i]); if(ans[i]&lt;mmin) mmin=ans[i]; } if(mmin != 0xfffffff) printf(&quot;Case #%d: %lld\\n&quot;,test_case,mmin); else{ printf(&quot;Case #%d: Evil John\\n&quot;,test_case); continue; } int cnt = 0; ll res[maxn]; rep(i,1,n+1){ if(ans[i]==mmin) res[cnt++] = i; } rep(i,0,cnt){ printf(&quot;%d%c&quot;,res[i],i==cnt-1?'\\n':' '); } }}","link":"/acm/2018/09/06/hdoj5521-Meeting.html"},{"title":"[hdoj5559]Frog and String","text":"Frog and String题意给定一个字符串的长度和他里面子回文串的个数。 子回文串是连续子串，并且相同的回文串不重复计数 字符串由前$K$个字符构成 题解构造题嘛，最重要的就是规律啦。 对于构造题，我们就要一步一步来，把题目分段。 首先对于$K=1$来说，如果$n !=m$的话，无解。 对于$K=2$来说，这时候爆搜就起作用了，我怎么想也不肯能根据我那只有6长度的字符串想到会存在一个长度为8但是只有7个自回文串的字符串。他就是$AABABBAA$.估计只有搜才能发现这个玩意，之后就会发现只有两个字符，你也能构造一个长度很长，但只有很少的子回文串。$AABABB$这个玩意可以无限重复，但是只有$A,B,AA,BB,ABA,BAB,ABBA,BAAB$这四种玩意。 对于$K \\ge 3$，最好想，就是$ABC$来重复计数，$m-3$个前导$A$ 我真是蠢，真的，没有去用爆搜找一下答案，就凭自己的直觉在那里搞来搞去。 +1 $m=2$的时候少考虑了 +1 当$k&gt;m$的时候 +1 单独测试用例 没有print case +1 特判m==n没有加else if +1 $k=2,n=m$的时候出现了错误。应该特判的。 ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5+10;const int maxk = 30;int n,k,m;char magic[10] = &quot;ABAABB&quot;;int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif int T; scanf(&quot;%d&quot;,&amp;T); rep(test_case,1,T+1){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); bool flag = false; if(n!=m){ if(k==1) flag = true; if(k==2 &amp;&amp; m&lt;8) flag = true; if(k&gt;=3 &amp;&amp; m&lt;=2) flag = true; if(n&lt;m) flag = true; if(m==7 &amp;&amp; n==8 &amp;&amp; k==2){ printf(&quot;Case #%d:\\n&quot;,test_case); puts(&quot;AABABBAA&quot;); continue; } } printf(&quot;Case #%d:\\n&quot;,test_case); if(flag) puts(&quot;Impossible&quot;); else if(n==m){ rep(i,0,n) printf(&quot;A&quot;); puts(&quot;&quot;); }else if(k==2){ int cnt = m-8; rep(i,0,cnt) printf(&quot;A&quot;); rep(i,0,n-cnt) printf(&quot;%c&quot;,magic[i%6]); puts(&quot;&quot;); }else{ vector&lt;char&gt; ve; rep(i,0,m-3) printf(&quot;A&quot;); rep(i,0,3) ve.push_back('A'+i); rep(i,0,n-m+3){ printf(&quot;%c&quot;,ve[i%3]); } puts(&quot;&quot;); } } return 0;}","link":"/acm/2018/11/21/hdoj5559-Frog-and-String.html"},{"title":"[hdoj5881]Tea","text":"Tea题意题意有点复杂。给你一壶茶，容量范围为$[L,R]$。之后给你两个杯子。让你从茶壶中往杯子里加茶。结果有以下要求。 经过$ans$次加水,$ans$最小 两个杯子的茶水量相差不超过$1$ 茶壶中茶水量最终不超过$1$ 题解贪心。 贪心很好想，就是细节很多。 记录茶杯1为a,茶杯2为b。 我们首先向a添加$L/2+0.5$的茶水，之后茶壶中还剩下的范围为$[L/2-0.5,R-L/2-0.5]$。如果满足要求，那么$ans$就是$1$。 之后我们往b添加$L/2-0.5$的茶水，之后茶壶中剩下的范围为$[0,R-L-2]$。如果满足要求，$ans$就是$2$。 之后我们循环往每个茶杯中加入$2$的水，直到满足要求。 需要注意的是，如果$L=0$的话要特判，还有如果$R&lt;=1$那么就直接满足条件，如果$R&lt;=2$的话只要添加一次。 ac代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headll l,r;int main(){#ifdef LOCAL freopen(&quot;3.in&quot;,&quot;r&quot;,stdin);#endif std::ios::sync_with_stdio(false); cin.tie(0); while(cin&gt;&gt;l&gt;&gt;r){ if(r&lt;=1) puts(&quot;0&quot;); else if(r&lt;=2) puts(&quot;1&quot;); else if(l==0) printf(&quot;%lld\\n&quot;,(r-1)/2+1); else { ll temp = r-l-3; temp = max(0ll,temp); ll ans = temp/2; if(ans*2&lt;temp) ans++; printf(&quot;%lld\\n&quot;,ans+2); } } return 0;}","link":"/acm/2018/11/18/hdoj5881-Tea.html"},{"title":"[hdoj6376]度度熊剪纸条","text":"度度熊剪纸条题意将一段01的序列分成$k$段，将他们重新拼接，问拼接成的纸条中前导0最多有多少个。 拼接不可以改变方向。 题解我模拟下来就是我们可以将这段序列分成三部分， 比如 11111/0/111/0/1111/0/11111 最前方的1部分和最后方的1部分和中间的1部分。 如果想将中间的1放在前面就必须剪两次，前方和后方的只需要1次。 模拟的话。 我们首先如果第一段不剪，那么就是从后面的中间1和后方1选择，中间1需要剪两次，后方1只要剪一次。 如果第一段剪掉，那么就是选择最大的，在他前面切一刀，把它当做最后的处理，其余的是前面的和后面的剪一刀和中间的剪两刀。 如果$k==0$特殊处理一下。 ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,k;const int maxn = 1e4+100;char s[maxn];int ve[maxn];int solve(){ bool flag = 0; int cnt = 0; int l = 0,r = 0; int ans = 0; int j = 0; int st = 0,ed = n-1; while(s[st]==1&amp;&amp;st&lt;n)st++; l = st; while(s[ed]==1&amp;&amp;st&lt;=ed) ed--; r = n-ed-1; rep(i,st,ed+1){ if(s[i] == 1) cnt++; if(s[i] == 0 &amp;&amp; cnt){ ve[++j] = cnt; cnt = 0; } } if(k==0) return l; sort(ve+1,ve+j+1); while(k&gt;2 &amp;&amp; j&gt;=1){ ans += ve[j--]; k-=2; } if(k==1){ ans += max(l+r,ve[j]); }else{ ans += max(l+r,max(l+ve[j],r+ve[j])); } return ans;}char temp[maxn];int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;k)){ scanf(&quot;%s&quot;,s); rep(i,0,n) s[i] -= '0'; printf(&quot;%d\\n&quot;,solve()); } return 0;}","link":"/acm/2018/10/12/hdoj6376-%E5%BA%A6%E5%BA%A6%E7%86%8A%E5%89%AA%E7%BA%B8%E6%9D%A1.html"},{"title":"[hdoj6387]AraBellaC","text":"AraBellaC题意一段序列中只有$A,B,C$三种字母，这段序列是一段周期序列，并且他的重复序列是这样子的。 AAAABBBBCCCCC 他的重复序列由$a$个A,$b$个B,$c$个C组成，并且是有顺序的。 给定以下规则。 给你$m$个位置的值。 其余的位置 问你生成一个序列，使得$a,b,c$的字典序最小，如果没有输出$NO$ 题解二分。 枚举重复序列的长度，那么我们要检验的就是$a,b,c$满足不满足要求。下面就可以用二分来解决。 感觉复杂度有点高。。 我们分别用三个数组存放A,B,C的位置。那么在搜索每个区间内的最后面的一个A，B，C和最前面的一个A，B，C。 之后比较复杂的就是，将一些不对的答案剔除。 因为我们得到了每个字母第一次出现和最后一次出现的位置，我们就可以得到$a,b,c$并且把一些值给剔除。 定义$a_{max},a_{min},b_{max},b_{min},c_{max},c_{min}$分别为他们出现的位置。 $a_{max} &lt; b_{min}$ 并且$b_{max} &lt; c_{min}$ 可能会存在没有b和c的情况，这种都要舍去。 因为要字典序最小，所以$a$要尽可能的小。 $a=a_{max}-begin+1,b = b_{max}-a_{max}+1,c = len-a-b$ ac代码","link":"/acm/2018/11/18/hdoj6387-AraBellaC.html"},{"title":"[hdoj6406]Taotao Picks Apple","text":"Taotao Picks Apples题意一段序列，从中挑选的子序列是这样规定的 能取就取，而且取得数字一定要比上一次取得数字要大。 已知一段序列，问如果改变序列中的一个数字，那么取得数字的个数是多少。 题解每次查询将数组分为两部分$[1,p-1],[p+1,n]$，前半部分的最长长度就是可以通过预处理得到。很容易想到先处理出从头到$i$的最大长度$dl[i]$。然后针对后半段，我们要得到的是置换的$q$，然后大于他的第一个数字到末尾的最大长度。 有一个细节就是，如果置换的数字小于前面最大的数字，那么就是从前面最大的数字到$[p+1,n]$中间大于这个数字的第一个数字开始。 如果置换的数字大于前面最大的数字，那么答案就是$dl([1,p-1])+1+dr([p+1,n])$这个意思。 寻找第一个比该数字大的最前数字用的是线段树。 +1 判断最大值的时候直接用mmax判断，应该用a[x]判断 +1 得到dr数组的时候范围搞错了，应该是[i,n]的范围内比a[i]大的第一个数字。 ac代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 2e5+100;int n,m;int a[maxn];struct Segtree{ int mmax[maxn&lt;&lt;2]={0},id[maxn&lt;&lt;2]={0},cur=0; void pushup(int rt){ int x = id[rt&lt;&lt;1],y = id[rt&lt;&lt;1|1]; id[rt] = a[x]&gt;a[y]?x:y; mmax[rt] = max(mmax[rt&lt;&lt;1],mmax[rt&lt;&lt;1|1]); } void build(int l,int r,int rt){ if(l==r){ mmax[rt] = a[l]; id[rt] = l; return; } int mid = l+r&gt;&gt;1; build(lson); build(rson); pushup(rt); } void query1(int val,int L,int R,int l,int r,int rt){ if(l==r){ if(mmax[rt]&gt;val) cur = min(cur,id[rt]); return; } int mid = l+r&gt;&gt;1; if(L&lt;=l &amp;&amp; r&lt;=R){ if(mmax[rt&lt;&lt;1]&gt;val) query1(val,L,R,lson); else if(mmax[rt&lt;&lt;1|1]&gt;val) query1(val,L,R,rson); return; } if(L&lt;=mid) query1(val,L,R,lson); if(mid&lt;R) query1(val,L,R,rson); } void query2(int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ if(mmax[rt]&gt;a[cur]) cur = id[rt]; return; } int mid = l+r&gt;&gt;1; if(L&lt;=mid) query2(L,R,lson); if(mid&lt;R) query2(L,R,rson); }}st;int dl[maxn],dr[maxn];int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,1,n+1) scanf(&quot;%d&quot;,a+i); st.build(1,n,1); int mx = 0; memset(dr,0,sizeof(dr)); memset(dl,0,sizeof(dl)); rep(i,1,n+1){ if(a[i]&gt;mx){ mx = a[i]; dl[i] = dl[i-1]+1; }else{ dl[i] = dl[i-1]; } } per(i,1,n+1){ st.cur = n+1; st.query1(a[i],i,n,1,n,1); if(st.cur&gt;n) st.cur = 0; dr[i] = dr[st.cur]+1; } while(m--){ int p,q;scanf(&quot;%d%d&quot;,&amp;p,&amp;q); int ans = 0; st.cur = 0; if(p&gt;1) st.query2(1,p-1,1,n,1); ans += dl[st.cur]; if(q &gt; a[st.cur]) ans ++; if(q &lt;= a[st.cur]) q = a[st.cur]; st.cur = n+1; if(p&lt;n) st.query1(q,p+1,n,1,n,1); if(st.cur&lt;=n) ans += dr[st.cur]; printf(&quot;%d\\n&quot;,ans); } } return 0;}","link":"/acm/2018/10/13/hdoj6406-Taotao-Picks-Apple.html"},{"title":"[hdoj6447] YJJ&#39;s Salesman","text":"[hdoj6447] YJJ’s Salesman题意给定一个地图，只能向右或者向上走，地图上有很多点，有以下条件 每个点有钱$val$ 你只能从该点的左下方进入点才可以拿钱。 问最多能获得多少钱。 题解dp + 树状数组优化 单dp就是$O(n^2)$的复杂度。但是题目数据范围$1e5$所以不行。只有树状数组优化了。 树状数组处理的是$dp[i]$代表着以$i$点为重点的权值。 并且由于$x,y$范围是$1e9$所以必须离散化。 有一步我看了好久代码才看懂。在dp方程转移的时候，先对于$x$进行排列，之后在之后更大的$x$再更新之后的dp数组，保证每一次update的dp数组都是最优的。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5 + 10;struct node{ int x,y,val; bool operator &lt;(const node&amp; t)const{ return x &lt; t.x; }}a[maxn];int T,n,tot;int bit[maxn],dp[maxn];int lowbit(int x){ return x&amp;-x;}void update(int x,int val){ for(int i=x;i&lt;=tot;i+=lowbit(i)) bit[i] = max(bit[i],val);}int query(int x){ int s = 0; for(int i=x;i;i-=lowbit(i)){ s = max(s,bit[i]); } return s;}int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); while(T--){ vector&lt;int&gt; v; memset(bit,0,sizeof(bit)); scanf(&quot;%d&quot;,&amp;n); rep(i,0,n){ int x,y,v;scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;v); a[i].x = x;a[i].y = y;a[i].val = v; } rep(i,0,n) v.push_back(a[i].y); sort(v.begin(),v.end()); sort(a,a+n); v.erase(unique(v.begin(),v.end()),v.end()); tot = v.size(); rep(i,0,n) a[i].y = lower_bound(v.begin(),v.end(),a[i].y) - v.begin() + 1; rep(i,0,n) dp[i] = a[i].val; int ans = 0;int pos = 0; rep(i,0,n){ while(pos &lt; i &amp;&amp; a[pos].x &lt; a[i].x){ update(a[pos].y,dp[pos]); pos ++; } dp[i] = query(a[i].y-1) + a[i].val; ans = max(ans,dp[i]); } printf(&quot;%d\\n&quot;,ans); } return 0;}","link":"/acm/2018/08/27/hdoj6447-YJJ-s-Salesman.html"},{"title":"[hdoj6438]Buy and Resell","text":"[hdoj6438]Buy and Resell题意给定$n$个城市和无限制的初始金钱你可以在每个城市里 以$a_i$的价格买个商品 以$a_i$的价格卖出商品 啥都不做 问最多能赚多少钱？ 题解贪心 + 数据结构 假设每个城市都卖出商品。那么之前买入的最便宜的商品来卖。对于买卖次数就将假设买入的商品记录为两种 $1$表示他是之前买入并且在这次卖出 $2$表示他是没有买卖，直接抵消了。 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint T,n;ll ans = 0;int main(){#ifdef LOCAL freopen(&quot;3.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); while(T--){ priority_queue&lt;pII&gt;pq; ans = 0;int cnt = 0; scanf(&quot;%d&quot;,&amp;n); rep(i,0,n){ int x;scanf(&quot;%d&quot;,&amp;x); pq.push(make_pair(-x,1)); pq.push(make_pair(-x,2)); ll temp = x + pq.top().fi; if(pq.top().se == 1) cnt+=2; ans += temp; pq.pop(); } printf(&quot;%lld %d\\n&quot;,ans,cnt); } return 0;}","link":"/acm/2018/08/27/hdoj6438-Buy-and-Resell.html"},{"title":"html5学习笔记","text":"html5学习笔记功能很强。","link":"/html/2018/11/19/html5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"iBatis框架 粗略学习","text":"iBatisjar包 Ibatis 2.3.4 Sql server 配置文件配置文件和Hibernate类似 映射文件他的映射方式是把CRUD映射到操作。 123&lt;insert id=&quot;insertStudent&quot; parameterClass=&quot;Student&quot;&gt; ...&lt;/insert&gt; 初始化123inputStream ins = Resources.getResourceAsStream(&quot;sql-map-confg.xml&quot;);client = SqlMapClientBuilder.buildSqlClient(ins);Client.startTransaction(); 老师不讲了，溜了溜了","link":"/%E5%BC%80%E5%8F%91/2018/11/19/iBatis%E6%A1%86%E6%9E%B6-%E7%B2%97%E7%95%A5%E5%AD%A6%E4%B9%A0.html"},{"title":"jsp作业","text":"jsp第五次上机题目1实现Hibernate的增加数据功能 题目2实现Hibernate的查找数据功能 项目构成 DAO是项目的功能接口类，DAOImpl是DAO功能接口的实现类。AddStudent是主要的Action类，有两个方法，一个是增加学生数据一个是显示学生数据。Student和hbm由IDE自动根据数据库生成。 java类函数代码接口类12345678package njtech.edu.DAO;import java.util.List;import njtech.edu.model.Student;public interface StudentDAO { public void saveStudent(Student student); public List&lt;Student&gt; getAll();} 实现类123456789101112131415161718192021222324252627282930313233343536373839package njtech.edu.DAO.impl;import njtech.edu.model.Student;import njtech.edu.DAO.StudentDAO;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import java.util.Iterator;import java.util.List;public class StudentDAOImpl extends BaseDAOImpl implements StudentDAO{ SessionFactory sessionFactory = null; Session session = null; Transaction tx = null; public StudentDAOImpl(){} public void init() { sessionFactory = new Configuration(). configure(&quot;hibernate.cfg.xml&quot;). buildSessionFactory(); session = sessionFactory.openSession(); tx = session.beginTransaction(); } @Override public void saveStudent(Student student) { init(); session.save(student); tx.commit(); } @Override public List&lt;Student&gt; getAll() { init(); List&lt;Student&gt; students = session.createQuery(&quot;from Student&quot;).list(); return students; }} Action类12345678910111213141516171819202122232425262728293031323334353637383940package com.listAction;import java.util.ArrayList;import java.util.List;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;import njtech.edu.DAO.StudentDAO;import njtech.edu.DAO.impl.StudentDAOImpl;import njtech.edu.model.Student;public class AddStudent extends ActionSupport implements ModelDriven { private Student student = new Student(); private List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(); private StudentDAO dao = new StudentDAOImpl(); public Object getModel() { return student; } public String execute() { dao.saveStudent(student); return &quot;success&quot;; } public String listStudents() { students = dao.getAll(); return &quot;success&quot;; } public Student getStudent() { return student; } public void setStudent(Student student) { this.student = student; } public List&lt;Student&gt; getStudents() { return students; } public void setStudents(List&lt;Student&gt; students) { this.students = students; }} model类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package njtech.edu.model;import javax.persistence.*;import java.util.Objects;public class Student { private int id; private String name; private String address; public Student(){} public Student(int id, String name, String address){ this.id = id; this.name = name; this.address = address; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student that = (Student) o; return id == that.id &amp;&amp; Objects.equals(name, that.name) &amp;&amp; Objects.equals(address, that.address); } @Override public int hashCode() { return Objects.hash(id, name, address); }} 对应的数据库mapping123456789101112131415161718&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;class name=&quot;njtech.edu.model.Student&quot; table=&quot;student&quot; schema=&quot;test&quot;&gt; &lt;id name=&quot;id&quot;&gt; &lt;column name=&quot;id&quot; sql-type=&quot;int(11)&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;name&quot;&gt; &lt;column name=&quot;name&quot; sql-type=&quot;varchar(100)&quot; length=&quot;100&quot; not-null=&quot;true&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;address&quot;&gt; &lt;column name=&quot;address&quot; sql-type=&quot;varchar(100)&quot; length=&quot;100&quot; not-null=&quot;true&quot;/&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; Hibernate配置文件1234567891011121314151617181920&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/test?useSSL=false&lt;/property&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;connection.password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;mapping class=&quot;njtech.edu.model.Student&quot;/&gt; &lt;mapping resource=&quot;njtech/edu/model/Student.hbm.xml&quot;/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; struts2配置文件1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;package name=&quot;default&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;addStudent&quot; method=&quot;execute&quot; class=&quot;com.listAction.AddStudent&quot;&gt; &lt;result name=&quot;success&quot; type=&quot;redirect&quot;&gt; listStudents.action &lt;/result&gt; &lt;/action&gt; &lt;action name=&quot;listStudents&quot; method=&quot;listStudents&quot; class=&quot;com.listAction.AddStudent&quot;&gt; &lt;result name=&quot;success&quot;&gt;index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 测试类，可以用来测试Hibernate是否运行需要加载对应的Junit的jar包。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import njtech.edu.model.Student;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.junit.Before;import org.junit.Test;import java.util.Iterator;import java.util.List;public class DAOtest { SessionFactory sessionFactory = null; Session session = null; Transaction tx = null; @Before public void init() { sessionFactory = new Configuration(). configure(&quot;hibernate.cfg.xml&quot;). buildSessionFactory(); session = sessionFactory.openSession(); tx = session.beginTransaction(); } //增加 @Test public void insert() { Student ue = new Student(); ue.setName(&quot;Anny&quot;); ue.setId(7777); ue.setAddress(&quot;wodediercichangshi&quot;); session.save(ue); tx.commit(); } //修改 @Test public void update() { Student user = (Student) session.get(Student.class, new Integer(2)); user.setName(&quot;Penny&quot;); session.update(user); tx.commit(); session.close(); } //查找 @Test public void getById() { Student user = (Student) session.get(Student.class, new Integer(8)); tx.commit(); session.close(); System.out.println(&quot;ID号：&quot; + user.getId() + &quot;；用户名：&quot; + user.getName() + &quot;；密码：&quot; + user.getAddress() ); } //删除 @Test public void delete() { Student user = (Student) session.get(Student.class, new Integer(6)); if(user != null){ session.delete(user); } tx.commit(); session.close(); } @Test public void gogogo(){ List&lt;Student&gt; students = students = session.createQuery(&quot;from Student&quot;).list(); for (Iterator iter = students.iterator(); iter.hasNext();) { Object[] o = (Object[])iter.next(); System.out.println(o[0]+&quot;,&quot;+o[1]); } }} 显示页面写了两种显示方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;s:head /&gt;&lt;/head&gt;&lt;body&gt;&lt;s:form action=&quot;addStudent&quot;&gt; &lt;s:textfield name=&quot;student.id&quot; label=&quot;ID&quot;/&gt; &lt;s:textfield name=&quot;student.name&quot; label=&quot;Name&quot;/&gt; &lt;s:textfield name=&quot;student.address&quot; label=&quot;Address&quot;/&gt; &lt;s:submit/&gt; &lt;hr/&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;Name&lt;/td&gt; &lt;td&gt;Address&lt;/td&gt; &lt;/tr&gt; &lt;s:iterator value=&quot;students&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;s:property value=&quot;id&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=&quot;name&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=&quot;address&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/s:form&gt;&lt;s:if test=&quot;students.size() &gt; 0&quot;&gt; &lt;table border=&quot;1px&quot; cellpadding=&quot;8px&quot;&gt; &lt;tr&gt; &lt;th&gt;Student Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Address&lt;/th&gt; &lt;/tr&gt; &lt;s:iterator value=&quot;students&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;s:property value=&quot;id&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=&quot;name&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=&quot;address&quot; /&gt;&lt;/td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/s:if&gt;&lt;/body&gt;&lt;/html&gt; 运行界面 输入信息之后submit加载到数据库中，并显示数据库中所有数据。","link":"/uncategorized/2018/11/11/jsp%E4%BD%9C%E4%B8%9A.html"},{"title":"[kuangbin带你飞13]基础计算几何","text":"","link":"/uncategorized/2018/09/06/kuangbin%E5%B8%A6%E4%BD%A0%E9%A3%9E13-%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95.html"},{"title":"[nowcoder1] J.Different Integers","text":"[nowcoder1]J. Different Integers题意给出一段序列$a_1,a_2,…,a_n$，和$l,r$，求区间$[1,l],[r,n]$中不同数字的个数。 题解树状数组+倍增序列 将查询的$l,r$转化为查询序列$[r,l+n]$中不同中数字的个数。 使用$pre[]$数组维护一个前缀不同种类数字的个数。针对查询就是$pre[r]-pre[l-1]$再加上同时出现在$[1,l-1]$和$[l,r]$上的元素，因为在计算$pre[r]$的时候对于和$[1,l-1]$序列中相同的元素是剔除的，但是减掉之后是需要再加上去的。 对于查询$a[l,…,r]$和$a[1,…,l-1]$内同时出现数字的种类，可以使用树状数组来进行维护。$bit[i]$表示$a[i]$已经在$1,…,l$出现过了。 先对区间查询进行离线排序操作，对于左端每次右移把对应的数的下一个位置加入到树状数组中即可。(嘤嘤嘤？) tips:处理每个位置数字下一次出现位置的方式很巧妙哦！ 123456789101112//last 记录上一个出现该数字的位置//nxt 记录下一个出现该数字的位置rep(i,1,n+1){ if(!vis[a[i]]){ vis[a[i]] = 1; pre[i] = pre[i-1]+1; }else{ pre[i] = pre[i-1]; } if(last[a[i]]) nxt[last[a[i]]] = i; last[a[i]] = i;} AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 2e5 + 10;int a[maxn],last[maxn],nxt[maxn],vis[maxn],pre[maxn],bit[maxn];int n,q;struct node{ int l,r,id; bool operator&lt;(const node&amp; x){ return l &lt; x.l; }}ask[maxn];int lowbit(int x){return x&amp;-x;}void update(int x,int val){ for(int i=x;i&lt;=n*2;i+=lowbit(i)){ bit[i] += val; }}int query(int x){ int s = 0; for(int i=x;i;i-=lowbit(i)){ s += bit[i]; } return s;}int query(int l,int r){ return query(r) - query(l-1);}void init(){ memset(vis,0,sizeof(vis)); memset(last,-1,sizeof(last)); memset(nxt,-1,sizeof(nxt)); memset(bit,0,sizeof(bit));}int main(){#ifdef LOCAL freopen(&quot;j.in&quot;,&quot;r&quot;,stdin);#endif while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;q)){ init(); rep(i,1,n+1) scanf(&quot;%d&quot;,&amp;a[i]),a[i+n] = a[i]; rep(i,1,n+n+1){ if(!vis[a[i]]){ pre[i] = pre[i-1] + 1; vis[a[i]] = 1; }else{ pre[i] = pre[i-1]; } if(~last[a[i]]) nxt[last[a[i]]] = i; last[a[i]] = i; } rep(i,0,q){ int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); int temp = l;l = r;r = temp + n; ask[i].l = l;ask[i].r = r;ask[i].id = i; } sort(ask,ask+q); int nowl = 1; int ans[maxn]; rep(i,0,q){ while(nowl &lt; ask[i].l){ if(~nxt[nowl])update(nxt[nowl],1); nowl++; } ans[ask[i].id] = pre[ask[i].r] - pre[ask[i].l-1] +query(ask[i].l,ask[i].r); } rep(i,0,q) printf(&quot;%d\\n&quot;,ans[i]); } return 0;} Reference:https://www.nowcoder.com/discuss/87249?type=101&amp;order=0&amp;pos=12&amp;page=1","link":"/acm/2018/08/28/nowcoder1-J-Different-Integers.html"},{"title":"[nowcoder3]补题向","text":"J.Coloring Tree题意给一棵树，每个节点从$[1,k]$选择一种颜色染。定义树的颜色值为两个相同颜色节点之间的最小值。问如果一棵树的颜色值为$D$，那么它有多少种染色方式。 题解 Reference:https://www.nowcoder.com/discuss/88556?type=101&amp;order=0&amp;pos=1&amp;page=1 本地能过就是能过谁能知道我为啥超时10%有重赏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e3 + 10;int n,k,D,tot;const ll mod = 1e9 + 7;struct node{ int next,to;}G[maxn&lt;&lt;1];int head[maxn],vis[maxn],cnt[maxn];void add(int u,int v){ G[tot].to = v; G[tot].next = head[u]; head[u] = tot++;}ll ans = 1;ll pow3(ll a,ll b){ ll res = 1; while(b){ if(b&amp;1) res = res*a%mod; a = a*a%mod; b&gt;&gt;=1; } return res;}ll bfs(int rt,int ds){ queue&lt;pII&gt; q; ll ans = 0; q.push(make_pair(rt,0));vis[rt] = rt; ans = cnt[rt]%mod; while(!q.empty()){ int u = q.front().fi; int d = q.front().se; q.pop(); if(d &gt;= ds) break; cnt[u]--; for(int i = head[u];~i;i=G[i].next){ int v = G[i].to; if(vis[v]==rt) continue; vis[v] = rt; q.push(make_pair(v,d+1)); } } return ans;}inline int read(){ int x=0; char c=getchar(); bool flag=0; while(c&lt;'0'||c&gt;'9'){if(c=='-')flag=1; c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0';c=getchar();} return flag?-x:x;}int main(){#ifdef LOCAL freopen(&quot;j.in&quot;,&quot;r&quot;,stdin);#endif memset(head,-1,sizeof(head)); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;D); rep(i,0,n-1){ int u,v; u =read();v= read(); add(u,v); add(v,u); } ll ans1 = 1,ans2 = 1; rep(i,1,n+1) cnt[i] = k; queue&lt;int&gt;q; memset(vis,0,sizeof(vis)); q.push(1);int sign[maxn]={0};sign[1] = 1; while(!q.empty()){ int u = q.front();q.pop(); ans1 = ans1*bfs(u,D)%mod; for(int i= head[u];~i;i=G[i].next){ int v = G[i].to; if(sign[v]) continue; sign[v] = 1; q.push(v); } } rep(i,1,n+1) cnt[i] = k; memset(sign,0,sizeof(sign)); q.push(1); sign[1] =1; while(!q.empty()){ int u = q.front();q.pop(); ans2 = ans2*bfs(u,D+1)%mod; for(int i= head[u];~i;i=G[i].next){ int v = G[i].to; if(sign[v]) continue; sign[v] = 1; q.push(v); } } printf(&quot;%lld\\n&quot;,(ans1-ans2+mod)%mod); return 0;} 真丶AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e3 + 10;int n,k,D,tot;const ll mod = 1e9 + 7;struct node{ int next,to;}G[maxn&lt;&lt;1];int head[maxn],vis[maxn],cnt[maxn],dis[maxn][maxn];void add(int u,int v){ G[tot].to = v; G[tot].next = head[u]; head[u] = tot++;}void dfs(int u,int fa,int rt){ for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(v == fa) continue; dis[v][rt] = dis[u][rt]+1; dfs(v,u,rt); }}ll solve(int d){ queue&lt;int&gt;q; rep(i,1,n+1) cnt[i] = k; ll ans = 1; q.push(1); memset(vis,0,sizeof(vis));vis[1] = 1; while(!q.empty()){ int u = q.front();q.pop(); ll res = 0; rep(v,1,n+1) if(v!=u) cnt[v] -= (dis[u][v]&lt;d); if(cnt[u] &lt;= 0) return 0; ans = ans*cnt[u]%mod; for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(dis[1][u]+1 == dis[1][v]){ q.push(v); } } } return ans;}inline int read(){ int x=0; char c=getchar(); bool flag=0; while(c&lt;'0'||c&gt;'9'){if(c=='-')flag=1; c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0';c=getchar();} return flag?-x:x;}int main(){#ifdef LOCAL freopen(&quot;j.in&quot;,&quot;r&quot;,stdin);#endif memset(head,-1,sizeof(head)); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;D); rep(i,0,n-1){ int u,v; u = read(); v = read(); add(u,v); add(v,u); } rep(i,1,n+1) dfs(i,-1,i); printf(&quot;%lld\\n&quot;,(solve(D)-solve(D+1)+mod)%mod); return 0;}","link":"/acm/2018/09/05/nowcoder3-%E8%A1%A5%E9%A2%98%E5%90%91.html"},{"title":"[pat1003]Emergency","text":"","link":"/uncategorized/2019/07/23/pat1003-Emergency.html"},{"title":"nowcoder6 C.Generation I","text":"Generation I题解首先放$k$种数字的情况，有$A_n^k$中可能。 由于操作后，前面的球就无法放置,就可以第一个放置该数字的点来确定该结果的区别。相当于将$k$种放在$n$个格子里面。使用隔板法$n\\choose k$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst ll mod = 998244353;int T;const int maxn = 1e6 + 10;ll cur,p[maxn],q[maxn],inv[maxn];ll n,m;ll C(ll n,ll k){ return p[n]*q[k]%mod*q[n-k]%mod;}ll c(ll n,ll k){ if(n&lt;maxn) return C(n,k); if(!k) return 1; return cur = cur*inv[k]%mod*((n-k+1)%mod)%mod;}void init(){ p[0] = p[1] = q[0] = q[1] = inv[0] = inv[1] = 1; for(ll i = 2;i&lt;maxn;i++){ inv[i] = (mod-mod/i)*inv[mod%i]%mod; q[i] = q[i-1]*inv[i]%mod; p[i] = p[i-1] * i % mod; }}int main(){#ifdef LOCAL freopen(&quot;j.in&quot;,&quot;r&quot;,stdin);#endif init(); scanf(&quot;%d&quot;,&amp;T); rep(test_case,1,T+1){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); ll len = min(n,m); ll ans = 0; cur = 1; for(ll i = 1;i&lt;=len;i++){ ans = (ans + (c(m,i)*p[i]%mod)*c(n-1,i-1)%mod)%mod; } printf(&quot;Case #%d: %lld\\n&quot;,test_case,ans); } return 0;}","link":"/acm/2018/08/24/nowcoder6-C-Generation-I.html"},{"title":"[pat1139]First Contact 前导零","text":"First Contact题意给定一个图，图中的点只有男的点或者女的点。给定两个不同的点AB，问他们第一个点通过两个不同的点找到第二个点，并且A找到的点和A同性，B连接的点跟B同性，这样的点对有多少对。 题解暴力枚举即可，找到所有相邻的同性点，之后同性点之间有连接就是一对点对。 wa点 前导零输出，-0000输入 中间的点不能是两边的点，必须是不同的四个点 ac代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headmap&lt;int,int&gt; mx;const int maxn = 3e2+10;int vis[maxn][maxn];int idx[maxn];int gender[maxn];void output(int x){ char ch[10]; ch[0] = '0'; ch[1] = '0'; ch[2] = '0'; ch[3] = '0'; ch[4] = '\\0'; int cnt = 3; while(x){ ch[cnt--] = (x%10)+'0'; x /= 10; } printf(&quot;%s&quot;,ch);}int trans(string x,int &amp;sign){ int a = 0; int sz = x.size(); if(x[0] == '-'){ rep(i,1,sz){ a += pow(10,4-i) * (x[i] - '0'); } sign = 1; }else{ rep(i,0,sz){ a += pow(10,3-i) * (x[i] - '0'); } } return a;}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int cnt = 1; rep(i,0,m){ string a,b; cin&gt;&gt;a&gt;&gt;b; int x,y; int sign1 = 0,sign2 = 0; x = trans(a,sign1) ; y = trans(b,sign2); if(mx[x] == 0){ mx[x] = cnt++; if(sign1) gender[mx[x]] = 1; idx[mx[x]] = x; } if(mx[y] == 0){ mx[y] = cnt++; if(sign2) gender[mx[y]] = 1; idx[mx[y]] = y; } int id1 = mx[x]; int id2 = mx[y]; vis[id1][id2] = vis[id2][id1] = 1; } int k;scanf(&quot;%d&quot;,&amp;k); rep(i,0,k){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); x = max(-1*x,x); y = max(-1*y,y); int id1 = mx[x]; int id2 = mx[y]; vector&lt;int&gt; xx;vector&lt;int&gt; yy; if(id1 == 0 || id2 == 0){ puts(&quot;0&quot;); continue; } rep(j,1,cnt+1) if(j != id2 &amp;&amp; vis[id1][j] &amp;&amp; (gender[id1]^gender[j]) == 0) xx.push_back(j); rep(j,1,cnt+1) if(j != id1 &amp;&amp; vis[id2][j] &amp;&amp; (gender[id2]^gender[j]) == 0) yy.push_back(j); vector&lt;pair&lt;int,int&gt;&gt; ans; for(auto x:xx){ for(auto y:yy){ if(vis[x][y] == 1){ ans.push_back(make_pair(idx[x],idx[y])); } } } sort(ans.begin(),ans.end()); printf(&quot;%d\\n&quot;,ans.size()); for(auto x:ans){ output(x.fi); printf(&quot; &quot;); output(x.se); puts(&quot;&quot;); //printf(&quot;%d %d\\n&quot;,x.fi,x.se); } } return 0;}","link":"/pat/2019/08/28/pat1139-First-Contact-%E5%89%8D%E5%AF%BC%E9%9B%B6.html"},{"title":"[uva10479]The Hendrie Sqquence","text":"The Hendrie Sequence题意给定一段序列的生成方式，问第$n$个元素是多少。 $0&lt;n&lt;2^{63}$。 $H(1) = 0$ $H(n) = H(n-1)$中的每个元素$a_i$，那么每个元素就生成一个小子序列$0,0,0,0,0,a_i+1$其中$0$的个数是$a_i$。 除了第一个元素之外的所有元素都要进行这种变化 举个例子, $H(1) = 0$ $H(2) =0,1$ //$0$变成了$0,1$ $H(4) = 0,1,0,2$ //$0$ 变成了$0,1$， $1$变成了$0,2$ $H(8) = 0,1,0,2,1,0,0,3$ //$0$ 变成了$0,1$， $1$变成了$0,2$ ,$2$变成了$0,0,3$ 题解找规律，我们可以发现每次都变化之后序列的长度都翻了一倍。所以我们单独把他增长的序列拿出来看。可以用心去发现这样一个规律。 定义增长的序列为$b_i$ $b_i$是由$1$个$b_{i-1}$，$2$个$b_{i-2}$，$3$个$b_{i-3}$，$4$个$b_{i-4}$…$i$个$b_{0}$ ,再加上一个单独的数字$i$。以此类推出来的。 那么我们就可以从第$n$个元素表示在它属于的那次增长中，它排第几个递归到最初的那几个元素中去，要判断一下范围。 由于题目中的数据比较极限，所以能用unsigned long long 还是用unsigned long long 吧。 如果用unsigned long long。一般数据量输入很小 可以用cin很靠谱。但是要把endl换成’\\n’还有输入 12std::ios::sync_with_stdio(false);cin.tie(0); 或者判断他是$2$的几次幂的时候可以这样子判断最高位的$1$在哪里。 1234ll n; int dep=0;ll temp = n;while(temp) temp&gt;&gt;=1,dep++;dep--; ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headll n;ll lie[10][20] ={ {0}, {1}, {0,2}, {1,0,0,3},{0,2,1,1,0,0,0,4}};ll solve(ll x,int dep){ if(dep&lt;5){ return lie[dep][x]; } ll st = 0; rep(i,2,dep+1){ ll temp = pow(2,dep-i-1); if(i==dep) temp = 1; if(x&lt;temp*(1ll*i-1ll)+st) return solve((x-st)%temp,dep-i); st += temp*(ll)(i-1); } return dep;}int main(){#ifdef LOCAL freopen(&quot;4.in&quot;,&quot;r&quot;,stdin);#endif std::ios::sync_with_stdio(false); cin.tie(0); while(cin&gt;&gt;n &amp;&amp; n){ int dep = 0;ll temp = 1; n--; ll tn = n; while(tn) tn/=2,dep++; temp&lt;&lt;=(dep-1); n = n - temp; cout&lt;&lt;solve(n,dep); cout&lt;&lt;'\\n'; } return 0;}","link":"/acm/2018/11/17/uva10479-The-Hendrie-Sqquence.html"},{"title":"web应用开发笔记","text":"web应用开发现代人的生活方式 移动端,mobile 浏览器,browser 10年前还是以客户端,client软件形式。 两个主流技术 .Net J2ee .Net过气了，用J2ee J2ee的三个方面 M 模型:负责数据方面的事情，数据分为两个方面，store存储，access访问。依靠模型完成这个功能。 承载数据。 把数据中的信息进行表达convey，存储信息和加工信息。 不只是一个dbms。 V 视图:将信息呈现出来，view显示。 把数据呈现给用户。 承载用户修改功能，使用户能够修改信息。 C 控制:把用户的信息进行处理(按照一定的算法和一定的逻辑)，之后再保存在M端。 summary：M存储信息，V交互，C逻辑控制（算法）。 梅宏，杨芙青，吕健——网构建 开发V端V html,jsp,css,jQuery 自学html。 在w3c学 jQuery,是js的一个库。 extjs 扩展版js 丰富了UI设计功能 开发M端MySql，Oracle，SQL server,DB2,Access 框架Hibernate统一了不同的dbms的操作。 缺点：是将数据和公共模型进行映射，一旦确定就不好改变，开发的时候麻烦。 iBatis 容易改进的框架 MyBatis 开发C端struts 框架，把数据进行逻辑处理之后保存到M端。 jQuery js spring 开发代码是Java。framework 开发模式Html + css + mySQL 几种在view端和modle端 jsp + css + mySQL jQuery+css+mySQL PHP + css + mySQL 这些都是小型网站。 乐色 我们的模式 JSP+Struts+mySQL plus + spring + ssh Real 项目： JSP + SSH + CSS + MYSQL SSH Spring Struts HibernateJSP详解element 语素123&lt;% //可以嵌入语句%&gt; 有三类语句 表达式 小脚本 声明 声明table称为一个标签，tag。标签有很多属性 看看JSP和mySQLNaviCat可视化操作MySQL 1433 SQLServer 3306 mySQL 端口 各种端口号是必记。 Myecl集成了子IDE,所以比较方便。 JAR包是将java代码和文档集成在一个包中。 5.1.35java connect是可以用的 jdbc driver URL，第一节是JDBC协议，第二节是MySQL表示数据库名称，第三节是代表这MySQL服务器的名字，localhost 127.0.0.1,第四节是端口号。后面都删掉。后面是连着的库。 driver name 随便取。 Schema 是 database的超集。 datebase是table的超集。 数据库1StringTypeConversion //把子段转化成串 connection transantion statement resultset 先建立连接，使用JSP连接MySQL getConnection函数是静态类型，可以通过类名直接调用函数。 语句分为两方面 静态的， 动态的，是由运行时候确定的查询和修改语句 获得了resultset之后因为其中有很多条记录，所以必须要用循环。resultset自带了迭代器，iterator。一行一行，一个记录一个记录访问。 123456//把当前指针指向的record赋予re,之后指针往下走。while(re.next()){ TypeConversion(rs,Type.VARCHAR,1);//and so on 把结果串加入过来。 } 1234rs.close();stmt.close();conn.close();// 记得关闭连接 一级一级一级往回退 交互界面(登陆界面)早年窗口还叫Window，现在流行叫frame。 使用html的指令去做 使用JSTL做窗口，使用扩展模板库 123&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt;&lt;/input&gt;&lt;input type=&quot;password&quot; name=&quot;pass&quot;&gt;&lt;/input&gt;&lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;&lt;/input&gt; MVC的思想C的思想逻辑控制部分，与应用与需求是相关的。 Struts的本质是借用了java类或者说是函数映射成了一个action，就像html的标签一样可以任意的去使用它。 Struts缺省的配置文件是Sruts.xml 。 web.xml 配置struts.xml文件 建立Action类文件 建立Action执行后转向的jsp文件。 例子${message} 直接将message类中的信息直接输出出来。 他把control端的数据在页面里输出出来。 那么如何把view端的数据在control中获得呢？ 实现原理 数据共享 data sharing 配置文件 configuration struts2提供在一个类中，具有一定特征的函数就可以映射成actions。 resultdispatcher分发包裹的方式，之前建立的页面缺省的是dispatcher。","link":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2018/09/03/web%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.html"},{"title":"三月计划","text":"March每天记录一点在计算中心的计划。 a plan a day,a master i will be. even a phD! 3/11 背一单元单词 高数第一单元finish hash题目搞定 不看贴吧 不看斗鱼 hash完成了两道。 贴吧看的飞起。斗鱼看的飞起。 3/12 颓废一天 3/13 上计算机网络 不看Bilibili 不看斗鱼 不看贴吧 不看知乎 不点外卖 3/14 背单词 帮个同学搬宿舍 cf回顾+字符串题目 3/15 不看Bilibili 不看斗鱼 不看贴吧 不看知乎 不点外卖 背单词 高数题目做做做 并纠错。 3/163/17 不看Bilibili 不看斗鱼 不看贴吧 不看知乎 不点外卖 3/18 不看Bilibili 不看斗鱼 不看贴吧 不看知乎 不点外卖 计算机网络作业搞定 高数课后习题 整理一下 cf题目D搞定 蓝桥杯题目+字符串题目 at least 5 p 蓦然回首已经是四月9号了。看来我还是比较摸鱼的。 计划都没有实施的比较完善。 我决定，开启流浪四月计划，四月每周更新一下一周做了什么事情。","link":"/%E8%80%83%E7%A0%94%E8%B7%AF%E6%BC%AB%E6%BC%AB/2019/03/11/%E4%B8%89%E6%9C%88%E8%AE%A1%E5%88%92.html"},{"title":"上海科技大学信息学院夏令营随笔","text":"随笔以此记录我人生中的第一次面试 前因因为在报名夏令营的时候，一个公众号将上海科技大学加入列表中，我才知道有上海科技大学这所大学。之后查了以后发现上科大是一所2013年建成的精致的大学。查了以后发现上科大的师资力量和学校经济实力十分得强大，所以就报名了上科大的信息学院夏令营并通过了初审。 过程我选择的是第一批次，之后在生产实习的时候请假来到上海，来到上科大的第一感觉就是这个学校很精致，很有设计感。里面的每一栋建筑明显都是有设计过的痕迹，并且没有一座建筑是长得一样的！ 之后入住了上科大的研究生宿舍，2人一间，宿舍是酒店标间的设计。 面试上一届上科大夏令营是3个老师来面试每一个人。这一届上科大选择了老师同学双向选择面试，你可以面试很多老师，只要你去找这个老师即可。我一开始的目标老师是tkw老师，但是这位老师一直没有回我邮件。所以我就去给hxm老师和yjy老师发了邮件。之后他们都有回复。第一天上午是参观学校并介绍学校的毕业生去向。下午自由活动，由于给hxm老师发邮件的人实在是太多，所以老师选择先让我们笔试。笔试的内容大概就是计算机专业课+机器学习中的线性代数和概率论+程序设计算法思维题。我由于计算机网络还没有复习完，并且专业课的内容学得也没有那么扎实，所以第二天没有能够和hxm老师面试，惨遭淘汰。之后第二天上午，我去了yjy老师，yjy老师有两次面试，一次是让他的博士生来面试，主要的内容就是简历中他们感兴趣的内容，之后我程序竞赛还算是比较认真的。通过了一面，来到了二面，二面中，老师会先让你自我介绍，之后会让你提一些你感兴趣的问题。但是作为一个死读书的，我哪里来那么多问题。如果在给我一次机会的话，我会问：博士毕业后创业，我看先前有学姐介绍有一个人就是通过他自己研究生的课题发展成为一家公司，并且我在乔布斯访谈中也了解到，乔布斯当时在车库中创业是因为他们组装的电脑收到了很大的欢迎，那么老师，如果您推荐创业，您的课题中有哪一些课题是比较适合落地并且创业的呢？二面我感觉蛮糟糕的。之后我去了zr老师的面试，老师是比较偏硬件的，但是人面试的时候十分好，hin温柔。之后老师问我有没有问题，我当时有点紧张，所以就没有问老师。。如果再给我一个机会的话，我会问：老师由于我大一到现在基本上都在程序设计竞赛，没有完整地参加过一次科研活动，我就想问一下您，您觉得一次科研的过程大概是怎样的。之后科研在现在到底是会对这个社会产生怎样的影响。因为我看现在的公司工业界感觉创造的成就比学术界更加强力并且落地的程度更加完善。您觉得工业界和学术界各有什么优劣势吗？ 结尾食堂不咋地，但是住宿很舒服，环境很好，并且听说研究生的补助很高，大概每个人2000+每个月是肯定的。觉得有点遗憾的就是，没有面试足够多的老师，本来我就是来积累面试经验的，结果就面试了两个老师，有点亏。。 总结自我介绍，还是需要整理一下的，必须要让老师有亮眼的地方！","link":"/%E4%BF%9D%E7%A0%94/2019/07/11/%E4%B8%8A%E6%B5%B7%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E4%BF%A1%E6%81%AF%E5%AD%A6%E9%99%A2%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%9A%8F%E7%AC%94.html"},{"title":"八数码问题","text":"八数码问题前提知识 康拓展开用途相当于hash存储序列，使用更加小的空间来存储排列。 公式$X = a_n*(n-1)!+a_{n-1}(n-2)+…+a_10!$，$a_i$表示当前未出现的数字是排在第几个元素。$0 \\leq a_i &lt; i,1 \\leq i \\leq n$ 实现1234567891011121314int fac[maxn];fac[0] = 1;rep(i,1,max) fac[i] = fac[i-1]*i;int cantor(){ int ans = 0; rep(i,0,maxn){ int cnt = 0; for(int k=i+1;k&lt;maxn;k++){ if(vis[k]&lt;vis[i]) cnt++; } ans += fac[n-i]*cnt; } return ans;} reference:https://blog.csdn.net/cyningsun/article/details/6797128","link":"/acm/2018/08/31/%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98.html"},{"title":"前端修炼手册","text":"前端修炼手册使用工具语言：js+html 框架:echarts+impress 经历一开始我就在寻找有什么能够跟ppt一样，展示出我们的数据分析图表的框架，之后我就搜索到了impress.js这个框架。他的效果很酷炫，非常适合拿来展示自己的作品甚至代替ppt来使用。 官方demo:https://impress.js.org/#/bored 半小时因为impress.js的版本不对，搞了半天。应该直接去github下载就行了。 之后遇到了一个坑点，jsp嵌入html5的时候，载入js脚本的时候，必须声明是javascript，否则可能会出错。 并且jsp声明html5的格式为 123456789101112&lt;!DOCTYPE HTML&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;","link":"/%E5%89%8D%E7%AB%AF/2019/05/09/%E5%89%8D%E7%AB%AF%E4%BF%AE%E7%82%BC%E6%89%8B%E5%86%8C.html"},{"title":"回文树学习笔记","text":"回文树学习笔记神奇的数据结构 Palindromic Tree 回文树功能简介 求一个串$S$中$[0,i]$中本质不同回文串的个数 求串$S$中每一个本质不同回文串出现的次数 求指定下标$i$结尾的回文串的个数 变量简介 $len[i]$表示编号为$i$节点所表示的回文串的$len$。 $next[i][c]$表示编号为$i$的节点表示的回文串在两边添加字符$c$之后会变成的回文串的编号。 $fail[i]$表示节点$i$失配以后跳转后不等于自己的节点$i$所表示的回稳产的最长长度。 $cnt[i]$表示节点$i$表示的本质不同的串的个数。 $num[i]$表示以节点$i$表示的最长回文串的最右端点为回文串结尾的回文串个数。 $last$指向新添加一个字母后所形成的最长回文串表示的节点。 $S[i]$表示第$i$次添加的字符(初始化S[0]=不存在的字符)。 $p$表示添加的节点个数。 $n$表示添加的字符个数。 模板(抄的)123456789101112131415161718192021222324252627282930313233343536373839404142const int maxn = 1e5+10;const int N = 26; // attention 用模板的时候要改变struct Ptree{ int next[maxn][N]; int fail[maxn]; int cnt[maxn]; int num[maxn]; int len[maxn]; int S[maxn]; int last,n,p; int newNode(int x){ rep(i,0,N) next[p][i] = 0; cnt[p] = 0;num[p] = 0;len[p] = x; return p++; } void init(){ p = 0; newNode(0);newNode(-1); last = 0; n = 0;S[n] = -1;fail[0] = 1; } int get_fail(int x){ while(S[n-len[x]-1] != S[n]) x = fail[x]; return x; } void add(int c){ c -= 'a'; // attention 用模板的时候要改变 S[++n] = c; int cur = get_fail(last); if(!next[cur][c]){ int now = newNode(len[cur]+2); fail[now] = next[get_fail(fail[cur])][c]; next[cur][c] = now; num[now] = num[fail[now]] + 1; } last = next[cur][c]; cnt[last]++; } void count(){ per(i,0,p) cnt[fail[i]] += cnt[i]; }} https://blog.csdn.net/u013368721/article/details/42100363","link":"/%E6%A8%A1%E6%9D%BF/2018/09/03/%E5%9B%9E%E6%96%87%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"单调队列学习笔记","text":"单调队列定义单调队列，就是指队列中的元素是单调的。 $a_1,a_2,a_3,…,a_n$满足$a1\\leq a_2\\leq a_3…\\leq a_n$的序列便是单调序列。 运用单调队列可以简化问题，由于队列是单调的，那么我们存取最大最小值的复杂度均是$O(1)$。而每一个元素入队一次，出队一次的复杂度也是$O(1)$。 而单调队列和数据结构deque结合较好，如果题目的数据量不是很大，没有卡std，就可以使用deque实现。 维护以单调增序列为例子： 如果队列长度一定，先判断队首元素是否在规定范围内，如果超范围就弹出队首。 每次加入元素和队尾比较，如果当前元素小于队尾元素并且队列非空，就弹出队尾指针，直到满足单调性为止。 例题1 合并果子(题目太老，只能换个改版的。代码有一定问题，细心的人能看下出来。) 题解建两个单调队列，寻找两个最小值加入其中一个堆中，有点像haffman编码的方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define pb push_backtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e4 + 10;int n,ans;int a[maxn];int T;int main(){#ifdef LOCAL freopen(&quot;111.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;n); rep(i,0,n){ scanf(&quot;%d&quot;,&amp;a[i]); } deque&lt;int&gt; dq1; deque&lt;int&gt; dq2; sort(a,a+n); rep(i,0,n) dq1.pb(a[i]); ans = 0; int x,y; rep(i,0,n-1){ if(dq2.empty()){ x = dq1.front(); dq1.pop_front(); }else if(dq1.empty()){ x = dq2.front(); dq2.pop_front(); }else{ if(dq1.front() &lt; dq2.front()){ x = dq1.front(),dq1.pop_front(); }else{ x = dq2.front(),dq2.pop_front(); } } if(dq2.empty()){ y = dq1.front(); dq1.pop_front(); }else if(dq1.empty()){ y = dq2.front(); dq2.pop_front(); }else{ if(dq1.front() &lt; dq2.front()){ y = dq1.front(),dq1.pop_front(); }else{ y = dq2.front(),dq2.pop_front(); } } ans += (x+y); dq2.pb(x+y); } printf(&quot;%d\\n&quot;,ans); return 0;} 例题2 Sliding Window 题解单调队列+维护一下队头指针不能超过$k$的范围。 由于有最大值和最小值，维护两个单调队列。 需要注意一下的就是如果是手写双向队列的话，我一般是定义 12345int st,ed;st = ed = 0;mmax[ed++] = a[0];//判定的时候需要判定ed-1才是指向队尾的值while(st&lt;ed &amp;&amp; mmax[ed-1]&lt;=a[i]) ed--; AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e6 + 10;int n,k;int a[maxn];int mmax[maxn];int mmin[maxn];int main(){#ifdef LOCAL freopen(&quot;12.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;n,&amp;k); rep(i,0,n) scanf(&quot;%d&quot;,&amp;a[i]); int st1,st2,ed1,ed2; st1 = st2 = ed2 = ed1 = 0; mmax[ed1++] = 0; mmin[ed2++] = 0; rep(i,0,k-1){ while(st1&lt;ed1 &amp;&amp; a[mmax[ed1-1]] &lt;= a[i]) ed1--; mmax[ed1++] = i; while(st2&lt;ed2 &amp;&amp; a[mmin[ed2-1]] &gt;= a[i]) ed2--; mmin[ed2++] = i; } rep(i,k-1,n){ while(st2&lt;ed2 &amp;&amp; i-mmin[st2]+1 &gt; k) st2++; while(st2&lt;ed2 &amp;&amp; a[mmin[ed2-1]] &gt;= a[i]) ed2--; mmin[ed2++] = i; printf(&quot;%d%c&quot;,a[mmin[st2]],i==n-1?'\\n':' '); } rep(i,k-1,n){ while(st1&lt;ed1 &amp;&amp; i-mmax[st1]+1 &gt; k) st1++; while(st1&lt;ed1 &amp;&amp; a[mmax[ed1-1]] &lt;= a[i]) ed1--; mmax[ed1++] = i; printf(&quot;%d%c&quot;,a[mmax[st1]],i==n-1?'\\n':' '); } return 0;} 例题3 Max Sum of Max-K-sub-sequence题意给定一个序列，求不超过$k$长的最大连续子段和。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint T,n,k;const int maxn = 1e5 + 123;int a[maxn*3];int b[maxn];int main(){#ifdef LOCAL freopen(&quot;11.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); rep(i,0,n) scanf(&quot;%d&quot;,&amp;b[i]); rep(i,1,n*2+1) a[i] = (a[i-1] + b[(i-1)%n]); deque&lt;int&gt; dq; int ans = -INF; int l,r; rep(i,1,2*n+1){ while(!dq.empty() &amp;&amp; i-dq.front() &gt; k) dq.pop_front(); while(!dq.empty() &amp;&amp; a[dq.back()] &gt; a[i-1]) dq.pop_back(); dq.push_back(i-1); int temp = a[i] - a[dq.front()]; if(ans &lt; temp){ ans = temp; l = dq.front()+1; r = i; if(r&gt;n) r-=n; } } printf(&quot;%d %d %d\\n&quot;,ans,l,r); } return 0;} 例题4 Subsequence题意给定一段序列，求最长的一段子序列，他的条件是 最大和最小值的差不超过$k$也不小于$m$。 题解建立两个单调队列，维护$i$之前最大值的下标和$i$之前最小值的下标。 如果最大值最小值超过$k$就弹出下标较小的，并记录较小的位置。 答案是$i-pos$，如果之后的点满足条件了，那么说明$[pos+1,n]$是满足条件的，因为e.g.$a[min[st] 到min[st+1]]$中的元素都大于$a[min[st+1]]$，如果$a[min[st+1]]$满足那么，$a[min[st]+1]$肯定满足条件。 心路历程：我真是太弱了，这就是一道基础的单调队列题目，我想到用两个单调队列来维护，但是对于小于$k$和大于$m$这个条件，不知道怎么去掌控，妈蛋，其实可以靠单调队列的单调性来掌控他们之间的差距。因为一个是递增一个是递减，如果他们之间的差距过大，那么就可以pop掉队首元素，来减少他们的差距，那么大于$m$怎么维护呢？那就是特判他们之间差距是否大于$m$,大于的话就更新一下答案。对于每个$i$就是维护了他之前最大的值的下标和最小值的下标。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,m,k;const int maxn = 1e5 + 10;int a[maxn];int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k)){ rep(i,1,n+1) scanf(&quot;%d&quot;,&amp;a[i]); deque&lt;int&gt; dq1; //min deque&lt;int&gt; dq2; //max int ans = 0;int pos = 0; rep(i,1,n+1){ while(!dq1.empty() &amp;&amp; a[dq1.back()]&gt;=a[i]) dq1.pop_back(); dq1.push_back(i); while(!dq2.empty() &amp;&amp; a[dq2.back()]&lt;=a[i]) dq2.pop_back(); dq2.push_back(i); while(!dq1.empty() &amp;&amp; !dq2.empty() &amp;&amp; a[dq2.front()]-a[dq1.front()]&gt;k){ if(dq1.front() &lt; dq2.front()) pos = dq1.front(),dq1.pop_front(); else pos = dq2.front(),dq2.pop_front(); } if(!dq1.empty() &amp;&amp; !dq2.empty() &amp;&amp; a[dq2.front()]-a[dq1.front()] &gt;=m) ans = max(ans,i-pos); } printf(&quot;%d\\n&quot;,ans); } return 0;} 例题5 Trade题意股票交易 $i$天你可以以$APi$价格买入股票，$BPi$价格卖出股票 $i$天最多买$ASi$股，最多卖$BSi$股 最多拥有$MaxP$股股票 交易后有缓冲期$M$天 开始无限制的钱，问最多能赚多少钱？ 题解AC代码例题6 Cut the Sequence例题7 瑰丽华尔兹例题8 Sequence Partitioning http://www.voidcn.com/article/p-bcrxdtjx-nd.html","link":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2018/08/28/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"快读模板","text":"1234567891011121314151617181920212223242526template &lt;typename T&gt; inline bool read (T &amp;ret) { char c; int sgn; if (c = getchar(), c == EOF) return 0; //EOF while (c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9') ) { if((c = getchar()) == EOF) return 0; } sgn = (c == '-') ? -1 : 1; ret = (c == '-') ? 0 : (c - '0'); while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + (c - '0'); ret *= sgn; return 1; } template&lt;typename T&gt;void print(T x) { static char s[33], *s1; s1 = s; if (!x) *s1++ = '0'; if (x &lt; 0) putchar('-'), x = -x; while(x) *s1++ = (x % 10 + '0'), x /= 10; while(s1-- != s) putchar(*s1);}template&lt;typename T&gt;void println(T x) { print(x); putchar('\\n');}","link":"/uncategorized/2018/09/10/%E5%BF%AB%E8%AF%BB%E6%A8%A1%E6%9D%BF.html"},{"title":"我是Makefile","text":"我是Makefile我是makefile而不是makelove。最近学校开了Linux这门课，于是我就开始自学Linux了，看的是《Linux就是这个范儿》。实名制推荐，语言又风趣又实在。 什么是Makefile作为一名程序员，我们第一个程序大概率是通过vs或者是vc6.0来写的。这些都是IDE集成开发环境，他们帮我们做了很多事情，很多底层的事情。其中比较重要的就是编译这个命令了。如果像我参加acm的，会知道如果经常只是写一个单cpp文件的话，我们只需要使用GCC中的g++命令就可以完成将cpp文件编译成可执行文件，但是如果我们是写一个项目呢？如果我们的项目中有好几个头文件，好几个cpp文件呢？这时候makefile就出现了。 Makefile的作用就是自动化编译，一旦我们写好了makefile文件，只需要一个make命令，整个工程就能自动编译。Makefile定义了一系列的规则，来指定哪些文件需要先编译，哪些文件需要后编译，就像一个shell脚本一样。 IDE是高手的挡泥板，却是新手的遮阳伞。 我在南大的编译原理课件中就看到，他们项目的要求也是要用Makefile来完整的做一个项目的。南大还是南大啊。 Makefile的基本概念目标、条件和命令对于Makefile来说，最最重要的就是目标、条件和命令这三大要素。 目标是make要产生的东西或者是要做的事情 条件是用于产生目标所需要的文件 命令是有条件转化为目标的方法 举个例子 12main.o:main.c line.h buffer.h tedef.h cc -c -o main.o main.c main.o就是目标，main.c line.h buffer.h tedef.h就是条件，最下面那句”cc -c -o main.o main.c”就是命令。 all命令就是Makefile的默认目标。 基本语法Makefile是看成是一种解释型语言，一般解释型语言都是采用“自顶向下”的解释逻辑。 tip:所有命令都是需要以\\tab开头的，规定如此 变量作为一种类似语言的东西，那么变量肯定是少不了啊。Makefile中的变量类似于宏替代，采用的语法。 1CC := gcc -g 这就定义了一个变量，变量的名称是CC，变量的值是”gcc -g”，我们可以用”$()或者${}”来替代。 自动变量Makefile中有特殊变量，他们可以自动取用一条规则中目标和条件中的元素，这样就可以节省输入文件名和条件文件名的力气。ps:确实在vim一键编译中我也看到了类似的东西。 并且自动变量不需要加$().","link":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2019/04/11/%E6%88%91%E6%98%AFMakefile.html"},{"title":"最大子段和学习笔记","text":"最大子段和学习笔记什么是最大子段和？给定$n$个整数(可以为负数)组成的序列$a_1,a_2,…,a_n$，求该序列连续的字段和最大值。显然如果都是负数最大值可以为0。 解决方案1暴力枚举开始位置$i$和终止位置$j$，对每一种可能性计算和。 复杂度$O(n^3)$ 解决方案2使用前缀和优化，保存$\\sum_{i=1}^{j-1}a[i]$的结果。 复杂度$O(n^2)$ 解决方案3采用分治策略优化复杂度。 将给定序列$a$分成长度两段子序列$a[1,n/2],a[n/2+1,n]$，分别求出这两段的最大子段和，而总序列的最大子段和有三种情况 和前半段相同 和后半段相同 由前半段的部分和后半段的部分组成的序列相同 1234567891011121314151617181920int MaxSubSum(vector&lt;int&gt; ve,int l,int r){ int sum = 0; if(l==r) return max(ve[l],0); int mid = (l+r)&gt;&gt;1; int lm = MaxSubSum(ve,l,mid); int rm = MaxSubSum(ve,mid+1,r); int ls = 0;int lefts = 0; for(int i=mid;i&gt;=l;i--){ lefts += ve[i]; ls = max(ls,lefts) //遍历更新最大值 } int rs = 0;int rights = 0; for(int i=mid+1;i&lt;=r;i++){ rights += ve[i]; rs = max(rs,rights); } sum = ls + rs; sum = max(sum,max(lm,rm)); return sum;} 复杂度$O(nlogn)$ 解决方案4动态规划。 设置$dp[i] = max(dp[i-1]+a[i],a[i])$，$dp[i]$表示以$i$为结尾的最长子串的和。 对于每一个$a[i]$如果之前的最大子串小于$0$了，那么就要重新以他为开头建立一个子串。 123456789101112131415161718int MaxSubSum(vector&lt;int&gt; ve,int n,int&amp; l,int&amp; r){ int sum = -INF;int mmax = -INF; int L=0;int R = 0; for(int i=0;i&lt;n;i++){ if(sum &lt; 0){ sum = ve[i]; L = R = i; }else{ sum += ve[i]; R ++; } if(mmax &lt; sum){ mmax = sum; l = L;r = R; } } return mmax;} 复杂度$O(n)$ 解决方案5最大子段的左右两个数字必定为正数，最左边数字 reference:https://blog.csdn.net/zhong36060123/article/details/4381391","link":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2018/08/27/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"杭电多校Age_of_Moyu","text":"Age of Moyu题解标程的set+bfs貌似有漏洞。 12345675 61 2 12 3 13 4 14 5 11 3 21 4 3 这个数据就可以hack掉了。 所以我果断copy了dls队伍的代码。(用边做) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;inline char inputchar(){ return getchar();}inline void inputnum(int &amp;ret){ char ch = inputchar(); while(ch &lt; '0' || ch &gt; '9') ch = inputchar(); ret = ch - '0'; ch = inputchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') { ret = ret * 10 + ch - '0'; ch = inputchar(); }}const int MAXN = 101010, MAXM = 202020;int n, m;class Edge{public: int to, c, next;}e[MAXM * 2];int en, head[MAXN];int dis[MAXM];deque&lt;int&gt; q;void insert(){ int u, v, c;// scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;c); inputnum(u); inputnum(v); inputnum(c); e[++en].to = v; e[en].c = c; e[en].next = head[u]; head[u] = en; e[++en].to = u; e[en].c = c; e[en].next = head[v]; head[v] = en;}bool solve(){ if(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != 2) return false; memset(head, -1, (n + 2) * sizeof(int)); en = 1; for(int i = 1; i &lt;= m; i++) insert(); memset(dis, 1, (m + 2) * sizeof(int)); for(int i = head[1]; i &gt; 0; i = e[i].next) dis[i / 2] = 1, q.push_back(i / 2); while(!q.empty()) { int now = q.front(); q.pop_front(); for(int i = head[e[now * 2].to]; i &gt; 0; i = e[i].next) if(e[i].c == e[now * 2].c) { if(dis[i / 2] &gt; dis[now]) dis[i / 2] = dis[now], q.push_front(i / 2); } else { if(dis[i / 2] &gt; dis[now] + 1) dis[i / 2] = dis[now] + 1, q.push_back(i / 2); } for(int i = head[e[now * 2 + 1].to]; i &gt; 0; i = e[i].next) if(e[i].c == e[now * 2 + 1].c) { if(dis[i / 2] &gt; dis[now]) dis[i / 2] = dis[now], q.push_front(i / 2); } else { if(dis[i / 2] &gt; dis[now] + 1) dis[i / 2] = dis[now] + 1, q.push_back(i / 2); } } int ans = MAXM; for(int i = head[n]; i &gt; 0; i = e[i].next) if(ans &gt; dis[i / 2]) ans = dis[i / 2]; if(ans == MAXM) ans = -1; printf(&quot;%d\\n&quot;, ans); return true;}int main(){#ifdef LOCAL freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);#endif while(solve()); return 0;} 时间卡的非常紧。优化了很多终于2.4s过了。 $$O(n^2)$$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headvoid read(int &amp;x){ char ch = getchar();x = 0; for (; ch &lt; '0' || ch &gt; '9'; ch = getchar()); for (; ch &gt;='0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = x * 10 + ch - '0';}const int maxn = 1e5 + 10;int n,m,ans,cnt;int head[maxn],dis[maxn&lt;&lt;1];struct Edge{ int to,next,idx;}G[maxn&lt;&lt;2];void add(int u,int v,int id){ G[cnt].to = v; G[cnt].next = head[u]; G[cnt].idx = id; head[u] = cnt++;}deque&lt;int&gt; q;void bfs(){ for(int i = head[1];~i;i=G[i].next) dis[i/2] = 1,q.push_back(i/2); while(!q.empty()){ int now = q.front(); q.pop_front(); for(int i = head[G[now*2].to];~i;i=G[i].next){ if(G[i].idx == G[now*2].idx){ if(dis[i/2] &gt; dis[now]){ dis[i/2] = dis[now];q.push_front(i/2); } }else{ if(dis[i/2] &gt; dis[now] + 1){ dis[i/2] = dis[now]+1;q.push_back(i/2); } } } for(int i = head[G[now*2+1].to];~i;i=G[i].next){ if(G[i].idx == G[now*2+1].idx){ if(dis[i/2] &gt; dis[now]){ dis[i/2] = dis[now];q.push_front(i/2); } }else{ if(dis[i/2] &gt; dis[now]+1){ dis[i/2] = dis[now]+1;q.push_back(i/2); } } } } ans = INF; for(int i = head[n];~i;i=G[i].next){ if(ans &gt; dis[i/2]) ans = dis[i/2]; }}int main(){#ifdef LOCAL freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);#endif while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){ memset(head,-1,sizeof(int)*(n+2));cnt = 0; rep(i,0,m+2) dis[i] = INF; rep(i,0,m){ int u,v,id;read(u);read(v);read(id); add(u,v,id);add(v,u,id); } bfs(); printf(&quot;%d\\n&quot;,ans==INF?-1:ans); } return 0;}","link":"/acm/2018/08/19/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1Age-of-Moyu.html"},{"title":"树形dp5题连做","text":"树形dp，3天搞定A - Information Disturbing题意对于一棵树，切断一些边使得每一个叶节点都无法连接到根节点，有两个要求 每条边带权重，切掉的边权重和不大于$m$ 切掉的每条边都不能大于一个$ans$ 问$ans$最小是多少？ 题解二分+树形dp +1 ans初始化-1 看别人代码发现了个好东西，链式前项星判断节点是否为叶节点可以这样判断 1234if(G[head[u]].to == father) 该节点是叶节点 //在双向边的时候适用if(head[u]==-1) 该节点是叶节点 //在单向边的时候适用 ac代码","link":"/acm/2018/10/09/%E6%A0%91%E5%BD%A2dp5%E9%A2%98%E8%BF%9E%E5%81%9A.html"},{"title":"树链剖分学习笔记","text":"树链剖分学习笔记题型当一道题在询问两点之间修改后的权值或者是两点之间边修改后的权值。这类题目往往我们一开始就会思考用线段树来维护，但是线段树无法维护一颗树上的链，所以我们需要来将树上的链剖分下来。 轻重边剖分将树中的边分为两部分，轻边和重边，用$size[u]$来记录以$u$为根的子树的节点个数，之后令$v$为$u$的儿子中$size$最大的一个，那么我们就可以将$u$的边分为重边和轻边了(重边就是$(u.v)$)。 之后我们就可以得到如下性质 如果$(u,v)$为轻边，那么$size[v] \\leq size[u]/2$。因为如果大于的话，他就成为重边了。 从根到某一点的路径上轻边的个数不会超过$logN$。假设从$root-&gt;v$，那么$size[v]&gt;=1$，可以递推出$size[root]&gt;=2^k$，其中$k$为根到点进过的点数。 实现初始化操作首先我们定义以下几个数组 $size[v]$表示以$v$为根的子树的节点数 $dep[v]$表示$v$的深度（根的深度为1） $top[v]$表示所在重链的顶端节点 $fa[v]$表示父亲节点，$son[v]$表示重儿子节点 $w[v]$表示与父亲的连边 然后我们使用两个dfs来把数组确定下来。 第一个dfs求出fa,dep,size,top,w。 第二个dfs 对于循环到的$v$，当$son[v]$存在的时候，也就是非叶子节点，那么$top[son[v]] = top[v]$是显而易见的。在线段树中我们规定孩子节点的重边必须在父亲节点的后面，那么$w[son[v]]=totw+1$，其中$totw$表示线段树中加入的最后一条边的位置。之后进行递归dfs(son[v]); 对于$v$的轻孩子，那么他们没有身处重链所以$top[x]=x$。那么我们为了线段树好看一点也将他加入线段树。$w[x]=totw+1$。 经过两个dfs我们把所有的数组都给他确认了。 这代码量该有多大啊，对于常年只写70行就要debug很久的我来说。 更新操作因为我们其实也是慢慢修改路径上的边的，所以我们先求个LCA。之后更新$u,v$到祖先节点。方法意会吧，或者看代码。 查询操作跟更新操作很像，就是在过程中不再更新，而是求值。 例题Aragorn’s Story+1 更新节点的时候必须在id[x]更新 +1 大于小于没弄明白，在change函数中。 +1 update的时候以为是线段树直接从左边更新到右边，其实是在那个重边更新，所以是update(val,id[x],id[t1],1,totw,1);这样的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1void swap(int &amp;a,int &amp;b){ int temp = a; a = b; b = temp;}typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e4+10;int size[maxn],dep[maxn],top[maxn],fa[maxn],id[maxn],son[maxn];int head[maxn],w[maxn];int n,cnt,totw,m;struct edge{ int next,to;}G[maxn&lt;&lt;1];int find(int x){ return x==fa[x]?x:find(fa[x]);}void addedge(int u,int v){ G[cnt].next = head[u]; G[cnt].to = v; head[u] = cnt++;}void dfs1(int u,int f){ size[u] = 1; for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(v==f) continue; dep[v] = dep[u]+1; fa[v] = u; dfs1(v,u); if(size[v] &gt; size[son[u]]) son[u] = v; size[u]+=size[v]; }}void dfs2(int u,int topu){ top[u] = topu; id[u] = ++totw; if(son[u]) dfs2(son[u],top[u]); for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(v==fa[u] || v==son[u]) continue; dfs2(v,v); }}int data[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2];void pushdown(int rt){ if(lazy[rt]!=0){ data[rt&lt;&lt;1] += lazy[rt]; data[rt&lt;&lt;1|1] += lazy[rt]; lazy[rt&lt;&lt;1] += lazy[rt]; lazy[rt&lt;&lt;1|1] += lazy[rt]; lazy[rt] = 0; }}void build(int l,int r,int rt){ lazy[rt] = 0; if(l==r){ data[rt] = w[l]; return; } int mid = l+r&gt;&gt;1; build(lson); build(rson);}int query(int pos,int l,int r,int rt){ if(l==r &amp;&amp; l==pos) return data[rt]; int mid = l+r&gt;&gt;1; pushdown(rt); if(pos&lt;=mid) return query(pos,lson); else return query(pos,rson);}void update(int val,int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ lazy[rt] += val; data[rt] += val; return; } pushdown(rt); int mid = l+r&gt;&gt;1; if(L&lt;=mid) update(val,L,R,lson); if(mid&lt;R) update(val,L,R,rson);}void change(int u,int v,int val){ int t1=top[u],t2=top[v]; while(t1!=t2){ if(dep[t1]&lt;dep[t2]){ swap(t1,t2); swap(u,v); } update(val,id[t1],id[u],1,totw,1); u = fa[t1]; t1 = top[u]; } if(dep[u]&gt;dep[v]) swap(u,v); update(val,id[u],id[v],1,totw,1);}int val[maxn];int p;char op[20];void init(){ cnt = totw = 0; memset(head,-1,sizeof(head)); dep[1] = fa[1] = size[0] = 0; memset(son,0,sizeof(son));}int main(){#ifdef LOCAL freopen(&quot;4.in&quot;,&quot;r&quot;,stdin);#endif while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p)){ init(); rep(i,1,n+1) scanf(&quot;%d&quot;,val+i); rep(i,0,m){ int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v); addedge(v,u); } dfs1(1,0); dfs2(1,1); rep(i,1,n+1) w[id[i]] = val[i]; build(1,totw,1); while(p--){ scanf(&quot;%s&quot;,op); if(op[0]=='Q'){ int x;scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,query(id[x],1,totw,1)); }else{ int u,v,val;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;val); if(op[0]=='D') val = -val; change(u,v,val); } } } return 0;} 个人鄙见： 树链剖分就是将树一部分分成区间修改，一部分分成单点修改，但是单点修改的复杂度控制在了$O(logN)$。 Reference: https://blog.csdn.net/dyx404514/article/details/8718249","link":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2018/09/29/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"概率dp入门","text":"概率dp概率dp有两种题型，一种是求概率一种是求期望。 来结合一下题目 Aeroplane chess题意一个人在一条线上掷骰子，在线上有类似飞行棋的可以直接到达某个点的特殊点，问从$0$到$n$掷骰子次数的数学期望是多少？ 题解期望dp，dp最重要的就是从一个已知的最优状态转化到另一个最优状态。 为什么期望要反着求呢，因为你并不知道$dp[0]$这个点的值，因为我们定义$dp[x]$为$x$点到$n$点的掷骰子数的数学期望。而$dp[n]$的数学期望我们是知道的，是0，因为已经在$n$点了。之后我们倒推前面点的数学期望，因为你骰子是6面，从一个点可以到后面的六个点并且是等概率的，所以 $dp[i] = \\sum_{j=i+1}^{i+6}dp[j]/6+1$ 而且如果是特殊的飞行点，那么他的数学期望直接就是他的到的点的数学期望。 +2：没有从n-1开始，居然sb到从n开始计算。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define pb push_backtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,m;const int maxn = 1e5 + 10;double dp[maxn];int nxt[maxn];int main(){#ifdef LOCAL freopen(&quot;11.in&quot;,&quot;r&quot;,stdin);#endif while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) &amp;&amp; (m||n)){ rep(i,0,n+1) dp[i] = 0.0,nxt[i] = 0; rep(i,0,m){ int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); nxt[x] = y; } per(i,0,n){ if(nxt[i]){ dp[i] = dp[nxt[i]]; }else{ double sum = 0.0; rep(j,1,6+1){ if(i+j&lt;=n){ sum+=dp[i+j]; } } dp[i] = sum/6.0+1.0; } } printf(&quot;%0.4f\\n&quot;,dp[0]); } return 0;} B - Discovering Gold题意跟上面的差不多，就是求期望。 题解跟上面基本相似。 AC代码12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 110;int T,n;double dp[maxn];int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); rep(test_case,1,T+1){ scanf(&quot;%d&quot;,&amp;n); rep(i,1,n+1) cin&gt;&gt;dp[i]; per(i,1,n){ double sum = 0.0; double cnt = 0; rep(j,i+1,i+7){ if(j&lt;=n) sum+=dp[j],cnt++; } dp[i] += sum/cnt; } printf(&quot;Case %d: %0.9f\\n&quot;,test_case,dp[1]); } return 0;}","link":"/%E6%A6%82%E7%8E%87dp/2018/09/10/%E6%A6%82%E7%8E%87dp%E5%85%A5%E9%97%A8.html"},{"title":"求逆元和组合数模板","text":"求逆元$O(n)$求逆元1234ll inv[maxn];inv[1] = 1;rep(i,2,maxn) inv[i] = inv[mod%i] * (mod-mod/i) % mod; $O(n)$求阶乘1234ll f[maxn];ll f[1] = 1;rep(i,2,maxn) f[i] = f[i-1]*i; 求$n\\choose k$123456789101112131415161718ll cur,p[maxn],q[maxn],inv[maxn];ll C(ll n,ll k){ return p[n]*q[k]%mod*q[n-k]%mod;}ll c(ll n,ll k){ if(n&lt;maxn) return C(n,k); if(!k) return 1; return cur = cur*inv[k]%mod*((n-k+1)%mod)%mod;}void init(){ p[0]=p[1]=q[0]=q[1]=inv[0]=inv[1]=1; for(ll i = 2;i&lt;maxn;i++){ inv[i] = (mod-mod/i)*inv[mod%i]%mod; q[i] = q[i-1] * inv[i] % mod; p[i] = p[i-1] * i % mod; }}//在每次的时候就得cur初始化为1 求$A^k_n$123int A(int n,int k){ return c(n,k)*p[k]%mod;}","link":"/acm%E6%A8%A1%E6%9D%BF/2018/08/24/%E6%B1%82%E9%80%86%E5%85%83%E5%92%8C%E7%BB%84%E5%90%88%E6%95%B0%E6%A8%A1%E6%9D%BF.html"},{"title":"第十届蓝桥杯题解","text":"第十届蓝桥杯题解(个人向)第一题 平方和算$1 ​$到$2019​$中含有$2,0,1,9​$的数的平方和。 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headbool check(int x){ while(x){ int t = x % 10; x /= 10; if(t == 1 || t == 0 || t == 9 || t == 2) return true; } return false;}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif ll ans = 0; rep(i,1,2019+1){ if(check(i)) ans += 1ll * i*i; } printf(&quot;%lld\\n&quot;,ans); return 0;} 第二题 数列求值求类似斐波那契数列$f[i] = f[i-1] + f[i-2] + f[i-3]$ ，求$f[20190324]%10000$。 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint a[10];const int mod = 1e4;int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif a[0] = 1; a[1] = 1; a[2] = 1; rep(i,3,20190324){ a[3] = (a[0] + a[1] + a[2]) % mod; rep(j,0,3) a[j] = a[j+1]; } printf(&quot;%d\\n&quot;,a[2]); return 0;} 第三题 最大降雨量答案34.贪心即可。注意中位数的中位数 第四题 迷宫第九题 糖果题意有n袋糖，里面有m种糖，每袋糖有k个，问至少取几包才能攒够所有种类的糖。 $n \\leq 100;m,k\\leq 20​$ 题解状压dp。我场上直接上暴力了。但是场下经过队友提示，发现就是个简单的状压dp。 因为他的$m$低于20所以我们可以用二进制位来表示。总的复杂度$O(2^m *n)$ 状态转移方程 $dp[S|i] = min(dp[S|i],dp[i]+1)$ 可能ac的代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,m,k;const int maxm = 21;const int maxn = 110;int dp[1&lt;&lt;maxm];int sta[maxn];int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); rep(i,0,n){ rep(j,0,k){ int x; scanf(&quot;%d&quot;,&amp;x); dp[i] |= (1&lt;&lt;(x-1)); } } rep(i,0,(1&lt;&lt;m)) dp[i] = INF; dp[0] = 0; for(int i = 0;i&lt;(1&lt;&lt;m);i++){ rep(j,0,n){ dp[i|sta[j]] = min(dp[i]+1,dp[i|sta[j]]); } } printf(&quot;%d\\n&quot;,dp[(1&lt;&lt;m)-1]!=INF?dp[(1&lt;&lt;m)-1]:-1); return 0;}","link":"/%E8%93%9D%E6%A1%A5%E6%9D%AF/2019/03/29/%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E8%A7%A3.html"},{"title":"考研随想","text":"考研感想感触现在是12月25号，考完研的第三天。在今天之前的前一个星期里，我每天都是7点左右自然醒。而终于在今天，我睡到了九点，但依然没有睡饱。我想考研带给我了很多，不只是那摞起来像山一样高的辅导书，还有一些随之带来的习惯的改变。 考研开始高考之后最开始听说考研应该是高考出成绩之后吧。那个时候因为考的太差，是真的对自己的人生失去了信心。之后听说到了大学以后，还可以靠着考研”翻身“（哪有什么翻身）。之后就下定决心，在大学期间冲冲冲，以考研考上浙大为目标。 得知专业之后高考分数出来之后，还要进行选学校和选专业，但是因为分是在是太低了。只能随便选选了。最后来到njtech的这个环境科学专业。本着干一行爱一行的心态，我在网上搜索了很多关于环境科学的信息。但是越搜索我的心是越来越拔凉拔凉的。作为环化生材四大坑之首，环境绝对算得上是以先辈们的血一般地事实展示了环境专业的不受待见。之后，在知乎的熏染之下，我选择了转专业！ 大一大一的过程可以总结为：守望先锋+刷绩点。除此之外，啥活动都没有参加。 转专业以后终于在大一下的时候，以环境科学专业第一的成绩转入了计算机科学与技术学院。并且加入了在大一的时候就听说过的acm比赛。但是投身于acm比赛的过程中，我也忘记了我进入大学的初始动机—-考研浙大。 acm区域赛3铜可能因为暑假的半学半玩，也可能是因为自己的水品不行智商不够。我们队在2018年的下半年，去了三场区域赛（包括一场EC-Final）全部都拿了铜奖。还记得第一个铜的时候，心里是低落的。但是在听说有学长保研南大，有数理学院的学长保研的浙大计算机直博，并且在网上看了一下，保研中打acm的还算是少数，我保研的心情又高涨了起来。 2019年4月份4，5月份是acm邀请赛开始的时候，但也是保研申请学校夏令营的高峰期，这时候不管是哪里的学生，都在疯狂地给老师发邮件，咨询保研的事项。但是我由于acm还要打个邀请赛，精力确实也分了一些。结果就上了个上科大和浙软的夏令营。（其实还是因为acm牌子不够响，也没有啥子科研经历） 暑假暑假的时候，去了浙软的夏令营，并且考研数学过了高数，英语单词也背了不少。结果夏令营当场没给我优秀营员，但是在后面的优秀营员名单中是有我的。不过我们学院保研要求的是对方学校的确保接受证明，这tm谁有啊。只能灰溜溜地准备去考研了。 8月此时正是考研的冲刺期，但是我考浙大计科，怕是去送命了，（浙大计科408考4门专业课，就算是再扎实的基础，也要个长时间的准备，而且我的数学一直属于刷个绩点的水品，并不能应付考研这个高强度考试。）所以根据我看到的浙软合作企业的项目，我决定tm考浙软，软件就软件，起码也是个浙大。 8-12月冲冲冲！疯狂复习，虽然有时候也松懈个1天，但是这四个月我的考研复习效率还是可以的。养成了一些学习的习惯，比如写感想，摘录错题。 考研中转眼之间就到了考研的时间了，12月21日-22日。 酒店中凌乱虽然我的考点离学校蛮近的，但是我还是选择了订了个酒店，既可以中午的时候躺一会儿，也可以防止意外。所以我在周四的晚上，还去试睡了一下。结果就tm出现意外了。 论酒店隔音不好+旁边是一对激情似火的情侣的住房体验 所以我毅然决然地选择周五这个最重要的睡觉时间在宿舍里睡。 周五宿舍中辗转难眠，因为周六考的是政治和英语，所以有大量的需要背诵的内容。我选择了在10.30睡觉，之后早上6.20左右爬起来再过一遍。","link":"/%E8%80%83%E7%A0%94/2019/12/25/%E8%80%83%E7%A0%94%E9%9A%8F%E6%83%B3.html"},{"title":"蓝桥杯历届题目","text":"还有6天蓝桥杯了开始刷历届练习题了。 小计算器题意实现一个直接的计算器。没有四则运算规则优先级。并且能够有进制转换 题解数字转换字符串的时候,$0$是关键点。 ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;typedef long long ull;const int INF = 0x3f3f3f3f;//headint n;const int maxchar = 100;const int maxn = 100;char s[maxn];int k;char ans[maxn];void solve(ull x){ memset(ans,0,sizeof(ans)); ull t = k; int cnt = 0; if(x==0) ans[0] = '0'; while(x){ if(x%t &lt; 10){ ans[cnt++] = x%t+'0'; }else{ ans[cnt++] = x%t+'A'-10; } x/=t; } int len = strlen(ans); rep(i,0,len/2) swap(ans[i],ans[len-1-i]);}char tt[maxn];ull real_num(){ int len = strlen(tt); ull t = 0; ull cnt = 1; per(i,0,len){ if(tt[i]&gt;='A' &amp;&amp; tt[i]&lt;='Z'){ t += cnt * (tt[i] - 'A' +10); }else{ t += cnt * (tt[i] - '0'); } cnt*= k; } return t;}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif cin&gt;&gt;n; ull now = 0; int sign = 0; k = 10; bool init = false; rep(i,0,n){ cin&gt;&gt;s; if(s[0] == 'C' &amp;&amp; s[1] == 'L') { now = 0; init = true; }else if(s[0] == 'N'){ cin&gt;&gt;tt; ull temp = real_num(); if(init){ now = temp; init = false; continue; } if(sign == 1) now += temp; else if(sign == 2) now -= temp; else if(sign == 3) now *= temp; else if(sign == 4) now /= temp; else now %= temp; }else if(s[0] == 'A'){ sign = 1; }else if(s[0] == 'S'){ sign = 2; }else if(s[0] == 'M' &amp;&amp; s[1] == 'U'){ sign = 3; }else if(s[0] == 'D'){ sign = 4; }else if(s[0] == 'M'){ sign = 5; }else if(s[0] == 'E'){ solve(now); cout&lt;&lt;ans&lt;&lt;'\\n'; }else{ cin&gt;&gt;k; } } return 0;} 合根植物题意并查集 数组开小了。 ac代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 2e3+10;int fa[maxn*maxn];int Find(int x){ if(fa[x] == x) return x; else return fa[x] = Find(fa[x]);}int Union(int x,int y){ int i = Find(x);int j = Find(y); if(i!=j) fa[j] = i;}int n,m;int k;int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); rep(i,1,n*m+1) fa[i] = i; rep(i,0,k){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); Union(x,y); } int ans = 0; rep(i,1,n*m+1) if(fa[i] == i) ans++; printf(&quot;%d\\n&quot;,ans); return 0;}","link":"/%E8%93%9D%E6%A1%A5%E6%9D%AF/2019/03/18/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8E%86%E5%B1%8A%E9%A2%98%E7%9B%AE.html"},{"title":"逆元模板","text":"求逆元模板递推求逆元12345int inv[maxn];int inv[1] = 1;rep(i,2,max){ inv[i] = inv[mod%i]*(mod-mod/i)%mod;} 费马小定理求逆元12345678910111213141516ll extend_gcd(ll a,ll b,ll x,ll y){ if(a==0 &amp;&amp; b==0) return -1; if(b==0) { x = 1;y = 0; return a; } ll d = extend_gcd(b,a%b,y,x); y -= a/b*x; return d;}ll mod_reverse(ll a,ll n){ ll x,y; ll d = extend_gcd(a,n,x,y); if(d==1) return (x%n+n)%n; else return -1;}","link":"/acm%E6%A8%A1%E6%9D%BF/2018/08/19/%E9%80%86%E5%85%83%E6%A8%A1%E6%9D%BF.html"},{"title":"jsp第七次作业","text":"jsp大作业作业要求 mysql + CRUD 校验器 Struts2+Hibernate 框架 css美化 文件结构![image-20181128192100403](/Users/cheasim/Library/Application Support/typora-user-images/image-20181128192100403.png) 运行截图登陆界面![image-20181128192157690](/Users/cheasim/Library/Application Support/typora-user-images/image-20181128192157690.png) 选择操作界面![image-20181128192234733](/Users/cheasim/Library/Application Support/typora-user-images/image-20181128192234733.png) 增加和修改界面使用了js语言，实现了一个form中有两个按钮，指向不同的action ![image-20181128192321558](/Users/cheasim/Library/Application Support/typora-user-images/image-20181128192321558.png) 校验器应用对加入学生信息进行校验。 ID必须为0或者不为0开头的数字。 name和address不能为空。 ![image-20181128192708351](/Users/cheasim/Library/Application Support/typora-user-images/image-20181128192708351.png) 成功添加后自动转到学生列表(改变也是一样)![image-20181128192747889](/Users/cheasim/Library/Application Support/typora-user-images/image-20181128192747889.png) 查询和删除因为用户可能不确定要删除哪一个，所以删除的旁边还有一个查询按钮。根据ID来进行查询。 ![image-20181128192905933](/Users/cheasim/Library/Application Support/typora-user-images/image-20181128192905933.png) ![image-20181128192914679](/Users/cheasim/Library/Application Support/typora-user-images/image-20181128192914679.png) 代码接口代码![image-20181128193135141](/Users/cheasim/Library/Application Support/typora-user-images/image-20181128193135141.png) 1234567891011package njtech.edu.DAO;import java.util.List;import org.hibernate.Session;public interface BaseDAO { public Session getSession(); public void closeSession(); public List search(String hql);} 1234567891011121314package njtech.edu.DAO;import java.util.List;import njtech.edu.model.Student;public interface StudentDAO { void saveStudent(Student student); List&lt;Student&gt; getAll(); void changeStudent(Student student); void deleteStudent(Student student); List&lt;Student&gt; queryStudent(Student student);} 1234567891011package njtech.edu.DAO;import njtech.edu.model.User;import java.util.List;public interface UserDAO { User queryUser(String username);} 实现类代码![image-20181128193145593](/Users/cheasim/Library/Application Support/typora-user-images/image-20181128193145593.png) 12345678910111213141516171819202122232425262728293031323334353637383940package njtech.edu.DAO.impl;import java.util.List;import com.googlecode.s2hibernate.struts2.plugin.util.HibernateSessionFactory;import njtech.edu.DAO.BaseDAO;import njtech.edu.DAO.StudentDAO;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;public class BaseDAOImpl implements BaseDAO { private SessionFactory sessionFactory; private Session session; private Transaction tx; public void init(){ session = HibernateSessionFactory.getSession(); tx = session.beginTransaction(); } @Override public Session getSession() { init(); return session; } @Override public void closeSession() { session.close(); } @Override public List search(String hql) { Session session = null; session = getSession(); List alist = null; alist = session.createQuery(hql).list(); session.close(); return alist; }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package njtech.edu.DAO.impl;import njtech.edu.model.Student;import njtech.edu.DAO.StudentDAO;import org.hibernate.*;import org.hibernate.cfg.Configuration;import org.hibernate.criterion.Restrictions;import java.util.List;public class StudentDAOImpl extends BaseDAOImpl implements StudentDAO{ SessionFactory sessionFactory = null; Session session = null; Transaction tx = null; public StudentDAOImpl(){} public void init() { sessionFactory = new Configuration(). configure(&quot;hibernate.cfg.xml&quot;). buildSessionFactory(); session = sessionFactory.openSession(); tx = session.beginTransaction(); } @Override public void saveStudent(Student student) { init(); session.save(student); String sql = &quot;insert into student (id,name,address) values('&quot; + Integer.toString(student.getId()) +&quot;.'&quot;+ student.getName()+&quot;','&quot;+ student.getAddress()+&quot;')&quot; ; tx.commit(); session.close(); } @Override public List&lt;Student&gt; getAll() { init(); List&lt;Student&gt; students = session.createQuery(&quot;from Student&quot;).list(); //List&lt;Student&gt; students = (Student) session.createQuery(&quot;from Student &quot;); return students; } @Override public void changeStudent(Student student){ init(); Student student1 = (Student) session.get(Student.class, new Integer(student.getId())); // hql 查询 //Student student2 = (Student) session.createQuery(&quot;from Student where id=&quot;+student.getId()); // sql 查询 //Query query = session.createSQLQuery(&quot;select * from student where id=&quot;+student.getId()).addEntity(Student.class); //Student student3 = (Student) query.list(); student1.setName(student.getName()); student1.setAddress(student.getAddress()); session.update(student1); tx.commit(); session.close(); } @Override public void deleteStudent(Student student){ init(); Student student1 = (Student) session.get(Student.class, student.getId()); // hql查询 //Student student2 = (Student) session.createQuery(&quot;from Student where id=&quot;+student.getId()); // sql 查询 //Query query = session.createSQLQuery(&quot;select * from student where id=&quot;+student.getId()).addEntity(Student.class); //Student student3 = (Student) query.list(); if(student != null){ session.delete(student1); } tx.commit(); session.close(); } @Override public List&lt;Student&gt; queryStudent(Student student){ init(); Criteria criteria = session.createCriteria(Student.class).add(Restrictions.like(&quot;id&quot;,student.getId())); //hql 查询 Query query = session.createQuery(&quot;from Student where id=&quot;+student.getId()); // sql 查询 //Query query = session.createSQLQuery(&quot;select * from student where id=&quot;+student.getId()).addEntity(Student.class); //List&lt;Student&gt; students2 = query.list(); List&lt;Student&gt; students = criteria.list(); //return students2; return students; }} 1234567891011121314151617181920212223242526272829303132333435package njtech.edu.DAO.impl;import njtech.edu.DAO.UserDAO;import njtech.edu.model.Student;import njtech.edu.model.User;import org.hibernate.*;import org.hibernate.cfg.Configuration;import org.hibernate.criterion.Restrictions;import java.util.List;public class UserDAOImpl extends BaseDAOImpl implements UserDAO { SessionFactory sessionFactory = null; Session session = null; Transaction tx = null; public UserDAOImpl(){} public void init() { sessionFactory = new Configuration(). configure(&quot;hibernate.cfg.xml&quot;). buildSessionFactory(); session = sessionFactory.openSession(); tx = session.beginTransaction(); } @Override public User queryUser(String username) { init(); Criteria criteria = session.createCriteria(User.class).add(Restrictions.like(&quot;username&quot;,username)); User user = (User)criteria.uniqueResult(); return user; }} action类代码![image-20181128193156432](/Users/cheasim/Library/Application Support/typora-user-images/image-20181128193156432.png) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package njtech.edu.Action;import java.util.ArrayList;import java.util.List;import java.util.regex.Pattern;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;import njtech.edu.DAO.StudentDAO;import njtech.edu.DAO.impl.StudentDAOImpl;import njtech.edu.model.Student;public class StudentAction extends ActionSupport implements ModelDriven { private Student student; private List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(); private StudentDAO dao = new StudentDAOImpl(); public Object getModel() { return student; } public String saveStudent() { dao.saveStudent(student); return &quot;success&quot;; } public String listStudents() { students = dao.getAll(); return &quot;success&quot;; } public String queryStudents(){ students = dao.queryStudent(student); return &quot;success&quot;; } public String changeStudent() { dao.changeStudent(student); return &quot;success&quot;; } public String deleteStudent(){ dao.deleteStudent(student); return &quot;success&quot;; } public void validate(){ System.out.println(&quot;校验器!&quot;); } public void validateSaveStudent(){ if(student != null){ Integer ID = student.getId(); String IID = ID.toString(); if(&quot;&quot;.equals(this.student.getName().trim())){ this.addFieldError(&quot;username&quot;, &quot;用户名不能为空&quot;); } if(&quot;&quot;.equals(this.student.getAddress().trim())){ this.addFieldError(&quot;address&quot;, &quot;地址不能为空&quot;); } if(!Pattern.compile(&quot;^(0|[1-9][0-9]*)$&quot;).matcher(IID).matches()){ this.addFieldError(&quot;id&quot;, &quot;ID格式不正确&quot;); } } super.validate(); } public Student getStudent() { return student; } public void setStudent(Student student) { this.student = student; } public List&lt;Student&gt; getStudents() { return students; } public void setStudents(List&lt;Student&gt; students) { this.students = students; }} 12345678910111213141516171819202122232425262728293031package njtech.edu.Action;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;import njtech.edu.DAO.impl.UserDAOImpl;import njtech.edu.model.User;public class UserLoginAction extends ActionSupport { private User user; private UserDAOImpl dao= new UserDAOImpl(); public String userLogin(){ User tempuser = dao.queryUser(user.getUsername()); if(tempuser.equals(user)){ return &quot;success&quot;; }else{ return &quot;error&quot;; } } public User getUser() { return user; } public void setUser(User user) { this.user = user; }} Hibernate配置文件cfg.xml12345678910111213141516171819&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/test?useSSL=false&lt;/property&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;connection.password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;mapping class=&quot;njtech.edu.model.Student&quot;/&gt; &lt;mapping resource=&quot;njtech/edu/model/Student.hbm.xml&quot;/&gt; &lt;mapping resource=&quot;njtech/edu/model/User.hbm.xml&quot;/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; hbm user和student123456789101112131415161718&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;class name=&quot;njtech.edu.model.Student&quot; table=&quot;student&quot; schema=&quot;test&quot;&gt; &lt;id name=&quot;id&quot;&gt; &lt;column name=&quot;id&quot; sql-type=&quot;int(11)&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;name&quot;&gt; &lt;column name=&quot;name&quot; sql-type=&quot;varchar(100)&quot; length=&quot;100&quot; not-null=&quot;true&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;address&quot;&gt; &lt;column name=&quot;address&quot; sql-type=&quot;varchar(100)&quot; length=&quot;100&quot; not-null=&quot;true&quot;/&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 123456789101112131415&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;class name=&quot;njtech.edu.model.User&quot; table=&quot;user&quot; schema=&quot;test&quot;&gt; &lt;id name=&quot;username&quot;&gt; &lt;column name=&quot;username&quot; sql-type=&quot;varchar(20)&quot; length=&quot;20&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;password&quot;&gt; &lt;column name=&quot;password&quot; sql-type=&quot;varchar(20)&quot; length=&quot;20&quot;/&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; model类 Student User12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package njtech.edu.model;import javax.persistence.*;import java.util.Objects;public class Student { private int id; private String name; private String address; public Student(){} public Student(int id, String name, String address){ this.id = id; this.name = name; this.address = address; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student that = (Student) o; return id == that.id &amp;&amp; Objects.equals(name, that.name) &amp;&amp; Objects.equals(address, that.address); } @Override public int hashCode() { return Objects.hash(id, name, address); }} 123456789101112131415161718192021222324252627282930313233343536373839package njtech.edu.model;import java.util.Objects;public class User { private String username; private String password; public User(){} public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; return Objects.equals(username, user.username) &amp;&amp; Objects.equals(password, user.password); } @Override public int hashCode() { return Objects.hash(username, password); }} Struts2配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;package name=&quot;default&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;addStudent&quot; method=&quot;saveStudent&quot; class=&quot;njtech.edu.Action.StudentAction&quot;&gt; &lt;result name=&quot;success&quot; type=&quot;redirect&quot;&gt; listStudents.action &lt;/result&gt; &lt;result name=&quot;input&quot;&gt;add.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=&quot;changeStudent&quot; method=&quot;changeStudent&quot; class=&quot;njtech.edu.Action.StudentAction&quot;&gt; &lt;result name=&quot;success&quot; type=&quot;redirect&quot;&gt; listStudents.action &lt;/result&gt; &lt;/action&gt; &lt;action name=&quot;listStudents&quot; method=&quot;listStudents&quot; class=&quot;njtech.edu.Action.StudentAction&quot;&gt; &lt;result name=&quot;success&quot;&gt; index.jsp &lt;/result&gt; &lt;/action&gt; &lt;action name=&quot;queryStudents&quot; method=&quot;queryStudents&quot; class=&quot;njtech.edu.Action.StudentAction&quot;&gt; &lt;result name=&quot;success&quot; &gt; queryStudent.jsp &lt;/result&gt; &lt;/action&gt; &lt;action name=&quot;deleteStudent&quot; method=&quot;deleteStudent&quot; class=&quot;njtech.edu.Action.StudentAction&quot;&gt; &lt;result name=&quot;success&quot;&gt; success.jsp &lt;/result&gt; &lt;/action&gt; &lt;action name=&quot;userLogin&quot; method=&quot;userLogin&quot; class=&quot;njtech.edu.Action.UserLoginAction&quot;&gt; &lt;result name=&quot;success&quot;&gt; index.jsp&lt;/result&gt; &lt;result name=&quot;error&quot;&gt;login.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 前端代码css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192body{ background: url(&quot;../image/2.jpg&quot;) no-repeat; background-size:100%; background-attachment: fixed;}form{ display:inline-block; margin-top:100px;}h1{ color: #ffb11c; text-align:center;}p{ font-family:&quot;Times New Roman&quot;; font-size:20px;}table{ border-collapse:collapse;}table,th, td{ border: 0px solid black; border-bottom-color: aqua;}form{ background:rgba(255,255,255,0.3); border: 1px solid rgba(0,0,0, 0.2); font-family:&quot;Monaco&quot;; font-size: 40px; border-radius: 30px;}.input_control{ width:360px; margin:14px auto;}.error_message{ color: #ff383f; font-size: 20px;}input[type=&quot;text&quot;]{ box-sizing: border-box; text-align:center; font-size:1.0em; height:2.0em; border-radius:20px; border:1px solid #c8cccf; color:#6a6f77; -web-kit-appearance:none; -moz-appearance: none; display:block; outline:0; padding:0 1em; text-decoration:none; width:100%;}input[type=&quot;password&quot;]{ box-sizing: border-box; text-align:center; font-size:1.0em; height:2.0em; border-radius:20px; border:1px solid #c8cccf; color:#6a6f77; -web-kit-appearance:none; -moz-appearance: none; display:block; outline:0; padding:0 1em; text-decoration:none; width:100%;}input[type=&quot;text&quot;]:focus{ border:1px solid #ff7496;}.button{ background-color: #af8c99; /* Green */ border: none; color: white; padding: 17px 28px; text-align: center; text-decoration: none; display: inline-block; font-size: 14px; border-radius:4px;} JSP第一个页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;%-- Created by IntelliJ IDEA. User: cheasim Date: 2018/11/11 Time: 11:57 AM To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登陆界面&lt;/title&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;css/mystyle.css&quot;/&gt; &lt;style&gt; &lt;!-- form{ height:350px; width:400px; border:1px solid #666666;} --&gt; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; function login(){ document.myform.action='http://localhost:8080/userLogin.action'; document.myform.submit(); } &lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .button{ background-color: #af8c99; /* Green */ border: none; color: white; padding: 14px 28px; text-align: center; text-decoration: none; display: inline-block; font-size: 20px; border-radius:13px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt; 管理员登陆界面&lt;/h1&gt;&lt;form action=&quot;userLogin&quot; name=&quot;myform&quot;&gt; &lt;s:textfield name=&quot;user.username&quot; label=&quot;用户名&quot;/&gt; &lt;s:textfield name=&quot;user.password&quot; label=&quot;密码&quot; type=&quot;password&quot;/&gt; &lt;input type=&quot;button&quot; class=&quot;button&quot; value=&quot;登陆&quot; onclick=&quot;login();&quot; align=&quot;right&quot;/&gt;&lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 选择页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;学生登录系统&lt;/title&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;css/mystyle.css&quot; /&gt; &lt;style type=&quot;text/css&quot;&gt; .button{ background-color: #af8c99; /* Green */ border: none; color: white; padding: 15px 30px; text-align: center; text-decoration: none; display: inline-block; font-size: 24px; border-radius:13px; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; function goAdd(){ document.myform.action='add.jsp'; document.myform.submit(); } function goDelete(){ document.myform.action='queryStudent.jsp'; document.myform.submit(); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;学生系统学生一览&lt;/h1&gt; &lt;form name=&quot;myform&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;input type=&quot;button&quot; class=&quot;button&quot; value=&quot;增加和修改&quot; onclick=&quot;goAdd();&quot;/&gt; &lt;/tr&gt; &lt;tr&gt; &lt;input type=&quot;button&quot; class=&quot;button&quot; value=&quot;删除和查询&quot; onclick=&quot;goDelete();&quot;/&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;s:if test=&quot;students.size() &gt; 0&quot;&gt; &lt;table border=&quot;1px&quot; cellpadding=&quot;8px&quot; bgcolor=#faebd7 style=&quot;filter:alpha(opacity=50);&quot;&gt; &lt;tr&gt; &lt;th&gt;Student Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Address&lt;/th&gt; &lt;/tr&gt; &lt;s:iterator value=&quot;students&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;s:property value=&quot;id&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=&quot;name&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=&quot;address&quot; /&gt;&lt;/td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/s:if&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 增加和修改 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;%-- Created by IntelliJ IDEA. User: cheasim Date: 2018/11/28 Time: 3:39 PM To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;增加学生&lt;/title&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;css/mystyle.css&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; function changeStudent(){ document.myform.action='http://localhost:8080/changeStudent.action'; document.myform.submit(); } function saveStudent(){ document.myform.action='http://localhost:8080/addStudent.action'; document.myform.submit(); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;form action=&quot;addStudent&quot; name=&quot;myform&quot;&gt; &lt;h4&gt; 加入学生信息&lt;/h4&gt; &lt;s:textfield name=&quot;student.id&quot; label=&quot;ID&quot;/&gt; &lt;s:fielderror fieldName=&quot;id&quot; cssClass=&quot;error_message&quot;/&gt; &lt;s:textfield name=&quot;student.name&quot; label=&quot;Name&quot;/&gt; &lt;s:fielderror fieldName=&quot;username&quot; cssClass=&quot;error_message&quot;/&gt; &lt;s:textfield name=&quot;student.address&quot; label=&quot;Address&quot;/&gt; &lt;s:fielderror fieldName=&quot;address&quot; cssClass=&quot;error_message&quot;/&gt; &lt;input type=&quot;button&quot; class=&quot;button&quot; value=&quot;改变&quot; onclick=&quot;changeStudent();&quot;/&gt; &lt;input type=&quot;button&quot; class=&quot;button&quot; value=&quot;增加&quot; onclick=&quot;saveStudent();&quot;/&gt; &lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 查询和删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;%-- Created by IntelliJ IDEA. User: cheasim Date: 2018/11/14 Time: 2:43 PM To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;查询结果&lt;/title&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;css/mystyle.css&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; function deleteStudent(){ document.myform1.action='http://localhost:8080/deleteStudent.action'; document.myform1.submit(); } function queryStudent(){ document.myform1.action='http://localhost:8080/queryStudents.action'; document.myform1.submit(); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;form action=&quot;queryStudents&quot; name=&quot;myform1&quot;&gt; &lt;h4&gt; 查询学生信息 依据id搜索或者删除&lt;/h4&gt; &lt;s:textfield name=&quot;student.id&quot; label=&quot;ID&quot;/&gt; &lt;input type=&quot;button&quot; class=&quot;button&quot;value=&quot;删除&quot; onclick=&quot;deleteStudent();&quot;/&gt; &lt;input type=&quot;button&quot;class=&quot;button&quot; value=&quot;查询&quot; onclick=&quot;queryStudent();&quot;/&gt; &lt;/form&gt;&lt;h1&gt;学生查询结果&lt;/h1&gt;&lt;s:if test=&quot;students.size() &gt; 0&quot;&gt; &lt;table border=&quot;1px&quot; cellpadding=&quot;8px&quot; bgcolor=#faebd7 style=&quot;filter:alpha(opacity=50);&quot;&gt; &lt;tr&gt; &lt;th&gt;Student Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Address&lt;/th&gt; &lt;/tr&gt; &lt;s:iterator value=&quot;students&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;s:property value=&quot;id&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=&quot;name&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=&quot;address&quot; /&gt;&lt;/td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/s:if&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;","link":"/uncategorized/2018/11/28/jsp%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%BD%9C%E4%B8%9A.html"},{"title":"[nowcoder2] 补题向","text":"A.run题意白云可以跑$k$米或者走$1$米，但不能连续跑，问到达终点有多少种方案。 题解1步2步上楼梯的加强版。典型的dp题。 $dp[i][0/1]$表示第$i$米最终是走还是跑的方案数 转移方程 $dp[i][0] = dp[i-1][1]+dp[i-1][0]$ $dp[i][1] = dp[i-1][0]$ AC代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5 + 10;const ll mod = 1e9 + 7;ll dp[maxn][2];ll pre[maxn];int q;ll k;int main(){#ifdef LOCAL freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%lld&quot;,&amp;q,&amp;k); dp[0][0] = 1; rep(i,1,maxn){ if(i&gt;=k){ dp[i][1] = dp[i-k][0] % mod; } dp[i][0] = (dp[i-1][0] + dp[i-1][1]) % mod; pre[i] = pre[i-1] + (dp[i][0] + dp[i][1]) % mod; pre[i] %= mod; } rep(i,0,q){ int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%lld\\n&quot;,(pre[r]-pre[l-1]+mod)%mod); } return 0;} D.Money题意白云可以在一个商店里卖或者买商品，但白云只能带一个商品。问最多能赚多少钱在最少的交易下。 题解dp $dp[i][0]$表示在$i$最后一次交易是买入的最优值，$dp[i][1]$表示在$i$最后一次交易是卖出的最优值。转移方程。 在$[1,i-1]$中卖出的最优值后在$i$买入或者不买入中取最好值。$dp[i][0]=max(dp[i-1][0],dp[i-1][1]-a[i])$ 在$[1,i-1]$买入的最优值后在$i$卖出或者不卖中取最大值。$dp[i][1] = max(dp[i-1][1],dp[i-1][1]+a[i])$ 只有由于要求最小交易次数，用pair&lt;ll,int&gt;来表示，第一个是金钱，第二个是交易次数，求最小次数，所以用min,并且把金钱变成负值，就可以相当于反向取最大了。 AC代码copydls的123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5 + 10;ll a[maxn];int T,n;pair&lt;ll,int&gt; dp[maxn][2];ll inf = 1ll&lt;&lt;60;int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d&quot;,&amp;n); rep(i,1,n+1) scanf(&quot;%lld&quot;,a+i); dp[0][0] = make_pair(0,0); dp[0][1] = make_pair(inf,0); rep(i,1,n+1){ dp[i][0] = min(dp[i-1][0],make_pair(dp[i-1][1].fi-a[i],dp[i-1][1].se+1)); dp[i][1] = min(dp[i-1][1],make_pair(dp[i-1][0].fi+a[i],dp[i-1][0].se+1)); } printf(&quot;%lld %d\\n&quot;,-dp[n][0].fi,dp[n][0].se); } return 0;} 贪心做法123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5 + 10;vector&lt;ll&gt; a;ll inf = 1ll&lt;&lt;50;int n;int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif int T; scanf(&quot;%d&quot;,&amp;T); while(T--){ a.clear(); scanf(&quot;%d&quot;,&amp;n); a.push_back(inf); rep(i,1,n+1){ ll x; scanf(&quot;%lld&quot;,&amp;x); a.push_back(x); } a.push_back(-1); a.erase(unique(a.begin(),a.end()),a.end()); int len = a.size(); int down = -1;int cnt = 0;ll ans = 0; rep(i,1,len-1){ if(a[i] &lt;a[i-1] &amp;&amp; a[i]&lt;a[i+1]){ down = i; } if(a[i]&gt;a[i+1]&amp;&amp;a[i]&gt;a[i-1]){ cnt+=2; ans += a[i]-a[down]; } } printf(&quot;%lld %d\\n&quot;,ans,cnt); } return 0;} G transform题意白云要把一个数轴上的箱子中的产品搬到一个箱子点上，每个箱子都有一个价值，每次搬一个产品从箱子$a$到$b$上都要花费$2*abs(x[a]-x[b])$的力气，问在$T$总力气下，可以获得多少价值。 题解二分+前缀数组 首先我们可以确定放箱子肯定是选择一定的区间内，因为每搬一个产品，肯定是越近消耗得越好，区间中只有左端点和右端点可能没搬完。 区间中，把所有产品集中到产品中位数，即改点左边的产品和右边的产品数量接近一致。便体力消耗最小。 难点 对于前缀数组的处理，我们用$suma$表示前缀产品和，$sumt$表示前缀对于假设运送产品到0点的和。$sumt[r]-sumt[l-1]$表示$[l,r]$移动到0点所需要的力气。 那么如果我们将产品$[l,r]$运送到点$l$的消耗相当于把$[l,r]$中的元素都先运送到$l$中之后再把$l$中的元素送到0，进行减一哈，就是答案。$ans = sumt[r]-sumt[l-1]-(suma[r]-suma[l-1])*x[l]$ 将产品$[l,r]$运送到$r$点，相当于我们先把$[l,r]$转移到$r$上面之后再统一移动到0点。$ans+sumt[r]-sumr[l-1]=(suma[r]-suma[l-1])*x[r]$。 之后枚举每个$l$的每个$r$和每个$r$的每个$l$，枚举的时候固定$l$或者$r$是消耗完全的。 二分又一个小套路。 1234567891011int l,r,mid,ans;l = 1,r = maxn;while(l&lt;=r){ mid = (l+r)&gt;&gt;1; if(check()){ ans = mid;l=mid+1; //避免了重复枚举Mid嘞。 }else{ r = mid-1; }}printf(&quot;%d\\n&quot;,ans); AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e5 + 10;ll n,T;ll x[maxn],a[maxn],suma[maxn],sumt[maxn];ll getl(ll l,ll r){ return (sumt[r]-sumt[l-1]) - (suma[r]-suma[l-1])*x[l];}ll getr(ll l,ll r){ return (suma[r]-suma[l-1])*x[r] - (sumt[r]-sumt[l-1]);}bool check(ll ans){ ll l,r,mid,mida; mida = ans/2+1; l = r = mid = 1; while(1){ while(r&lt;=n &amp;&amp; suma[r]-suma[l-1]&lt;ans) r++; while(mid&lt;r &amp;&amp; suma[mid]-suma[l-1]&lt;mida) mid++; if(r&gt;n || mid&gt;r) break; ll temp = suma[r]-suma[l-1]-ans; if(getr(l,mid)+getl(mid,r)-temp*(x[r]-x[mid]) &lt;= T) return true; l++; } l = r = mid = n; while(1){ while(l&gt;=1 &amp;&amp; suma[r]-suma[l-1]&lt;ans) l--; while(mid&gt;l &amp;&amp; suma[r]-suma[mid-1]&lt;mida) mid--; if(l&lt;1 || mid&lt;l) break; ll temp = suma[r] - suma[l-1] - ans; if(getr(l,mid)+getl(mid,r)-temp*(x[mid]-x[l])&lt;=T) return true; r--; } return false;}int main(){#ifdef LOCAL freopen(&quot;3.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%lld%lld&quot;,&amp;n,&amp;T); T&gt;&gt;=1; rep(i,1,n+1) scanf(&quot;%lld&quot;,x+i); rep(i,1,n+1){ scanf(&quot;%lld&quot;,a+i); suma[i] = suma[i-1] + a[i]; sumt[i] = sumt[i-1]+a[i]*x[i]; } ll l,r,mid,ans; l = 1;r = suma[n]; while(l&lt;=r){ mid = (l+r)&gt;&gt;1; if(check(mid)){ ans = mid;l = mid+1; }else { r = mid-1; } } printf(&quot;%lld\\n&quot;,ans); return 0;} https://www.nowcoder.com/discuss/88268?type=101&amp;order=1&amp;pos=4&amp;page=1 https://www.cnblogs.com/Flower-Z/p/9528057.html H.travel题意给定一棵树，树上每个点有一个$val$，从树上走三次，不能走重复的点，问能获得的最大价值是多少。 题解树形dp $f[i][j]$表示以$i$为根的子树选了$j$条路径的最大权值和。(也是包含$i$点) $g[i][j]$表示以$i$为根的子树选了$j$条路径加上一条包含$i$到根节点链的最大权值。 根据题意可以知道，如果我们$i$是竖直链，那么加入一个没有竖直链的。 $g[u][i] = max(g[u][i],f[v][x]+g[u][i-x])$ $g[u][i] = max(g[u][i],g[v][x]+f[v][i-x])$ 如果$i$不是竖直链 $f[u][i]=max(f[u][i],f[v][x]+f[u][i-x])$ 对不起，我编不下去了。就是瞎几把转移转移。能转移的状态就都转移了就行了。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 4e5 + 10;struct node{ int to,next;}G[maxn&lt;&lt;1];int head[maxn];ll f[maxn][4],g[maxn][4];int n,cnt;ll val[maxn];void add(int u,int v){ G[cnt].to = v; G[cnt].next = head[u]; head[u] = cnt++;}void dfs(int u,int fa){ ll best[4][3] = {0}; ll temp[4][3] = {0}; ll last[4][3] = {0}; for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(v==fa) continue; dfs(v,u); memset(temp,0,sizeof(temp)); memset(best,0,sizeof(best)); rep(x,0,4){ temp[x][0] = f[v][x]; temp[x][1] = g[v][x]; } rep(x,0,4) rep(y,0,4-x) rep(p,0,3) rep(q,0,3-p) best[x+y][q+p] = max(best[x+y][p+q],last[x][p]+temp[y][q]); memcpy(last,best,sizeof(best)); } rep(x,0,4) f[u][x] = max(f[u][x],best[x][0]); rep(x,1,4) rep(y,0,3) f[u][x] = max(f[u][x],val[u]+best[x-1][y]); rep(x,0,4) rep(y,0,2) g[u][x] = max(g[u][x],val[u]+best[x][y]);}int main(){#ifdef LOCAL freopen(&quot;h.in&quot;,&quot;r&quot;,stdin);#endif memset(head,-1,sizeof(head)); scanf(&quot;%d&quot;,&amp;n); rep(i,1,n+1) scanf(&quot;%lld&quot;,val+i); rep(i,0,n-1){ int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); } dfs(1,-1); printf(&quot;%lld\\n&quot;,f[1][3]); return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//dls队伍代码，感觉比标程的容易懂一点。#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int N=410000;vector&lt;int&gt; go[N&lt;&lt;1];int n,w[N];long long dp[N][4][2];void treedp(int k1,int k2){ long long f[4][3]; long long pre[4][3]; memset(f,0x00,sizeof f); for (int i=0;i&lt;go[k1].size();i++){ int j=go[k1][i]; if (j!=k2){ treedp(j,k1); memcpy(pre,f,sizeof f); for (int a=0;a&lt;4;a++) for (int b=0;b&lt;4;b++) for (int c=0;c&lt;3;c++) for (int d=0;d&lt;2;d++){ if (a+b&gt;3||c+d&gt;2) continue; f[a+b][c+d]=max(f[a+b][c+d],pre[a][c]+dp[j][b][d]); } } } for (int i=0;i&lt;4;i++){ dp[k1][i][0]=max(dp[k1][i][0],f[i][0]); dp[k1][i][1]=max(dp[k1][i][1],f[i][1]+w[k1]); if (i&lt;3){ for (int a=0;a&lt;2;a++) for (int b=a+1;b&lt;3;b++) dp[k1][i+1][a]=max(dp[k1][i+1][a],f[i][b]+w[k1]); } }}int main(){ scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]); for (int i=1;i&lt;n;i++){ int k1,k2; scanf(&quot;%d%d&quot;,&amp;k1,&amp;k2); go[k1].push_back(k2); go[k2].push_back(k1); } treedp(1,0); long long ans=0; for (int i=0;i&lt;=3;i++) ans=max(ans,dp[1][i][0]); printf(&quot;%lld\\n&quot;,ans);} I.Car题意给定一个长度为$n$的正方形，在上面放车。车有如下性质 速度一样 不能改变方向 起点都在矩阵的边缘 题解 奇数点特判一下，免得减了两次。题解也是经验所得，莫得证明。 AC代码1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,m;const int maxn = 1e5 + 10;int col[maxn],row[maxn];int main(){#ifdef LOCAL freopen(&quot;i.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int ans = 2*n; if(n%2) ans--; rep(i,0,m){ int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); row[x] = 1;col[y]=1; } rep(i,1,n+1){ if(row[i]) ans--; if(col[i]) ans--; } if(n%2 &amp;&amp; row[(n+1)/2]==1 &amp;&amp; col[(n+1)/2]) ans++; printf(&quot;%d\\n&quot;,ans); return 0;} J.Farm题意有一块$nm$的田，里面每一个土地都种$a[i][j]$的植物，每一种植物都有专属化肥，如果用错化肥就挂了。问在进行$T$次区间浇化肥后，挂了过多少个植物。 题解我一开始想的是能不能统计一下前缀和，如果加入的肥料和是植物种类的倍数就是对的。但是需要随机算法，避免出题人卡。毕竟是假算法。还是乖乖按照标答思路来。。 将化肥按照二进制分为肯定对植物不好和可能对植物好。如 $a$植物代号是101010,那么检查每一位的时候，101011肯定对它不好，101110在检查前几位的时候可能对它好。 分辨植物是否死亡就看。 他加入对它好的次数是不是总的施在他身上的次数。如果不等，说明有其他不好的施肥了，那他就挂了。 他加入对它不好的次数存不存在，如果有，那他也挂了。 还有一个细节，定义数组更加环保和不可能爆空间。之后可以定义 123int f[maxn];#define id(x,y) (x-1)*m+y// f[x][y] = f[id(x,y)] 还有一个细节就是前缀和你如果想要改变一个区间的前缀和，那就 123456789101112131415void add(int x1,int x2,int y1,int y2){ f[id(x1,y1)]++; if(x2&lt;n) f[id(x2+1,y1)]--; if(y2&lt;m) f[id(x1,y2+1)]--; if(x2&lt;n &amp;&amp; y2&lt;m) f[id(x2+1,y2+1)]++;}void gen(int *s){ for(int i = 1;&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ if(i&gt;1) s[id(x,y)]+=t[id(x-1,y)]; if(j&gt;1) s[id(x,y)]+=s[id(x,y-1)]; if(i&gt;1&amp;&amp;j&gt;1) s[id(x,y)]-=s[id(x-1,y-1)]; } }} AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint read() { int w=0;bool q=1;char c=getchar(); while ((c&lt;'0'||c&gt;'9') &amp;&amp; c!='-') c=getchar(); if (c=='-') q=0,c=getchar(); while (c&gt;='0'&amp;&amp;c &lt;= '9') w=w*10+c-'0',c=getchar(); return q? w:-w;}#define id(x,y) (x-1)*m+yconst int maxn = 1e6 + 1000;int n,m,T;int ans[maxn];int s[maxn],x1[maxn],x2[maxn],y1[maxn],y2[maxn],kind[maxn],a[maxn];void add(int k,int *f){ int a,b,c,d; a=x1[k]; b=x2[k]; c=y1[k]; d=y2[k]; f[id(a,c)]++; if(b&lt;n) f[id(b+1,c)]--; if(d&lt;m) f[id(a,d+1)]--; if(b&lt;n&amp;&amp;d&lt;m) f[id(b+1,d+1)]++;}void gen(int *f){ rep(i,1,n+1) rep(j,1,m+1){ if(i&gt;1) f[id(i,j)] += f[id(i-1,j)]; if(j&gt;1) f[id(i,j)] += f[id(i,j-1)]; if(i&gt;1&amp;&amp;j&gt;1) f[id(i,j)] -= f[id(i-1,j-1)]; }}int main(){#ifdef LOCAL freopen(&quot;j.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;T); rep(i,1,n+1) rep(j,1,m+1) a[id(i,j)] = read(); rep(i,0,T){ x1[i]=read();y1[i]=read();x2[i]=read();y2[i]=read();kind[i]=read(); add(i,s); } gen(s); rep(bit,0,21){ int f[maxn] ={0}; rep(i,0,T){ if(kind[i]&gt;&gt;bit &amp; 1){ add(i,f); } } gen(f); rep(i,1,n+1) rep(j,1,m+1){ if(a[id(i,j)]&gt;&gt;bit &amp; 1){ if(f[id(i,j)]!=s[id(i,j)]) ans[id(i,j)] = 1; }else if(f[id(i,j)]){ ans[id(i,j)] = 1; } } } int res = 0; rep(i,1,n+1) rep(j,1,m+1){ if(ans[id(i,j)]) res++; } printf(&quot;%d\\n&quot;,res); return 0;} 偷窥到大佬还有用树状数组做的。先copy一下代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;#define mp make_pair#define fi first#define se second#define debug(x) cerr&lt;&lt;#x&lt;&lt;&quot; = &quot;&lt;&lt;(x)&lt;&lt;endl#define eps 1e-8#define pi acos(-1.0)using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int MAXN=(int)1e6+5;const int MOD=(int)1e9+7;int read(){ int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}vector&lt;int&gt;p[MAXN];vector&lt;pii&gt;ve[MAXN];int n,m;void add(int x,int y,int z){ for(int i=x;i&lt;=n;i+=i&amp;-i){ for(int j=y;j&lt;=m;j+=j&amp;-j){ p[i][j]+=z; } }}int query(int x,int y){ int re=0; for(int i=x;i;i-=i&amp;-i){ for(int j=y;j;j-=j&amp;-j){ re+=p[i][j]; } } return re;}void add(int a,int b,int x,int y,int f){ add(a,b,f); add(x+1,y+1,f); add(a,y+1,-f); add(x+1,b,-f);}void init(){ for(int i=1;i&lt;=n;i++)p[i].resize(m+1);}struct node{ int a,b,x,y,k; void scan(){ a=read();b=read();x=read();y=read();k=read(); }};vector&lt;node&gt;op[MAXN]; int main(){ int q; n=read();m=read();q=read(); init(); for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ int x;x=read(); ve[x].push_back(mp(i,j)); } } for(int i=1;i&lt;=q;i++){ node now; now.scan(); op[now.k].push_back(now); add(now.a,now.b,now.x,now.y,1); } int ans=0; for(int i=1;i&lt;=n*m;i++){ // debug(i); if(!ve[i].empty()){ for(auto opi:op[i])add(opi.a,opi.b,opi.x,opi.y,-1); for(auto x:ve[i])if(query(x.fi,x.se))ans++; for(auto opi:op[i])add(opi.a,opi.b,opi.x,opi.y,1); //debug(ans); } } printf(&quot;%d\\n&quot;,ans); return 0;}","link":"/acm/2018/08/28/nowcoder2-%E8%A1%A5%E9%A2%98%E5%90%91.html"},{"title":"模板","text":"Java大数模板二、Java之输入输出处理由于ACM竞赛题目的输入数据和输出数据一般有多组（不定），并且格式多种多样，所以，如何处理题目的输入输出是对大家的一项最基本的要求。这也是困扰初学者的一大问题。 输入： 格式1：Scanner sc = new Scanner (new BufferedInputStream(System.in)); 格式2：Scanner sc = new Scanner (System.in); 在读入数据量大的情况下，格式1的速度会快些。 读一个整数： int n = sc.nextInt(); 相当于 scanf(“%d”, &amp;n); 或 cin &gt;&gt; n; 读一个字符串：String s = sc.next(); 相当于 scanf(“%s”, s); 或 cin &gt;&gt; s; 读一个浮点数：double t = sc.nextDouble(); 相当于 scanf(“%lf”, &amp;t); 或 cin &gt;&gt; t; 读一整行： String s = sc.nextLine(); 相当于 gets(s); 或 cin.getline(…); 判断是否有下一个输入可以用sc.hasNext()或sc.hasNextInt()或sc.hasNextDouble()或sc.hasNextLine() 123456import java.util.Scanner;import java.math.*;Scanner cin = new Scanner (new BufferedInputStream(System.in));while(cin.haxNextInt){ //操作} 大数使用例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215import java.io.*;import java.math.*;import java.util.*;public class Main { static Scanner in = new Scanner(System.in); public static void main(String[] args) { int a = in.nextInt(); BigInteger b = in.nextBigInteger(); BigDecimal c = in.nextBigDecimal(); /* BigDecimal： 构造方法: BigDecimal(BigInteger val) BigDecimal(BigInteger unscaledVal, int scale) BigDecimal(BigInteger unscaledVal, int scale, MathContext mc) BigDecimal(BigInteger val, MathContext mc) BigDecimal(char[] in) BigDecimal(char[] in, int offset, int len) BigDecimal(char[] in, int offset, int len, MathContext mc) BigDecimal(char[] in, MathContext mc) BigDecimal(double val) BigDecimal(double val, MathContext mc) BigDecimal(int val) BigDecimal(int val, MathContext mc) BigDecimal(long val) BigDecimal(long val, MathContext mc) BigDecimal(String val) BigDecimal(String val, MathContext mc) 成员方法: BigDecimal abs() BigDecimal abs(MathContext mc) BigDecimal add(BigDecimal augend) BigDecimal add(BigDecimal augend, MathContext mc) byte byteValueExact() int compareTo(BigDecimal val) BigDecimal divide(BigDecimal divisor) BigDecimal divide(BigDecimal divisor, int roundingMode) BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) BigDecimal divide(BigDecimal divisor, MathContext mc) BigDecimal divide(BigDecimal divisor, RoundingMode roundingMode) BigDecimal[] divideAndRemainder(BigDecimal divisor) BigDecimal[] divideAndRemainder(BigDecimal divisor, MathContext mc) BigDecimal divideToIntegralValue(BigDecimal divisor) BigDecimal divideToIntegralValue(BigDecimal divisor, MathContext mc) double doubleValue() boolean equals(Object x) float floatValue() int hashCode() int intValue() int intValueExact() long longValue() long longValueExact() BigDecimal max(BigDecimal val) BigDecimal min(BigDecimal val) BigDecimal movePointLeft(int n) BigDecimal movePointRight(int n) BigDecimal multiply(BigDecimal multiplicand) BigDecimal multiply(BigDecimal multiplicand, MathContext mc) BigDecimal negate() BigDecimal negate(MathContext mc) BigDecimal plus() BigDecimal plus(MathContext mc) BigDecimal pow(int n) BigDecimal pow(int n, MathContext mc) int precision() BigDecimal remainder(BigDecimal divisor) BigDecimal remainder(BigDecimal divisor, MathContext mc) BigDecimal round(MathContext mc) int scale() BigDecimal scaleByPowerOfTen(int n) BigDecimal setScale(int newScale) Returns a BigDecimal whose scale is the specified value, and whose value is numerically equal to this BigDecimal's. BigDecimal setScale(int newScale, int roundingMode) BigDecimal setScale(int newScale, RoundingMode roundingMode) Returns a BigDecimal whose scale is the specified value, and whose unscaled value is determined by multiplying or dividing this BigDecimal's unscaled value by the appropriate power of ten to maintain its overall value. short shortValueExact() int signum() Returns the signum function of this BigDecimal. (1,0,-1) BigDecimal stripTrailingZeros() Returns a BigDecimal which is numerically equal to this one but with any trailing zeros removed from the representation. BigDecimal subtract(BigDecimal subtrahend) BigDecimal subtract(BigDecimal subtrahend, MathContext mc) BigInteger toBigInteger() BigInteger toBigIntegerExact() String toEngineeringString() String toPlainString() String toString() BigDecimal ulp() Returns the size of an ulp, a unit in the last place, of this BigDecimal. BigInteger unscaledValue() static BigDecimal valueOf(double val) static BigDecimal valueOf(long val) static BigDecimal valueOf(long unscaledVal, int scale) */ BigDecimal test = new BigDecimal(&quot;1.234567&quot;); test = test.setScale(3, RoundingMode.HALF_UP); System.out.println(test); test = test.setScale(7, RoundingMode.HALF_EVEN); System.out.println(test); test = test.divide(new BigDecimal(&quot;3&quot;), MathContext.UNLIMITED); // 默认也是UNLIMITED精度，无限小数会报错 System.out.println(test); /* BigInteger: 构造方法: BigInteger(byte[] val) BigInteger(int signum, byte[] magnitude) BigInteger(int bitLength, int certainty, Random rnd) Constructs a randomly generated positive BigInteger that is probably prime, with the specified bitLength. BigInteger(int numBits, Random rnd) Constructs a randomly generated BigInteger, uniformly distributed over the range 0 to (2numBits - 1), inclusive. BigInteger(String val) BigInteger(String val, int radix) 成员方法: BigInteger abs() BigInteger add(BigInteger val) BigInteger and(BigInteger val) BigInteger andNot(BigInteger val) Returns a BigInteger whose value is (this &amp; ~val). int bitCount() Returns the number of bits in the two's complement representation of this BigInteger that differ from its sign bit. int bitLength() Returns the number of bits in the minimal two's-complement representation of this BigInteger, excluding a sign bit. BigInteger clearBit(int n) Returns a BigInteger whose value is equivalent to this BigInteger with the designated bit cleared. int compareTo(BigInteger val) BigInteger divide(BigInteger val) BigInteger[] divideAndRemainder(BigInteger val) double doubleValue() boolean equals(Object x) BigInteger flipBit(int n) Returns a BigInteger whose value is equivalent to this BigInteger with the designated bit flipped. float floatValue() BigInteger gcd(BigInteger val) Returns a BigInteger whose value is the greatest common divisor of abs(this) and abs(val). int getLowestSetBit() Returns the index of the rightmost (lowest-order) one bit in this BigInteger (the number of zero bits to the right of the rightmost one bit). int hashCode() int intValue() boolean isProbablePrime(int certainty) Returns true if this BigInteger is probably prime, false if it's definitely composite. long longValue() BigInteger max(BigInteger val) BigInteger min(BigInteger val) BigInteger mod(BigInteger m) BigInteger modInverse(BigInteger m) Returns a BigInteger whose value is (this^-1 mod m). BigInteger modPow(BigInteger exponent, BigInteger m) BigInteger multiply(BigInteger val) BigInteger negate() BigInteger nextProbablePrime() Returns the first integer greater than this BigInteger that is probably prime. BigInteger not() BigInteger or(BigInteger val) BigInteger pow(int exponent) static BigInteger probablePrime(int bitLength, Random rnd) Returns a positive BigInteger that is probably prime, with the specified bitLength. BigInteger remainder(BigInteger val) Returns a BigInteger whose value is (this % val). BigInteger setBit(int n) Returns a BigInteger whose value is equivalent to this BigInteger with the designated bit set. BigInteger shiftLeft(int n) Returns a BigInteger whose value is (this &lt;&lt; n). BigInteger shiftRight(int n) Returns a BigInteger whose value is (this &gt;&gt; n). int signum() BigInteger subtract(BigInteger val) boolean testBit(int n) Returns true if and only if the designated bit is set. byte[] toByteArray() String toString() String toString(int radix) static BigInteger valueOf(long val) BigInteger xor(BigInteger val) */ MyPair[] pairs = new MyPair[1000]; Arrays.sort(pairs); Arrays.binarySearch(pairs, 1, 4, new MyPair()); /* 二分查找 如果元素在数组中，则值为0~n-1，否则值为-1~-(n+1)，表示第一个比它大的值的位置，下标从1开始 */ List&lt;MyPair&gt; pairList = new ArrayList&lt;&gt;(); pairList.add(new MyPair()); //pairList.sort(); pairList.sort(new Cmp()); Collections.shuffle(pairList); Collections.swap(pairList, 1, 3); Collections.sort(pairList); }}class MyPair implements Comparable { int x, y; @Override public int compareTo(Object o) { MyPair b = (MyPair)o; if(x!=b.x) return x&lt;b.x?-1:1; else if(y!=b.y) return y&lt;b.y?-1:1; return 0; }}class Cmp implements Comparator&lt;MyPair&gt; { @Override public int compare(MyPair o1, MyPair o2) { if(o1.x!=o2.x) return o1.x&lt;o2.x?-1:1; else if(o1.y!=o2.y) return o1.y&lt;o2.y?-1:1; return 0; }} 关于树的树链剖分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1void swap(int &amp;a,int &amp;b){ int temp = a; a = b; b = temp;}typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e4+10;int size[maxn],dep[maxn],top[maxn],fa[maxn],id[maxn],son[maxn];int head[maxn],w[maxn];int n,cnt,totw,m;struct edge{ int next,to;}G[maxn&lt;&lt;1];int find(int x){ return x==fa[x]?x:find(fa[x]);}void addedge(int u,int v){ G[cnt].next = head[u]; G[cnt].to = v; head[u] = cnt++;}void dfs1(int u,int f){ size[u] = 1; for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(v==f) continue; dep[v] = dep[u]+1; fa[v] = u; dfs1(v,u); if(size[v] &gt; size[son[u]]) son[u] = v; size[u]+=size[v]; }}void dfs2(int u,int topu){ top[u] = topu; id[u] = ++totw; if(son[u]) dfs2(son[u],top[u]); for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(v==fa[u] || v==son[u]) continue; dfs2(v,v); }}int data[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2];void pushdown(int rt){ if(lazy[rt]!=0){ data[rt&lt;&lt;1] += lazy[rt]; data[rt&lt;&lt;1|1] += lazy[rt]; lazy[rt&lt;&lt;1] += lazy[rt]; lazy[rt&lt;&lt;1|1] += lazy[rt]; lazy[rt] = 0; }}void build(int l,int r,int rt){ lazy[rt] = 0; if(l==r){ data[rt] = w[l]; return; } int mid = l+r&gt;&gt;1; build(lson); build(rson);}int query(int pos,int l,int r,int rt){ if(l==r &amp;&amp; l==pos) return data[rt]; int mid = l+r&gt;&gt;1; pushdown(rt); if(pos&lt;=mid) return query(pos,lson); else return query(pos,rson);}void update(int val,int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ lazy[rt] += val; data[rt] += val; return; } pushdown(rt); int mid = l+r&gt;&gt;1; if(L&lt;=mid) update(val,L,R,lson); if(mid&lt;R) update(val,L,R,rson);}void change(int u,int v,int val){ int t1=top[u],t2=top[v]; while(t1!=t2){ if(dep[t1]&lt;dep[t2]){ swap(t1,t2); swap(u,v); } update(val,id[t1],id[u],1,totw,1); u = fa[t1]; t1 = top[u]; } if(dep[u]&gt;dep[v]) swap(u,v); update(val,id[u],id[v],1,totw,1);}int val[maxn];int p;char op[20];void init(){ cnt = totw = 0; memset(head,-1,sizeof(head)); dep[1] = fa[1] = size[0] = 0; memset(son,0,sizeof(son));}int main(){#ifdef LOCAL freopen(&quot;4.in&quot;,&quot;r&quot;,stdin);#endif while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p)){ init(); rep(i,1,n+1) scanf(&quot;%d&quot;,val+i); rep(i,0,m){ int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v); addedge(v,u); } dfs1(1,0); dfs2(1,1); rep(i,1,n+1) w[id[i]] = val[i]; build(1,totw,1); while(p--){ scanf(&quot;%s&quot;,op); if(op[0]=='Q'){ int x;scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,query(id[x],1,totw,1)); }else{ int u,v,val;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;val); if(op[0]=='D') val = -val; change(u,v,val); } } } return 0;} 线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//head ----------------------------------------const int maxn = 1e6+20;int T,n,m;struct sgt{ int maxlen[maxn&lt;&lt;2]; int ll[maxn&lt;&lt;2],rr[maxn&lt;&lt;2],mm[maxn&lt;&lt;2]; int lazy[maxn&lt;&lt;2]; void build(int l,int r,int rt){ lazy[rt] = -1; if(l==r){ ll[rt] = rr[rt] = 0; mm[rt] = 1; return; } int mid = l+r&gt;&gt;1; build(lson); build(rson); } void init(){ lazy[1] = 1; } void pushup(int l,int r,int rt){ if(lazy[rt]&gt;=0){ maxlen[rt] = ll[rt] = rr[rt] = mm[rt] = (lazy[rt]?(r-l+1):0); }else{ int lc = rt&lt;&lt;1,rc = rt&lt;&lt;1|1,mid = l+r&gt;&gt;1; ll[rt] = ll[lc]; if(ll[lc]==(mid-l+1)) ll[rt] += ll[rc]; mm[rt] = rr[lc] + ll[rc]; rr[rt] = rr[rc]; if(rr[rc] == r-mid) rr[rt] += rr[lc]; maxlen[rt] = max(maxlen[lc],max(maxlen[rc],mm[rt])); } } void pushdown(int rt){ if(lazy[rt]&gt;=0){ int lc=rt&lt;&lt;1,rc=rt&lt;&lt;1|1; lazy[lc] = lazy[rc] = lazy[rt]; lazy[rt] = -1; } } int query(int val,int l,int r,int rt){ pushup(l,r,rt); //cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;' '&lt;&lt;&quot; &quot;; int lc = rt&lt;&lt;1,rc = rt&lt;&lt;1|1,mid = l+r&gt;&gt;1; if(val&gt;maxlen[rt]) return 0; if(ll[rt] &gt;= val) return l; pushdown(rt); pushup(rson); int temp = query(val,lson); if(temp) return temp; if(mm[rt] &gt;= val) return mid-rr[lc]+1; return query(val,rson); } void update(int val,int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ lazy[rt] = val; pushup(l,r,rt); return; } pushdown(rt); int mid = l+r&gt;&gt;1; if(L&lt;=mid) update(val,L,R,lson); else pushup(lson); if(mid&lt;R) update(val,L,R,rson); else pushup(rson); pushup(l,r,rt); }}all,ns;char op[20];int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); rep(test_case,1,T+1){ printf(&quot;Case %d:\\n&quot;,test_case); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); //all.build(1,n,1); ns.build(1,n,1); all.init(); ns.init(); while(m--){ scanf(&quot;%s&quot;,op); if(op[0]=='D'){ int x;scanf(&quot;%d&quot;,&amp;x); int ans = all.query(x,1,n,1); if(ans){ all.update(0,ans,ans+x-1,1,n,1); printf(&quot;%d,let's fly\\n&quot;,ans); }else{ puts(&quot;fly with yourself&quot;); } }else if(op[0]=='N'){ int x;scanf(&quot;%d&quot;,&amp;x); int ans = all.query(x,1,n,1); if(!ans) ans = ns.query(x,1,n,1); if(ans){ all.update(0,ans,ans+x-1,1,n,1); ns.update(0,ans,ans+x-1,1,n,1); printf(&quot;%d,don't put my gezi\\n&quot;,ans); }else{ puts(&quot;wait for me&quot;); } }else{ int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); all.update(1,x,y,1,n,1); ns.update(1,x,y,1,n,1); puts(&quot;I am the hope of chinese chengxuyuan!!&quot;); } } } return 0;} LCA 最近公共父节点 用来求两点之间距离的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5 + 10;int cnt,n,m;int head[maxn];int fa[maxn];struct node{ int next,to;}G[maxn&lt;&lt;1];void addedge(int u,int v){ G[cnt].to = v; G[cnt].next = head[u]; head[u] = cnt++;}struct ST{ int tot; int first[maxn&lt;&lt;1],R[maxn&lt;&lt;1],order[maxn&lt;&lt;1],dp[maxn&lt;&lt;1][20],dis[maxn]; void init(int root){ tot = 0; dfs(root,0,-1); ST_init(tot); } void ST_init(int n){ rep(i,1,n+1) dp[i][0] = i; for(int j=1;(1&lt;&lt;j)&lt;=n;j++){ for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++){ int a = dp[i][j-1],b = dp[i+(1&lt;&lt;(j-1))][j-1]; dp[i][j] = R[a]&lt;R[b]?a:b; } } } int LCA(int u,int v){ int x = first[u],y = first[v]; if(x&gt;y) swap(x,y); int res = RMQ(x,y); return order[res]; } int RMQ(int l,int r){ int k = 0; while((1&lt;&lt;(k+1))&lt;=r-l+1) k++; int a = dp[l][k],b = dp[r-(1&lt;&lt;k)+1][k]; return R[a]&lt;R[b]?a:b; } void dfs(int u,int deep,int f){ R[++tot] = deep; dis[u] = deep; order[tot] = u; first[u] = tot; for(int i=head[u];~i;i=G[i].next){ int v = G[i].to; if(v==f) continue; dfs(v,deep+1,u); order[++tot] = u; R[tot] = deep; } }}st;int find(int x){ return x==fa[x]?x:fa[x] = find(fa[x]);}int ind[maxn];char s[60];void init(){ cnt = 0; memset(head,-1,sizeof(head)); memset(ind,0,sizeof(ind));}int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(); map&lt;string,int&gt; mp; int tot = 0; rep(i,0,n-1){ int u,v; scanf(&quot;%s&quot;,s); if(mp[s]==0) mp[s] = ++tot,u = tot; else u = mp[s]; scanf(&quot;%s&quot;,s); if(mp[s]==0) mp[s] = ++tot,v = tot; else v = mp[s]; addedge(v,u); ind[u]++; } int root = 0; rep(i,1,n+1) if(ind[i]==0){ root = i; break; } st.init(root); rep(i,0,m){ int u,v,ans; scanf(&quot;%s&quot;,s); u = mp[s]; scanf(&quot;%s&quot;,s); v = mp[s]; int rt = st.LCA(u,v); int x = st.dis[u] - st.dis[rt]; int y = st.dis[v] - st.dis[rt]; if(rt==u) ans = 1; else if(rt == v) ans = x; else ans = x+1; if(u==v) ans = 0; printf(&quot;%d\\n&quot;,ans); } } return 0;}","link":"/%E6%A8%A1%E6%9D%BF/2018/09/30/%E6%A8%A1%E6%9D%BF.html"},{"title":"[kuangbin带你飞7]线段树","text":"kuangbin带你飞7前言作为一名acm选手，不能连线段树都不会，练就完事了。而且我越发觉得在赛场上不能卡机，中档题才是区分牌子的题目。只有慢慢思索的题目才能真正地提高自己，立下一个flag，每十天完成一个kuangbin专题。现在时间9/6。必须在9/16完成这个线段树专题，就算是困死也得完成。 感想 左右区间还是注意一下，保不准出题人恶趣味。 初始化不能想当然$n$多大树多大，有可能他是一个范围，$n$只是代表着式子的个数罢了。 数组居然还是又一次忘记开4倍。 lazy数组忘记初始化，或者lazy可以为0但是还是初始化为0了。 A.敌兵布阵题意这如果我没有记错，应该是人生中第一个线段树题目，很是经典。单点修改，区间查询。 题解线段树。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e4 + 10;int T,n;int sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2],a[maxn];void pushup(int rt){ sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1];}void pushdown(int rt,int len){ if(lazy[rt]){ lazy[rt&lt;&lt;1] += lazy[rt]; lazy[rt&lt;&lt;1|1] += lazy[rt]; sum[rt&lt;&lt;1] += lazy[rt]*(len/2); sum[rt&lt;&lt;1|1] += lazy[rt]*(len-len/2); lazy[rt] = 0; }}void build(int l,int r,int rt){ lazy[rt] = 0; if(l==r){ sum[rt] = a[l]; return ; } int mid = l+r&gt;&gt;1; build(lson);build(rson); pushup(rt);}void update(int val,int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ lazy[rt] += val; sum[rt] += val*(r-l+1); return ; } pushdown(rt,r-l+1); int mid = l+r&gt;&gt;1; if(L &lt;= mid) update(val,L,R,lson); if(mid &lt; R) update(val,L,R,rson); pushup(rt);}int query(int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R) return sum[rt]; pushdown(rt,r-l+1); int mid = l+r&gt;&gt;1; int ans = 0; if(L &lt;= mid) ans += query(L,R,lson); if(mid &lt; R) ans += query(L,R,rson); return ans;}int main(){#ifdef LOCAL freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); rep(test_case,1,T+1){ scanf(&quot;%d&quot;,&amp;n); rep(i,1,n+1) scanf(&quot;%d&quot;,a+i); build(1,n,1); char op[20]; printf(&quot;Case %d:\\n&quot;,test_case); while(scanf(&quot;%s&quot;,op) &amp;&amp; op[0]!='E'){ if(op[0]=='A' || op[0] =='S'){ int l,val;scanf(&quot;%d%d%d&quot;,&amp;l,&amp;val); if(op[0] == 'A') update(val,l,l,1,n,1); else update(-val,l,l,1,n,1); }else{ int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%d\\n&quot;,query(l,r,1,n,1)); } } } return 0;} B.I Hate It题意单点修改，区间最值。 题解线段树。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 2e5 + 10;int n,m;int mmax[maxn&lt;&lt;2],a[maxn];void pushup(int rt){ mmax[rt] = max(mmax[rt&lt;&lt;1],mmax[rt&lt;&lt;1|1]);}void build(int l,int r,int rt){ if(l==r){ mmax[rt] = a[l]; return; } int mid = l+r&gt;&gt;1; build(lson);build(rson); pushup(rt);}void update(int val,int p,int l,int r,int rt){ if(l==r &amp;&amp; l==p){ mmax[rt] = val; return; } int mid = l+r&gt;&gt;1; if(p &lt;= mid) update(val,p,lson); if(mid &lt; p) update(val,p,rson); pushup(rt);}int query(int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R) return mmax[rt]; int mid = l+r&gt;&gt;1; int ans = 0; if(L &lt;= mid) ans = max(ans,query(L,R,lson)); if(mid &lt; R) ans = max(ans,query(L,R,rson)); return ans;}int main(){#ifdef LOCAL freopen(&quot;b.in&quot;,&quot;r&quot;,stdin);#endif while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){ rep(i,1,n+1) scanf(&quot;%d&quot;,a+i); build(1,n,1); rep(i,0,m){ char op[20];int x,y; scanf(&quot;%s%d%d&quot;,op,&amp;x,&amp;y); if(op[0] == 'Q'){ printf(&quot;%d\\n&quot;,query(x,y,1,n,1)); }else{ update(y,x,1,n,1); } } } return 0;} C - A Simple Problem with Integers题意区间查询，区间修改。 题解线段树 lazy需也要开两倍 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstring&gt;#include&lt;stdio.h&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5 + 10;ll sum[maxn&lt;&lt;2],a[maxn],lazy[maxn&lt;&lt;2];int n,q;void pushup(int rt){ sum[rt] = sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];}void pushdown(int rt,ll len){ if(lazy[rt]){ lazy[rt&lt;&lt;1] += lazy[rt]; lazy[rt&lt;&lt;1|1] += lazy[rt]; sum[rt&lt;&lt;1] += lazy[rt]*(len-len/2); sum[rt&lt;&lt;1|1] += lazy[rt]*(len/2); lazy[rt] = 0; }}void build(int l,int r,int rt){ if(l==r){ sum[rt] = a[l]; return; } int mid = l+r&gt;&gt;1; build(lson);build(rson); pushup(rt);}void update(ll val,int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ lazy[rt] += val; sum[rt] += val*(r-l+1); return; } pushdown(rt,r-l+1); int mid = l+r&gt;&gt;1; if(L &lt;= mid) update(val,L,R,lson); if(mid &lt; R) update(val,L,R,rson); pushup(rt);}ll query(int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ return sum[rt]; } pushdown(rt,r-l+1); int mid = l+r&gt;&gt;1; ll ans = 0; if(L &lt;= mid) ans += query(L,R,lson); if(mid &lt; R) ans += query(L,R,rson); return ans;}int main(){#ifdef LOCAL freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;n,&amp;q); rep(i,1,n+1) scanf(&quot;%lld&quot;,a+i); build(1,n,1); rep(i,0,q){ char op[20];int a,b,c; scanf(&quot;%s&quot;,op); if(op[0] == 'C'){ scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); update(c,a,b,1,n,1); }else{ scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%lld\\n&quot;,query(a,b,1,n,1)); } } return 0;} D - Mayor’s posters题意贴线段，每次贴都会覆盖掉前面的线。问贴到最后能看到多少种不同的线。 题解线段树+离散化 覆盖线段的范围是1e8，无法建树所以需要离散化，把线段长度按照排序的顺序重新赋值。由于有$2n$个长度所以记得$maxn$要开两倍。 区间修改，单点查询。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 2e5 + 20;int vis[maxn],lx[maxn],rx[maxn],lazy[maxn&lt;&lt;2],mmax[maxn&lt;&lt;2];int T,n;void pushdown(int rt){ if(lazy[rt]){ lazy[rt&lt;&lt;1] = lazy[rt&lt;&lt;1|1] = lazy[rt]; mmax[rt&lt;&lt;1] = mmax[rt&lt;&lt;1|1] = lazy[rt]; lazy[rt] = 0; }}void build(int l,int r,int rt){ lazy[rt] = 0; if(l==r){ mmax[rt] = 0; return ; } int mid = l+r&gt;&gt;1; build(lson); build(rson);}void update(int val,int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ lazy[rt] = val; mmax[rt] = val; return ; } pushdown(rt); int mid = l+r&gt;&gt;1; if(L &lt;= mid) update(val,L,R,lson); if(mid &lt; R) update(val,L,R,rson);}int query(int p,int l,int r,int rt){ if(l==r &amp;&amp; l==p){ return mmax[rt]; } int mid = l+r&gt;&gt;1; pushdown(rt); if(p &lt;= mid) return query(p,lson); if(mid &lt; p) return query(p,rson);}int main(){#ifdef LOCAL freopen(&quot;d.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d&quot;,&amp;n); vector&lt;int&gt;x; rep(i,1,n+1){ int l,r;scanf(&quot;%d%d&quot;,lx+i,rx+i); x.push_back(lx[i]);x.push_back(rx[i]); } sort(x.begin(),x.end()); x.erase(unique(x.begin(),x.end()),x.end()); rep(i,1,n+1){ lx[i] = lower_bound(x.begin(),x.end(),lx[i])-x.begin()+1; rx[i] = lower_bound(x.begin(),x.end(),rx[i])-x.begin()+1; } int len = x.size(); build(1,len,1); rep(i,1,n+1){ update(i,lx[i],rx[i],1,len,1); } memset(vis,0,sizeof(vis)); int ans = 0; rep(i,1,len+1){ int x = query(i,1,len,1); if(vis[x] == 0){ ans ++; vis[x] = 1; } } printf(&quot;%d\\n&quot;,ans); } return 0;} E - Just a Hook题意区间修改，区间查询 题解线段树 ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstring&gt;#include&lt;stdio.h&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5 + 10;int sum[maxn&lt;&lt;2],a[maxn],lazy[maxn&lt;&lt;2];int n,q,T;void pushup(int rt){ sum[rt] = sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];}void pushdown(int rt,int len){ if(lazy[rt]){ lazy[rt&lt;&lt;1] = lazy[rt]; lazy[rt&lt;&lt;1|1] = lazy[rt]; sum[rt&lt;&lt;1] = lazy[rt]*(len-len/2); sum[rt&lt;&lt;1|1] = lazy[rt]*(len/2); lazy[rt] = 0; }}void build(int l,int r,int rt){ lazy[rt] = 0; if(l==r){ sum[rt] = 1; return; } int mid = l+r&gt;&gt;1; build(lson);build(rson); pushup(rt);}void update(int val,int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ lazy[rt] = val; sum[rt] = val*(r-l+1); return; } pushdown(rt,r-l+1); int mid = l+r&gt;&gt;1; if(L &lt;= mid) update(val,L,R,lson); if(mid &lt; R) update(val,L,R,rson); pushup(rt);}int query(int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ return sum[rt]; } pushdown(rt,r-l+1); int mid = l+r&gt;&gt;1; ll ans = 0; if(L &lt;= mid) ans += query(L,R,lson); if(mid &lt; R) ans += query(L,R,rson); return ans;}int main(){#ifdef LOCAL freopen(&quot;e.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); rep(test_case,1,T+1){ scanf(&quot;%d%d&quot;,&amp;n,&amp;q); build(1,n,1); rep(i,0,q){ int l,r,val; scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;val); update(val,l,r,1,n,1); } printf(&quot;Case %d: The total value of the hook is %d.\\n&quot;,test_case,query(1,n,1,n,1)); } return 0;} F.Count the Colors题意在一条线上区间涂颜色。 问所有颜色出现的区间块的数量。 题解线段树+懒惰标记 需要注意的是，$n$不代表着数据的范围，8000才是数据的范围，并且由于区块间有空隙，所以离散化还有点不好做。虽然数据也只有8000。注意的是初始化的范围要覆盖到8000，不能以为到$n$就好了。 +5 $n$当坐范围 +3 误以为build函数能够初始化所有的点，但其实是要memset(vis,-1,sizeof(vis)); AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//head -------------------------const int maxn = 8e3+10;int n;int a[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2],ans[maxn&lt;&lt;2],id[maxn&lt;&lt;2],vis[maxn&lt;&lt;2];void pushdown(int rt){ if(lazy[rt]!=-1){ lazy[rt&lt;&lt;1] = lazy[rt&lt;&lt;1|1] = lazy[rt]; a[rt&lt;&lt;1] = a[rt&lt;&lt;1|1] = lazy[rt]; lazy[rt] = -1; }}void build(int l,int r,int rt){ lazy[rt] = -1; if(l==r){ a[rt] = -1; return; } int mid = l+r&gt;&gt;1; build(lson);build(rson);}void update(int val,int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ a[rt] = val; lazy[rt] = val; return; } pushdown(rt); int mid = l+r&gt;&gt;1; if(L&lt;=mid) update(val,L,R,lson); if(mid&lt;R) update(val,L,R,rson);}void query(int l,int r,int rt){ if(l==r){ vis[l] = a[rt]; return; } int mid = l+r&gt;&gt;1; pushdown(rt); query(lson); query(rson);}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif while(scanf(&quot;%d&quot;,&amp;n)!=EOF){ build(1,8000,1); memset(ans,0,sizeof(ans)); memset(vis,0,sizeof(vis)); memset(id,0,sizeof(id)); rep(i,1,n+1){ int l,r,x;scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x); if(l&gt;=r) continue; update(x,l+1,r,1,8000,1); } query(1,8000,1); int last = -1; //int i = 1; rep(i,1,maxn){ while(vis[i]==-1) i++,last=-1; if(i&gt;=maxn) break; if(vis[i] != last){ last = vis[i]; ans[vis[i]]++; } } rep(i,0,8000+1){ if(ans[i]==0) continue; printf(&quot;%d %d\\n&quot;,i,ans[i]); } puts(&quot;&quot;); } return 0;} G.Balanced Lineup题意求区间最大值和最小值的差 题解可以用ST表预处理，也可以用树状数组或者是线段树，线段树的常数比较大，但他们的复杂度均是$O(nlogn)$ AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e4+20;int mmax[maxn],mmin[maxn];int a[maxn];int n,q;int lowbit(int x){ return x&amp;-x;}void update(int x){ for(int i=x;i&lt;=n;i+=lowbit(i)){ mmax[i] = a[i]; mmin[i] = a[i]; for(int j=1;j&lt;lowbit(i);j&lt;&lt;=1){ mmax[i] = max(mmax[i],mmax[i-j]); mmin[i] = min(mmin[i],mmin[i-j]); } }}int query_min(int l,int r){ int res = INF; while(r&gt;=l){ res = min(a[r],res); r--; for(;r-lowbit(r)&gt;=l;r-=lowbit(r)) res = min(mmin[r],res); } return res;}int query_max(int l,int r){ int res = -INF; while(r&gt;=l){ res = max(a[r],res); r--; for(;r-lowbit(r)&gt;=l;r-=lowbit(r)) res = max(mmax[r],res); } return res;}int solve(int l,int r){ return query_max(l,r)-query_min(l,r);}int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d%d&quot;,&amp;n,&amp;q); rep(i,1,n+1) mmin[i]=INF,mmax[i]=-INF; rep(i,1,n+1){ scanf(&quot;%d&quot;,a+i); update(i); } while(q--){ int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%d\\n&quot;,solve(l,r)); } return 0;} H.Can you answer the queries?题意区间数字根号，区间查询数字和。 题解线段树＋智力门槛 因为所有数字最多根号8次就会变成1。所以我们只需要处理一下当数字为1就不用再更新区间内的数了。 acm还是靠智力和眼力啊，我想了半天都没想出来什么数学方法，原来只需要看出规律和找到最关键的突破点就ok了。 +1超时忘记开4倍数组了。。 +1 虚伪的看到了提醒要注意l,r的大小关系，妈的，这都卡，是不是人啊。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 1e5 + 10;int n,q;ll sum[maxn&lt;&lt;2],mmax[maxn&lt;&lt;2];void pushup(int rt){ sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]; mmax[rt] = max(mmax[rt&lt;&lt;1],mmax[rt&lt;&lt;1|1]);}void build(int l,int r,int rt){ if(l==r){ ll x;scanf(&quot;%lld&quot;,&amp;x); mmax[rt] = sum[rt] = x; return; } int mid = l+r&gt;&gt;1; build(lson);build(rson); pushup(rt);}void update(int L,int R,int l,int r,int rt){ if(mmax[rt]==1) return; if(l==r){ mmax[rt] = sqrt(mmax[rt]); sum[rt] = sqrt(sum[rt]); return; } int mid = l+r&gt;&gt;1; if(L&lt;=mid) update(L,R,lson); if(mid&lt;R) update(L,R,rson); pushup(rt);}ll query(int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R) return sum[rt]; int mid = l+r&gt;&gt;1; ll ans = 0; if(L&lt;=mid) ans += query(L,R,lson); if(mid&lt;R) ans += query(L,R,rson); return ans;}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif int test_case = 1; while(~scanf(&quot;%d&quot;,&amp;n)){ build(1,n,1); scanf(&quot;%d&quot;,&amp;q); printf(&quot;Case #%d:\\n&quot;,test_case++); while(q--){ int l,r,op;scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r); if(l&gt;r){ int temp = l; l = r; r = temp; } if(op==0){ update(l,r,1,n,1); }else{ printf(&quot;%lld\\n&quot;,query(l,r,1,n,1)); } } puts(&quot;&quot;); } return 0;} I Tunnel Warfare(前面写过了)题意题解ac代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se secondtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,m;const int maxn = 5e4+20;int bit[maxn];int lowbit(int x){ return x&amp;-x;}int query(int x){ int ans = 0; for(int i = x;i;i-=lowbit(i)){ ans += bit[i]; } return ans;}int query(int l,int r){ return query(r)-query(l-1);}void add(int x,int val){ for(int i=x;i&lt;=n;i+=lowbit(i)){ bit[i] += val; }}int solve_left(int l,int r){ int mid = l+r&gt;&gt;1;int ans = r; while(l&lt;=r){ mid = l+r&gt;&gt;1; if(query(mid,r)==r-mid+1) r = mid-1,ans = mid; else l = mid+1; } return ans;}int solve_right(int l,int r){ int mid,ans = l; while(l&lt;=r){ mid = l+r&gt;&gt;1; if(query(l,mid)==mid-l+1) l=mid+1,ans = mid; else r = mid-1; } return ans;}int vis[maxn];int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);#endif while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF){ stack&lt;int&gt; st; memset(bit,0,sizeof(bit)); memset(vis,0,sizeof(vis)); rep(i,1,n+1) add(i,1); while(m--){ char op[20];scanf(&quot;%s&quot;,op); if(op[0]=='D'){ int x;scanf(&quot;%d&quot;,&amp;x); st.push(x); if(vis[x]) continue; vis[x] = 1; add(x,-1); }else if(op[0]=='Q'){ int x;scanf(&quot;%d&quot;,&amp;x); if(query(x,x)==0) puts(&quot;0&quot;); else printf(&quot;%d\\n&quot;,solve_right(x,n)-solve_left(1,x)+1); }else{ add(st.top(),1); vis[st.top()] = 0; st.pop(); } } } return 0;} J.Assign the task题意dfs序+线段树模板题 题解同上 +1 lazy数组没有初始化，没适应无build建树 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst int maxn = 5e4+10;int T,n,clk;int on[maxn],in[maxn],ind[maxn],a[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2];vector&lt;int&gt; G[maxn];void init(){ clk = 0; memset(on,0,sizeof(on)); memset(in,0,sizeof(in)); memset(ind,0,sizeof(ind)); memset(a,-1,sizeof(a)); memset(lazy,-1,sizeof(lazy)); rep(i,0,n+1) G[i].clear();}void dfs(int u,int fa){ for(auto v:G[u]){ if(v==fa) continue; in[v] = ++clk; dfs(v,u); } on[u] = clk;}void pushdown(int rt){ if(lazy[rt]!=-1){ lazy[rt&lt;&lt;1] = lazy[rt&lt;&lt;1|1] = lazy[rt]; a[rt&lt;&lt;1] = a[rt&lt;&lt;1|1] = lazy[rt]; lazy[rt] = -1; }}void update(int val,int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ lazy[rt] = val; a[rt] = val; return ; } pushdown(rt); int mid = l+r&gt;&gt;1; if(L&lt;=mid) update(val,L,R,lson); if(mid&lt;R) update(val,L,R,rson);}int query(int p,int l,int r,int rt){ if(l==r &amp;&amp; p==l) return a[rt]; int mid = l+r&gt;&gt;1; pushdown(rt); if(p&lt;=mid) return query(p,lson); else return query(p,rson);}int main(){#ifdef LOCAL freopen(&quot;3.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); rep(test_case,1,T+1){ scanf(&quot;%d&quot;,&amp;n); init(); rep(i,0,n-1){ int u,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v); G[v].push_back(u); ind[u]++; } int root = 0; rep(i,1,n+1) if(ind[i]==0){ root = i; break; } in[root] = ++clk; dfs(root,-1); int q;scanf(&quot;%d&quot;,&amp;q); printf(&quot;Case #%d:\\n&quot;,test_case); while(q--){ char op[20];int x,y; scanf(&quot;%s&quot;,op); if(op[0]=='C'){ scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,query(in[x],1,n,1)); }else{ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); update(y,in[x],on[x],1,n,1); } } } return 0;} K.Transformation题意有四种操作。 将$[l,r]$区间的数字加上$val$. 将$[l,r]$区间的数字乘上$val$ 将$[l,r]$区间的数字变成$val$ 求区间$[l,r]$内所有数字$[1,2,3]$次方的和。 题解线段树 对于线段树的懒惰标记和取模运算细节要求很高。 相信对于sum数组的转化大家都能够推得出来，但是关于pushdown的操作是另有玄机。 首先他的顺序很重要。得先将lazy[1]递推下去，也就是操作3把数字变成$val$，之后再进行乘法和加法的操作。对于乘法很重要的一点是你在lazy[2]标记递推的时候，其实你把子树中的加法也相当于乘了$val$，所以递推不仅要递推乘法标记，还要递推加法标记。 +3 更新Pushdown中你也要更新lazy数组的值 +1 更新的次序也有关系 +1初始化 有的要1. +1 少写一个|1 rt[rt&lt;&lt;1|1]写成了rt&lt;&lt;1 +10000 有一个r-l+1写错了，下次写成 len 。不然很容易出错妈了个鸡 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1template &lt;typename T&gt; inline bool read (T &amp;ret) { char c; int sgn; if (c = getchar(), c == EOF) return 0; //EOF while (c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9') ) { if((c = getchar()) == EOF) return 0; } sgn = (c == '-') ? -1 : 1; ret = (c == '-') ? 0 : (c - '0'); while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + (c - '0'); ret *= sgn; return 1; } typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headconst ll maxn = 1e5 + 20;const ll mod = 1e4 + 7;ll pp[mod+20][4],sum[4][maxn&lt;&lt;2];ll lazy[maxn&lt;&lt;2][4];int n,m,x,y,val;void init(){ memset(sum,0,sizeof(sum)); memset(lazy,0,sizeof(lazy)); rep(i,0,maxn){ lazy[i][2] = 1; }}void pushup(int rt){ rep(i,1,4){ sum[i][rt] = (sum[i][rt&lt;&lt;1] + sum[i][rt&lt;&lt;1|1])%mod; }}void pushdown(int rt,ll len){ if(lazy[rt][3]){ ll c = lazy[rt][3]%mod; lazy[rt&lt;&lt;1][1] = lazy[rt&lt;&lt;1|1][1] = 0; lazy[rt&lt;&lt;1][2] = lazy[rt&lt;&lt;1|1][2] = 1; lazy[rt&lt;&lt;1][3] = lazy[rt&lt;&lt;1|1][3] = c; sum[1][rt&lt;&lt;1] = c*(len-len/2); sum[1][rt&lt;&lt;1|1] = c*(len/2); sum[2][rt&lt;&lt;1] = pp[c][2]*(len-len/2)%mod; sum[2][rt&lt;&lt;1|1] = pp[c][2]*(len/2)%mod; sum[3][rt&lt;&lt;1] = pp[c][3]*(len-len/2)%mod; sum[3][rt&lt;&lt;1|1] = pp[c][3]*(len/2)%mod; lazy[rt][3] = 0; rep(i,1,4){ sum[i][rt&lt;&lt;1] %= mod; sum[i][rt&lt;&lt;1|1] %= mod; } } if(lazy[rt][2]!=1){ ll c = lazy[rt][2]%mod; rep(i,1,4){ sum[i][rt&lt;&lt;1] *= pp[c][i]; sum[i][rt&lt;&lt;1|1] *= pp[c][i]; } rep(i,1,3){ lazy[rt&lt;&lt;1][i] = (lazy[rt&lt;&lt;1][i]%mod)*c%mod; lazy[rt&lt;&lt;1|1][i] = (lazy[rt&lt;&lt;1|1][i]%mod)*c%mod; } lazy[rt][2] = 1; rep(i,1,4){ sum[i][rt&lt;&lt;1] %= mod; sum[i][rt&lt;&lt;1|1] %= mod; } } if(lazy[rt][1]){ ll c = lazy[rt][1]%mod; lazy[rt&lt;&lt;1][1] += c; lazy[rt&lt;&lt;1|1][1] += c; lazy[rt&lt;&lt;1][1] %= mod; lazy[rt&lt;&lt;1|1][1] %= mod; sum[3][rt&lt;&lt;1] += 1ll*3*sum[2][rt&lt;&lt;1]%mod*c%mod + c*c%mod*c%mod*(len-len/2)%mod + 3*sum[1][rt&lt;&lt;1]%mod*c%mod*c%mod; sum[3][rt&lt;&lt;1|1] += 1ll*3*sum[2][rt&lt;&lt;1|1]%mod*c%mod + 3*sum[1][rt&lt;&lt;1|1]*c%mod*c%mod + c*c%mod*c%mod*(len/2)%mod; sum[2][rt&lt;&lt;1] += 1ll*2*sum[1][rt&lt;&lt;1]%mod*c%mod + c*c%mod*(len-len/2)%mod; sum[2][rt&lt;&lt;1|1] += 1ll*2*sum[1][rt&lt;&lt;1|1]%mod*c%mod + c*c%mod*(len/2)%mod; sum[1][rt&lt;&lt;1] += c*(len-len/2); sum[1][rt&lt;&lt;1|1] += c*(len/2); lazy[rt][1] = 0; } rep(i,1,4){ sum[i][rt&lt;&lt;1] %= mod; sum[i][rt&lt;&lt;1|1] %= mod; lazy[rt&lt;&lt;1|1][i] %= mod; lazy[rt&lt;&lt;1][i] %= mod; }}void update(int op,ll c,ll L,ll R,ll l,ll r,ll rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ if(op==1){ sum[3][rt] += 1ll*3*sum[2][rt]*c%mod+1ll*3*sum[1][rt]*c%mod*c%mod+c*c%mod*c%mod*(r-l+1)%mod; sum[2][rt] += sum[1][rt]%mod*c%mod*2%mod+c*c%mod*(r-l+1)%mod; sum[1][rt] += 1ll*(r-l+1)*c%mod; lazy[rt][1] += c; lazy[rt][1] %= mod; }else if(op==2){ rep(i,1,4) sum[i][rt] *= pp[c][i]; lazy[rt][2] *= c; lazy[rt][2] %= mod; lazy[rt][1] *= c; lazy[rt][1] %= mod; }else{ rep(i,1,4) sum[i][rt] = pp[c][i]*(r-l+1)%mod; lazy[rt][3] = c; lazy[rt][1] = 0;lazy[rt][2] = 1; } rep(i,1,4) sum[i][rt] %= mod; return; } pushdown(rt,r-l+1); int mid = l+r&gt;&gt;1; if(L&lt;=mid) update(op,c,L,R,lson); if(mid&lt;R) update(op,c,L,R,rson); pushup(rt);}ll query(int op,int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ return sum[op][rt]; } pushdown(rt,r-l+1); int mid = l+r&gt;&gt;1; ll ans = 0; if(L&lt;=mid) (ans += query(op,L,R,lson)%mod)%=mod; if(mid&lt;R) (ans += query(op,L,R,rson)%mod)%mod; pushup(rt); return ans%mod;}int main(){#ifdef LOCAL freopen(&quot;2.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);#endif rep(i,1,mod+1) pp[i][1] = i%mod; rep(i,1,mod+1){ rep(j,2,4){ pp[i][j] = (ll)pp[i][j-1]*i%mod; } } while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){ init(); rep(i,0,m){ int op;read(op); read(x);read(y);read(val); if(op==4){ printf(&quot;%lld\\n&quot;,query(val,x,y,1,n,1)); }else{ update(op,val,x,y,1,n,1); } } }#ifdef LOCAL fclose(stdin); fclose(stdout);#endif return 0;} L - Vases and Flowers题意做过 在我之前博客里面有。 题解做过 +2 忘记掉可能初始不能放在A点，所以要加入一个全局变量flag，初始化maxl。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n,now,maxl,maxr,flag;const int maxn = 5e4+20;int sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2];void pushup(int rt){ sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1];}void pushdown(int rt,int len){ if(lazy[rt] != -1){ lazy[rt&lt;&lt;1] = lazy[rt&lt;&lt;1|1] = lazy[rt]; sum[rt&lt;&lt;1] = lazy[rt]*(len-len/2); sum[rt&lt;&lt;1|1] = lazy[rt]*(len/2); lazy[rt] = -1; }}void build(int l,int r,int rt){ lazy[rt] = -1; if(l==r){ sum[rt] = 0; return; } int mid = l+r&gt;&gt;1; build(lson); build(rson); pushup(rt);}void update1(int p,int l,int r,int rt){ if(now == 0) return; int len = r-l+1; if(sum[rt] == len) return; if(l&gt;=p &amp;&amp; sum[rt] == 0 &amp;&amp; len &lt;= now){ now -= len; sum[rt] = len; lazy[rt] = 1; if(flag == 0) maxl = l,flag = 1; maxr = max(maxr,r); return; } pushdown(rt,len); int mid = l+r&gt;&gt;1; if(p&lt;=mid) update1(p,lson); update1(p,rson); pushup(rt);}int query(int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ lazy[rt] = 0; int temp = sum[rt]; sum[rt] = 0; return temp; } pushdown(rt,r-l+1); int mid = l+r&gt;&gt;1; int ans = 0; if(L&lt;=mid) ans += query(L,R,lson); if(mid&lt;R) ans += query(L,R,rson); pushup(rt); return ans;}int main(){#ifdef LOCAL freopen(&quot;l.in&quot;,&quot;r&quot;,stdin);#endif int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); build(1,n,1); rep(i,0,m){ int op,x,y;scanf(&quot;%d%d%d&quot;,&amp;op,&amp;x,&amp;y); x++; if(op==1){ now = y; maxl = x;maxr = x;flag = 0; update1(x,1,n,1); if(now == y) puts(&quot;Can not put any one.&quot;); else printf(&quot;%d %d\\n&quot;,maxl-1,maxr-1); }else{ y++; printf(&quot;%d\\n&quot;,query(x,y,1,n,1)); } } puts(&quot;&quot;); } return 0;} M - 约会安排题意对每一次查询寻找$val$长度的最前面空闲时间并占据他。 如果是女神来查询，那么空闲的时间也包括基友的时间 如果是基友来查询，那么只有空闲的时间可以选择 如果想要学习$[l,r]$，那么$[l,r]$之间的时间都会被清空。 题解线段树的区间合并。 这里由于要维护两个线段树，所以用结构体来构造树，不过确实使用结构体封装之后复用性高了很多。 定义三个量$ll,rr,mm$分别表示从区间$[L,R]$最左边开始的最长长度和从区间最右边开始的最长长度和区间内横跨中点的最长长度。 定义$maxlen$来表示区间内最长的长度来剪枝。 这样就可以更新了。 一棵树代表屌丝+女神占有的，一棵树代表女神占有的。 查询分为三种方向 先查询左边开始的长度是否大于$val$，如果大于返回$L$，或者是递归左子树。 再查询中间的部分长度是否大于$val$，如果大于返回$mid-rr[lc]+1$就是中点减掉从左半部分右边的长度。 再查询递归右子树。 +1 区间合并中 更新父节点必须每个都更新，所以有时候你在return 之前也要更新一下。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1typedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//head ----------------------------------------const int maxn = 1e6+20;int T,n,m;struct sgt{ int maxlen[maxn&lt;&lt;2]; int ll[maxn&lt;&lt;2],rr[maxn&lt;&lt;2],mm[maxn&lt;&lt;2]; int lazy[maxn&lt;&lt;2]; void build(int l,int r,int rt){ lazy[rt] = -1; if(l==r){ ll[rt] = rr[rt] = 0; mm[rt] = 1; return; } int mid = l+r&gt;&gt;1; build(lson); build(rson); } void init(){ lazy[1] = 1; } void pushup(int l,int r,int rt){ if(lazy[rt]&gt;=0){ maxlen[rt] = ll[rt] = rr[rt] = mm[rt] = (lazy[rt]?(r-l+1):0); }else{ int lc = rt&lt;&lt;1,rc = rt&lt;&lt;1|1,mid = l+r&gt;&gt;1; ll[rt] = ll[lc]; if(ll[lc]==(mid-l+1)) ll[rt] += ll[rc]; mm[rt] = rr[lc] + ll[rc]; rr[rt] = rr[rc]; if(rr[rc] == r-mid) rr[rt] += rr[lc]; maxlen[rt] = max(maxlen[lc],max(maxlen[rc],mm[rt])); } } void pushdown(int rt){ if(lazy[rt]&gt;=0){ int lc=rt&lt;&lt;1,rc=rt&lt;&lt;1|1; lazy[lc] = lazy[rc] = lazy[rt]; lazy[rt] = -1; } } int query(int val,int l,int r,int rt){ pushup(l,r,rt); //cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;' '&lt;&lt;&quot; &quot;; int lc = rt&lt;&lt;1,rc = rt&lt;&lt;1|1,mid = l+r&gt;&gt;1; if(val&gt;maxlen[rt]) return 0; if(ll[rt] &gt;= val) return l; pushdown(rt); pushup(rson); int temp = query(val,lson); if(temp) return temp; if(mm[rt] &gt;= val) return mid-rr[lc]+1; return query(val,rson); } void update(int val,int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ lazy[rt] = val; pushup(l,r,rt); return; } pushdown(rt); int mid = l+r&gt;&gt;1; if(L&lt;=mid) update(val,L,R,lson); else pushup(lson); if(mid&lt;R) update(val,L,R,rson); else pushup(rson); pushup(l,r,rt); }}all,ns;char op[20];int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif scanf(&quot;%d&quot;,&amp;T); rep(test_case,1,T+1){ printf(&quot;Case %d:\\n&quot;,test_case); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); //all.build(1,n,1); ns.build(1,n,1); all.init(); ns.init(); while(m--){ scanf(&quot;%s&quot;,op); if(op[0]=='D'){ int x;scanf(&quot;%d&quot;,&amp;x); int ans = all.query(x,1,n,1); if(ans){ all.update(0,ans,ans+x-1,1,n,1); printf(&quot;%d,let's fly\\n&quot;,ans); }else{ puts(&quot;fly with yourself&quot;); } }else if(op[0]=='N'){ int x;scanf(&quot;%d&quot;,&amp;x); int ans = all.query(x,1,n,1); if(!ans) ans = ns.query(x,1,n,1); if(ans){ all.update(0,ans,ans+x-1,1,n,1); ns.update(0,ans,ans+x-1,1,n,1); printf(&quot;%d,don't put my gezi\\n&quot;,ans); }else{ puts(&quot;wait for me&quot;); } }else{ int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); all.update(1,x,y,1,n,1); ns.update(1,x,y,1,n,1); puts(&quot;I am the hope of chinese chengxuyuan!!&quot;); } } } return 0;} Reference:https://www.cnblogs.com/DSChan/p/4861977.html N.picture题意求多个矩形周长的并 题解扫描线+线段树 这道题目没有离散化$X$坐标就可以做。而且例子也只有一个。。 ac代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,a,n) for(int i=(n-1);i&gt;=(a);i--)#define fi first#define se second#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define pb push_backtypedef pair &lt;int,int&gt; pII;typedef long long ll;const int INF = 0x3f3f3f3f;//headint n;const int maxn = 2e4+100;struct node{ int lx,rx,y; int f; node(){} node(int _lx,int _rx,int _y,int _f){ lx = _lx; rx = _rx; y = _y; f = _f; } bool operator&lt;(const node &amp;s) const{ return y&lt;s.y; }}L[maxn&lt;&lt;2];int sum[maxn&lt;&lt;2],lb[maxn&lt;&lt;2],rb[maxn&lt;&lt;2],seg[maxn&lt;&lt;2];int flag[maxn&lt;&lt;2];void pushup(int rt,int l,int r){ if(flag[rt]){ sum[rt] = r-l+1; lb[rt] = rb[rt] = 1; seg[rt] = 2; }else if(l==r){ sum[rt] = lb[rt] = rb[rt] = seg[rt] = 0; }else{ sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1]; lb[rt] = lb[rt&lt;&lt;1]; rb[rt] = rb[rt&lt;&lt;1|1]; seg[rt] = seg[rt&lt;&lt;1] + seg[rt&lt;&lt;1|1]; if(lb[rt&lt;&lt;1|1]&amp;&amp;rb[rt&lt;&lt;1]) seg[rt]-=2; }}void update(int val,int L,int R,int l,int r,int rt){ if(L&lt;=l &amp;&amp; r&lt;=R){ flag[rt] += val; }else{ int mid = l+r&gt;&gt;1; if(L&lt;=mid) update(val,L,R,lson); if(mid&lt;R) update(val,L,R,rson); } pushup(rt,l,r);}int main(){#ifdef LOCAL freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);#endif while(~scanf(&quot;%d&quot;,&amp;n)){ int cnt = 0; int maxl = INF; int maxr = -INF; rep(i,0,n){ int x1,y1,x2,y2; scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2); L[++cnt] = node(x1,x2,y1,1); L[++cnt] = node(x1,x2,y2,-1); maxl = min(maxl,x1); maxr = max(maxr,x2); } sort(L+1,L+1+cnt); int res = 0; int last = 0; rep(i,1,cnt+1){ update(L[i].f,L[i].lx,L[i].rx-1,maxl,maxr,1); res += abs(sum[1]-last); res += seg[1] * (L[i+1].y-L[i].y); last = sum[1]; } printf(&quot;%d\\n&quot;,res); } return 0;}","link":"/acm/2018/09/06/kuangbin%E5%B8%A6%E4%BD%A0%E9%A3%9E7-%E7%BA%BF%E6%AE%B5%E6%A0%91.html"},{"title":"计算几何模板","text":"J .Distance to work题意懒得看了 题解计算几何。 扒一扒dls的板子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354typedef double db;const db EPS = 1e-9; inline int sign(db a) { return a &lt; -EPS ? -1 : a &gt; EPS; } inline int cmp(db a, db b){ return sign(a-b); } struct P { db x, y; P() {} P(db _x, db _y) : x(_x), y(_y) {} P operator+(P p) { return {x + p.x, y + p.y}; } P operator-(P p) { return {x - p.x, y - p.y}; } P operator*(db d) { return {x * d, y * d}; } P operator/(db d) { return {x / d, y / d}; } bool operator&lt;(P p) const { int c = cmp(x, p.x); if (c) return c == -1; return cmp(y, p.y) == -1; } bool operator==(P o) const{ return cmp(x,o.x) == 0 &amp;&amp; cmp(y,o.y) == 0; } db dot(P p) { return x * p.x + y * p.y; } db det(P p) { return x * p.y - y * p.x; } db distTo(P p) { return (*this-p).abs(); } db alpha() { return atan2(y, x); } void read() { cin&gt;&gt;x&gt;&gt;y; } void write() {cout&lt;&lt;&quot;(&quot;&lt;&lt;x&lt;&lt;&quot;,&quot;&lt;&lt;y&lt;&lt;&quot;)&quot;&lt;&lt;endl;} db abs() { return sqrt(abs2());} db abs2() { return x * x + y * y; } P rot90() { return P(-y,x);} P unit() { return *this/abs(); } int quad() const { return sign(y) == 1 || (sign(y) == 0 &amp;&amp; sign(x) &gt;= 0); } P rot(db an){ return {x*cos(an)-y*sin(an),x*sin(an) + y*cos(an)}; }}; struct L{ //ps[0] -&gt; ps[1] P ps[2]; L() {} L(P p1,P p2) { ps[0]=p1; ps[1]=p2; } P&amp; operator[](int i) { return ps[i]; } P dir() { return ps[1] - ps[0]; } bool include(P p) { return sign((ps[1] - ps[0]).det(p - ps[0])) &gt; 0; } L push(){ // push eps outward const double eps = 1e-6; P delta = (ps[1] - ps[0]).rot90().unit() * eps; return L(ps[0] - delta, ps[1] - delta); }}; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3)) bool chkLL(P p1, P p2, P q1, P q2) { db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2); return sign(a1+a2) != 0;} P isLL(P p1, P p2, P q1, P q2) { db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2); return (p1 * a2 + p2 * a1) / (a1 + a2);} P isLL(L l1,L l2){ return isLL(l1[0],l1[1],l2[0],l2[1]); } bool intersect(db l1,db r1,db l2,db r2){ if(l1&gt;r1) swap(l1,r1); if(l2&gt;r2) swap(l2,r2); return !( cmp(r1,l2) == -1 || cmp(r2,l1) == -1 );} bool isSS(P p1, P p2, P q1, P q2){ return intersect(p1.x,p2.x,q1.x,q2.x) &amp;&amp; intersect(p1.y,p2.y,q1.y,q2.y) &amp;&amp; crossOp(p1,p2,q1) * crossOp(p1,p2,q2) &lt;= 0 &amp;&amp; crossOp(q1,q2,p1) * crossOp(q1,q2,p2) &lt;= 0;} bool isSS_strict(P p1, P p2, P q1, P q2){ return crossOp(p1,p2,q1) * crossOp(p1,p2,q2) &lt; 0 &amp;&amp; crossOp(q1,q2,p1) * crossOp(q1,q2,p2) &lt; 0;} bool isMiddle(db a, db m, db b) { return sign(a - m) == 0 || sign(b - m) == 0 || (a &lt; m != b &lt; m);} bool isMiddle(P a, P m, P b) { return isMiddle(a.x, m.x, b.x) &amp;&amp; isMiddle(a.y, m.y, b.y);} bool onSeg(P p1, P p2, P q){ return crossOp(p1,p2,q) == 0 &amp;&amp; isMiddle(p1, q, p2);} bool onSeg_strict(P p1, P p2, P q){ return crossOp(p1,p2,q) == 0 &amp;&amp; sign((q-p1).dot(p1-p2)) * sign((q-p2).dot(p1-p2)) &lt; 0;} P proj(P p1, P p2, P q) { P dir = p2 - p1; return p1 + dir * (dir.dot(q - p1) / dir.abs2());} P reflect(P p1, P p2, P q){ return proj(p1,p2,q) * 2 - q;} db nearest(P p1,P p2,P q){ P h = proj(p1,p2,q); if(isMiddle(p1,h,p2)) return q.distTo(h); return min(p1.distTo(q),p2.distTo(q));} db disSS(P p1, P p2, P q1, P q2){ if(isSS(p1,p2,q1,q2)) return 0; return min(min(nearest(p1,p2,q1),nearest(p1,p2,q2)), min(nearest(q1,q2,p1),nearest(q1,q2,p2)));} db rad(P p1,P p2){ return atan2l(p1.det(p2),p1.dot(p2));} db incircle(P p1, P p2, P p3){ db A = p1.distTo(p2); db B = p2.distTo(p3); db C = p3.distTo(p1); return sqrtl(A*B*C/(A+B+C));} //polygon 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970db area(vector&lt;P&gt; ps){ db ret = 0; rep(i,0,ps.size()) ret += ps[i].det(ps[(i+1)%ps.size()]); return ret/2;} int contain(vector&lt;P&gt; ps, P p){ //2:inside,1:on_seg,0:outside int n = ps.size(), ret = 0; rep(i,0,n){ P u=ps[i],v=ps[(i+1)%n]; if(onSeg(u,v,p)) return 1; if(cmp(u.y,v.y)&lt;=0) swap(u,v); if(cmp(p.y,u.y) &gt;0 || cmp(p.y,v.y) &lt;= 0) continue; ret ^= crossOp(p,u,v) &gt; 0; } return ret*2;} vector&lt;P&gt; convexHull(vector&lt;P&gt; ps) { int n = ps.size(); if(n &lt;= 1) return ps; sort(ps.begin(), ps.end()); vector&lt;P&gt; qs(n * 2); int k = 0; for (int i = 0; i &lt; n; qs[k++] = ps[i++]) while (k &gt; 1 &amp;&amp; crossOp(qs[k - 2], qs[k - 1], ps[i]) &lt;= 0) --k; for (int i = n - 2, t = k; i &gt;= 0; qs[k++] = ps[i--]) while (k &gt; t &amp;&amp; crossOp(qs[k - 2], qs[k - 1], ps[i]) &lt;= 0) --k; qs.resize(k - 1); return qs;} vector&lt;P&gt; convexHullNonStrict(vector&lt;P&gt; ps) { //caution: need to unique the Ps first int n = ps.size(); if(n &lt;= 1) return ps; sort(ps.begin(), ps.end()); vector&lt;P&gt; qs(n * 2); int k = 0; for (int i = 0; i &lt; n; qs[k++] = ps[i++]) while (k &gt; 1 &amp;&amp; crossOp(qs[k - 2], qs[k - 1], ps[i]) &lt; 0) --k; for (int i = n - 2, t = k; i &gt;= 0; qs[k++] = ps[i--]) while (k &gt; t &amp;&amp; crossOp(qs[k - 2], qs[k - 1], ps[i]) &lt; 0) --k; qs.resize(k - 1); return qs;} db convexDiameter(vector&lt;P&gt; ps){ int n = ps.size(); if(n &lt;= 1) return 0; int is = 0, js = 0; rep(k,1,n) is = ps[k]&lt;ps[is]?k:is, js = ps[js] &lt; ps[k]?k:js; int i = is, j = js; db ret = ps[i].distTo(ps[j]); do{ if((ps[(i+1)%n]-ps[i]).det(ps[(j+1)%n]-ps[j]) &gt;= 0) (++j)%=n; else (++i)%=n; ret = max(ret,ps[i].distTo(ps[j])); }while(i!=is || j!=js); return ret;} vector&lt;P&gt; convexCut(const vector&lt;P&gt;&amp;ps, P q1, P q2) { vector&lt;P&gt; qs; int n = ps.size(); rep(i,0,n){ P p1 = ps[i], p2 = ps[(i+1)%n]; int d1 = crossOp(q1,q2,p1), d2 = crossOp(q1,q2,p2); if(d1 &gt;= 0) qs.pb(p1); if(d1 * d2 &lt; 0) qs.pb(isLL(p1,p2,q1,q2)); } return qs;} //min_dist 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146db min_dist(vector&lt;P&gt;&amp;ps,int l,int r){ if(r-l&lt;=5){ db ret = 1e100; rep(i,l,r) rep(j,l,i) ret = min(ret,ps[i].distTo(ps[j])); return ret; } int m = (l+r)&gt;&gt;1; db ret = min(min_dist(ps,l,m),min_dist(ps,m,r)); vector&lt;P&gt; qs; rep(i,l,r) if(abs(ps[i].x-ps[m].x)&lt;= ret) qs.pb(ps[i]); sort(qs.begin(), qs.end(),[](P a,P b) -&gt; bool {return a.y&lt;b.y; }); rep(i,1,qs.size()) for(int j=i-1;j&gt;=0&amp;&amp;qs[j].y&gt;=qs[i].y-ret;--j) ret = min(ret,qs[i].distTo(qs[j])); return ret;} int type(P o1,db r1,P o2,db r2){ db d = o1.distTo(o2); if(cmp(d,r1+r2) == 1) return 4; if(cmp(d,r1+r2) == 0) return 3; if(cmp(d,abs(r1-r2)) == 1) return 2; if(cmp(d,abs(r1-r2)) == 0) return 1; return 0;} vector&lt;P&gt; isCL(P o,db r,P p1,P p2){ db x = (p1-o).dot(p2-p1), y = (p2-p1).abs2(), d = x * x - y * ((p1-o).abs2() - r*r); if(sign(d) &lt; 0) return {}; d = max(d,0.0); P m = p1 - (p2-p1)*(x/y), dr = (p2-p1)*(sqrt(d)/y); return {m-dr,m+dr}; //along dir: p1-&gt;p2} vector&lt;P&gt; isCC(P o1, db r1, P o2, db r2) { //need to check whether two circles are the same db d = o1.distTo(o2); if (cmp(d, r1 + r2) == 1) return {}; if (cmp(d,abs(r1-r2))==-1) return {}; d = min(d, r1 + r2); db y = (r1 * r1 + d * d - r2 * r2) / (2 * d), x = sqrt(r1 * r1 - y * y); P dr = (o2 - o1).unit(); P q1 = o1 + dr * y, q2 = dr.rot90() * x; return {q1-q2,q1+q2};//along circle 1} vector&lt;P&gt; tanCP(P o, db r, P p) { db x = (p - o).abs2(), d = x - r * r; if (sign(d) &lt;= 0) return {}; // on circle =&gt; no tangent P q1 = o + (p - o) * (r * r / x); P q2 = (p - o).rot90() * (r * sqrt(d) / x); return {q1-q2,q1+q2}; //counter clock-wise} vector&lt;L&gt; extanCC(P o1, db r1, P o2, db r2) { vector&lt;L&gt; ret; if (cmp(r1, r2) == 0) { P dr = (o2 - o1).unit().rot90() * r1; ret.pb(L(o1 + dr, o2 + dr)), ret.pb(L(o1 - dr, o2 - dr)); } else { P p = (o2 * r1 - o1 * r2) / (r1 - r2); vector&lt;P&gt; ps = tanCP(o1, r1, p), qs = tanCP(o2, r2, p); rep(i,0,min(ps.size(),qs.size())) ret.pb(L(ps[i], qs[i])); //c1 counter-clock wise } return ret;} vector&lt;L&gt; intanCC(P o1, db r1, P o2, db r2) { vector&lt;L&gt; ret; P p = (o1 * r2 + o2 * r1) / (r1 + r2); vector&lt;P&gt; ps = tanCP(o1,r1,p), qs = tanCP(o2,r2,p); rep(i,0,min(ps.size(),qs.size())) ret.pb(L(ps[i], qs[i])); //c1 counter-clock wise return ret;} db areaCT(db r, P p1, P p2){ vector&lt;P&gt; is = isCL(P(0,0),r,p1,p2); if(is.empty()) return r*r*rad(p1,p2)/2; bool b1 = cmp(p1.abs2(),r*r) == 1, b2 = cmp(p2.abs2(), r*r) == 1; if(b1 &amp;&amp; b2){ if(sign((p1-is[0]).dot(p2-is[0])) &lt;= 0 &amp;&amp; sign((p1-is[0]).dot(p2-is[0])) &lt;= 0) return r*r*(rad(p1,is[0]) + rad(is[1],p2))/2 + is[0].det(is[1])/2; else return r*r*rad(p1,p2)/2; } if(b1) return (r*r*rad(p1,is[0]) + is[0].det(p2))/2; if(b2) return (p1.det(is[1]) + r*r*rad(is[1],p2))/2; return p1.det(p2)/2;} bool parallel(L l0, L l1) { return sign( l0.dir().det( l1.dir() ) ) == 0; } bool sameDir(L l0, L l1) { return parallel(l0, l1) &amp;&amp; sign(l0.dir().dot(l1.dir()) ) == 1; } bool cmp (P a, P b) { if (a.quad() != b.quad()) { return a.quad() &lt; b.quad(); } else { return sign( a.det(b) ) &gt; 0; }} bool operator &lt; (L l0, L l1) { if (sameDir(l0, l1)) { return l1.include(l0[0]); } else { return cmp( l0.dir(), l1.dir() ); }} bool check(L u, L v, L w) { return w.include(isLL(u,v));} vector&lt;P&gt; halfPlaneIS(vector&lt;L&gt; &amp;l) { sort(l.begin(), l.end()); deque&lt;L&gt; q; for (int i = 0; i &lt; (int)l.size(); ++i) { if (i &amp;&amp; sameDir(l[i], l[i - 1])) continue; while (q.size() &gt; 1 &amp;&amp; !check(q[q.size() - 2], q[q.size() - 1], l[i])) q.pop_back(); while (q.size() &gt; 1 &amp;&amp; !check(q[1], q[0], l[i])) q.pop_front(); q.push_back(l[i]); } while (q.size() &gt; 2 &amp;&amp; !check(q[q.size() - 2], q[q.size() - 1], q[0])) q.pop_back(); while (q.size() &gt; 2 &amp;&amp; !check(q[1], q[0], q[q.size() - 1])) q.pop_front(); vector&lt;P&gt; ret; for (int i = 0; i &lt; (int)q.size(); ++i) ret.push_back(isLL(q[i], q[(i + 1) % q.size()])); return ret;} P inCenter(P A, P B, P C) { double a = (B - C).abs(), b = (C - A).abs(), c = (A - B).abs(); return (A * a + B * b + C * c) / (a + b + c);} P circumCenter(P a, P b, P c) { P bb = b - a, cc = c - a; double db = bb.abs2(), dc = cc.abs2(), d = 2 * bb.det(cc); return a - P(bb.y * dc - cc.y * db, cc.x * db - bb.x * dc) / d;} P othroCenter(P a, P b, P c) { P ba = b - a, ca = c - a, bc = b - c; double Y = ba.y * ca.y * bc.y, A = ca.x * ba.y - ba.x * ca.y, x0 = (Y + ca.x * ba.y * b.x - ba.x * ca.y * c.x) / A, y0 = -ba.x * (x0 - c.x) / ba.y + ca.y; return {x0, y0};} AC代码（别人家的模板。）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866#include &lt;bits/stdc++.h&gt;using namespace std; // 计算几何模板#define REP(i, x, n) for (int i = x; i &lt; n; ++i)const double eps = 1e-8;const double inf = 1e20;const double pi = acos(-1.0);const int maxp = 1010;// Compares a double to zeroint sgn(double x) { if (fabs(x) &lt; eps) return 0; if (x &lt; 0) return -1; else return 1;}// square of a doubleinline double sqr(double x) { return x * x;}/*15 * Point16 * Point() - Empty constructor17 * Point(double _x,double _y) - constructor18 * input() - double input19 * output() - %.2f output20 * operator == - compares x and y21 * operator &lt; - compares first by x, then by y22 * operator - - return new Point after subtractingcurresponging x and y23 * operator ^ - cross product of 2d points24 * operator * - dot product25 * len() - gives length from origin26 * len2() - gives square of length from origin27 * distance(Point p) - gives distance from p28 * operator + Point b - returns new Point after addingcurresponging x and y29 * operator * double k - returns new Point after multiplieing x andy by k30 * operator / double k - returns new Point after divideing x and yby k31 * rad(Point a,Point b) - returns the angle of Point a and Point bfrom this Point32 * trunc(double r) - return Point that if truncated thedistance from center to r33 * rotleft() - returns 90 degree ccw rotated point34 * rotright() - returns 90 degree cw rotated point35 * rotate(Point p,double angle) - returns Point after rotateing thePoint centering at p by angle radian ccw36 */struct Point { double x, y; Point() {} Point(double _x, double _y) { x = _x; y = _y; } void input() { scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y); } void output() { printf(&quot;%.2f␣%.2f\\n&quot;, x, y); } bool operator==(Point b) const { return sgn(x - b.x) == 0 &amp;&amp; sgn(y - b.y) == 0; } bool operator&lt;(Point b) const { return sgn(x - b.x) == 0 ? sgn(y - b.y) &lt; 0 : x &lt; b.x; } Point operator-(const Point &amp;b) const { return Point(x - b.x, y - b.y); } //叉积 double operator^(const Point &amp;b) const { return x * b.y - y * b.x; } //点积 double operator*(const Point &amp;b) const { return x * b.x + y * b.y; } //返回长度 double len() { return hypot(x, y); //库函数 } //返回长度的平方 double len2() { return x * x + y * y; } //返回两点的距离 double distance(Point p) { return hypot(x - p.x, y - p.y); } Point operator+(const Point &amp;b) const { return Point(x + b.x, y + b.y); } Point operator*(const double &amp;k) const { return Point(x * k, y * k); } Point operator/(const double &amp;k) const { return Point(x / k, y / k); } //计算 pa 和 pb 的夹角 //就是求这个点看 a,b 所成的夹角 //测试 LightOJ1203 double rad(Point a, Point b) { Point p = *this; return fabs(atan2(fabs((a - p) ^ (b - p)), (a - p) * (b - p))); } //化为长度为 r 的向量 Point trunc(double r) { double l = len(); if (!sgn(l)) return *this; r /= l; return Point(x * r, y * r); } //逆时针旋转 90 度 Point rotleft() { return Point(-y, x); } //顺时针旋转 90 度 Point rotright() { return Point(y, -x); } //绕着 p 点逆时针旋转 angle Point rotate(Point p, double angle) { Point v = (*this) - p; double c = cos(angle), s = sin(angle); return Point(p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c); }};/* * Stores two points * Line() - Empty constructor * Line(Point _s,Point _e) - Line through _s and _e * operator == - checks if two points are same * Line(Point p,double angle) - one end p , another end at angle degree * Line(double a,double b,double c) - Line of equation ax + by + c = 0 * input() - inputs s and e * adjust() - orders in such a way that s &lt; e * length() - distance of se * angle() - return 0 &lt;= angle &lt; pi * relation(Point p) - 3 if point is on line * 1 if point on the left of line * 2 if point on the right of line * pointonseg(double p) - return true if point on segment * parallel(Line v) - return true if they are parallel * segcrossseg(Line v) - returns 0 if does not intersect * returns 1 if non - standard intersection * returns 2 if intersects * linecrossseg(Line v) - line and seg * linecrossline(Line v) - 0 if parallel * 1 if coincides * 2 if intersects * crosspoint(Line v) - returns intersection point * dispointtoline(Point p) - distance from point p to the line * dispointtoseg(Point p) - distance from p to the segment * dissegtoseg(Line v) - distance of two segment * lineprog(Point p) - returns projected point p on se line * symmetrypoint(Point p) - returns reflection point of p over se * */struct Line { Point s, e; Line() {} Line(Point _s, Point _e) { s = _s; e = _e; } bool operator==(Line v) { return (s == v.s) &amp;&amp; (e == v.e); } //根据一个点和倾斜角 angle 确定直线,0&lt;=angle&lt;pi Line(Point p, double angle) { s = p; if (sgn(angle - pi / 2) == 0) { e = (s + Point(0, 1)); } else { e = (s + Point(1, tan(angle))); } } // ax+by+c=0 Line(double a, double b, double c) { if (sgn(a) == 0) { s = Point(0, -c / b); e = Point(1, -c / b); } else if (sgn(b) == 0) { s = Point(-c / a, 0); e = Point(-c / a, 1); } else { s = Point(0, -c / b); e = Point(1, (-c - a) / b); } } void input() { s.input(); e.input(); } void adjust() { if (e &lt; s) swap(s, e); } //求线段长度 double length() { return s.distance(e); } //返回直线倾斜角 0&lt;=angle&lt;pi double angle() { double k = atan2(e.y - s.y, e.x - s.x); if (sgn(k) &lt; 0) k += pi; if (sgn(k - pi) == 0) k -= pi; return k; } //点和直线关系 // 1 在左侧 // 2 在右侧 // 3 在直线上 int relation(Point p) { int c = sgn((p - s) ^ (e - s)); if (c &lt; 0) return 1; else if (c &gt; 0) return 2; else return 3; } // 点在线段上的判断 bool pointonseg(Point p) { return sgn((p - s) ^ (e - s)) == 0 &amp;&amp; sgn((p - s) * (p - e)) &lt;= 0; } //两向量平行 (对应直线平行或重合) bool parallel(Line v) { return sgn((e - s) ^ (v.e - v.s)) == 0; } //两线段相交判断 // 2 规范相交 // 1 非规范相交 // 0 不相交 int segcrossseg(Line v) { int d1 = sgn((e - s) ^ (v.s - s)); int d2 = sgn((e - s) ^ (v.e - s)); int d3 = sgn((v.e - v.s) ^ (s - v.s)); int d4 = sgn((v.e - v.s) ^ (e - v.s)); if ((d1 ^ d2) == -2 &amp;&amp; (d3 ^ d4) == -2) return 2; return (d1 == 0 &amp;&amp; sgn((v.s - s) * (v.s - e)) &lt;= 0) || (d2 == 0 &amp;&amp; sgn((v.e - s) * (v.e - e)) &lt;= 0) || (d3 == 0 &amp;&amp; sgn((s - v.s) * (s - v.e)) &lt;= 0) || (d4 == 0 &amp;&amp; sgn((e - v.s) * (e - v.e)) &lt;= 0); } //直线和线段相交判断 //-*this line -v seg // 2 规范相交 // 1 非规范相交 // 0 不相交 int linecrossseg(Line v) { int d1 = sgn((e - s) ^ (v.s - s)); int d2 = sgn((e - s) ^ (v.e - s)); if ((d1 ^ d2) == -2) return 2; return (d1 == 0 || d2 == 0); } //两直线关系 // 0 平行 // 1 重合 // 2 相交 int linecrossline(Line v) { if ((*this).parallel(v)) return v.relation(s) == 3; return 2; } //求两直线的交点 //要保证两直线不平行或重合 Point crosspoint(Line v) { double a1 = (v.e - v.s) ^ (s - v.s); double a2 = (v.e - v.s) ^ (e - v.s); return Point((s.x * a2 - e.x * a1) / (a2 - a1), (s.y * a2 - e.y * a1) / (a2 - a1)); } //点到直线的距离 double dispointtoline(Point p) { return fabs((p - s) ^ (e - s)) / length(); } //点到线段的距离 double dispointtoseg(Point p) { if (sgn((p - s) * (e - s)) &lt; 0 || sgn((p - e) * (s - e)) &lt; 0) return min(p.distance(s), p.distance(e)); return dispointtoline(p); } //返回线段到线段的距离 //前提是两线段不相交，相交距离就是 0 了 double dissegtoseg(Line v) { return min(min(dispointtoseg(v.s), dispointtoseg(v.e)), min(v.dispointtoseg(s), v.dispointtoseg(e))); } //返回点 p 在直线上的投影 Point lineprog(Point p) { return s + (((e - s) * ((e - s) * (p - s))) / ((e - s).len2())); } //返回点 p 关于直线的对称点 Point symmetrypoint(Point p) { Point q = lineprog(p); return Point(2 * q.x - p.x, 2 * q.y - p.y); }};//struct circle { Point p; //圆心 double r; //半径 circle() {} circle(Point _p, double _r) { p = _p; r = _r; } circle(double x, double y, double _r) { p = Point(x, y); r = _r; } //三角形的外接圆 //需要 Point 的 + / rotate() 以及 Line 的 crosspoint() //利用两条边的中垂线得到圆心 //测试：UVA12304 circle(Point a, Point b, Point c) { Line u = Line((a + b) / 2, ((a + b) / 2) + ((b - a).rotleft())); Line v = Line((b + c) / 2, ((b + c) / 2) + ((c - b).rotleft())); p = u.crosspoint(v); r = p.distance(a); } //三角形的内切圆 //参数 bool t 没有作用，只是为了和上面外接圆函数区别 //测试：UVA12304 circle(Point a, Point b, Point c, bool t) { Line u, v; double m = atan2(b.y - a.y, b.x - a.x), n = atan2(c.y - a.y, c.x - a.x); u.s = a; u.e = u.s + Point(cos((n + m) / 2), sin((n + m) / 2)); v.s = b; m = atan2(a.y - b.y, a.x - b.x), n = atan2(c.y - b.y, c.x - b.x); v.e = v.s + Point(cos((n + m) / 2), sin((n + m) / 2)); p = u.crosspoint(v); r = Line(a, b).dispointtoseg(p); } //输入 void input() { p.input(); scanf(&quot;%lf&quot;, &amp;r); } //输出 void output() { printf(&quot;%.2lf␣%.2lf␣%.2lf\\n&quot;, p.x, p.y, r); } bool operator==(circle v) { return (p == v.p) &amp;&amp; sgn(r - v.r) == 0; } bool operator&lt;(circle v) const { return ((p &lt; v.p) || ((p == v.p) &amp;&amp; sgn(r - v.r) &lt; 0)); } //面积 double area() { return pi * r * r; } //周长 double circumference() { return 2 * pi * r; } //点和圆的关系 // 0 圆外 // 1 圆上 // 2 圆内 int relation(Point b) { double dst = b.distance(p); if (sgn(dst - r) &lt; 0) return 2; else if (sgn(dst - r) == 0) return 1; return 0; } //线段和圆的关系 //比较的是圆心到线段的距离和半径的关系 int relationseg(Line v) { double dst = v.dispointtoseg(p); if (sgn(dst - r) &lt; 0) return 2; else if (sgn(dst - r) == 0) return 1; return 0; } //直线和圆的关系 //比较的是圆心到直线的距离和半径的关系 int relationline(Line v) { double dst = v.dispointtoline(p); if (sgn(dst - r) &lt; 0) return 2; else if (sgn(dst - r) == 0) return 1; return 0; } //两圆的关系 // 5 相离 // 4 外切 // 3 相交 // 2 内切 // 1 内含 //需要 Point 的 distance //测试：UVA12304 int relationcircle(circle v) { double d = p.distance(v.p); if (sgn(d - r - v.r) &gt; 0) return 5; if (sgn(d - r - v.r) == 0) return 4; double l = fabs(r - v.r); if (sgn(d - r - v.r) &lt; 0 &amp;&amp; sgn(d - l) &gt; 0) return 3; if (sgn(d - l) == 0) return 2; if (sgn(d - l) &lt; 0) return 1; return 0; } //求两个圆的交点，返回 0 表示没有交点，返回 1 是一个交点，2 是两个交点 //需要 relationcircle //测试：UVA12304 int pointcrosscircle(circle v, Point &amp;p1, Point &amp;p2) { int rel = relationcircle(v); if (rel == 1 || rel == 5) return 0; double d = p.distance(v.p); double l = (d * d + r * r - v.r * v.r) / (2 * d); double h = sqrt(r * r - l * l); Point tmp = p + (v.p - p).trunc(l); p1 = tmp + ((v.p - p).rotleft().trunc(h)); p2 = tmp + ((v.p - p).rotright().trunc(h)); if (rel == 2 || rel == 4) return 1; return 2; } //求直线和圆的交点，返回交点个数 int pointcrossline(Line v, Point &amp;p1, Point &amp;p2) { if (!(*this).relationline(v)) return 0; Point a = v.lineprog(p); double d = v.dispointtoline(p); d = sqrt(r * r - d * d); if (sgn(d) == 0) { p1 = a; p2 = a; return 1; } p1 = a + (v.e - v.s).trunc(d); p2 = a - (v.e - v.s).trunc(d); return 2; } //得到过 a,b 两点，半径为 r1 的两个圆 int gercircle(Point a, Point b, double r1, circle &amp;c1, circle &amp;c2) { circle x(a, r1), y(b, r1); int t = x.pointcrosscircle(y, c1.p, c2.p); if (!t) return 0; c1.r = c2.r = r; return t; } //得到与直线 u 相切，过点 q, 半径为 r1 的圆 //测试：UVA12304 int getcircle(Line u, Point q, double r1, circle &amp;c1, circle &amp;c2) { double dis = u.dispointtoline(q); if (sgn(dis - r1 * 2) &gt; 0) return 0; if (sgn(dis) == 0) { c1.p = q + ((u.e - u.s).rotleft().trunc(r1)); c2.p = q + ((u.e - u.s).rotright().trunc(r1)); c1.r = c2.r = r1; return 2; } Line u1 = Line((u.s + (u.e - u.s).rotleft().trunc(r1)), (u.e + (u.e - u.s).rotleft().trunc(r1))); Line u2 = Line((u.s + (u.e - u.s).rotright().trunc(r1)), (u.e + (u.e - u.s).rotright().trunc(r1))); circle cc = circle(q, r1); Point p1, p2; if (!cc.pointcrossline(u1, p1, p2)) cc.pointcrossline(u2, p1, p2); c1 = circle(p1, r1); if (p1 == p2) { c2 = c1; return 1; } c2 = circle(p2, r1); return 2; } //同时与直线 u,v 相切，半径为 r1 的圆 //测试：UVA12304 int getcircle(Line u, Line v, double r1, circle &amp;c1, circle &amp;c2, circle &amp;c3, circle &amp;c4) { if (u.parallel(v)) return 0; //两直线平行 Line u1 = Line(u.s + (u.e - u.s).rotleft().trunc(r1), u.e + (u.e - u.s).rotleft().trunc(r1)); Line u2 = Line(u.s + (u.e - u.s).rotright().trunc(r1), u.e + (u.e - u.s).rotright().trunc(r1)); Line v1 = Line(v.s + (v.e - v.s).rotleft().trunc(r1), v.e + (v.e - v.s).rotleft().trunc(r1)); Line v2 = Line(v.s + (v.e - v.s).rotright().trunc(r1), v.e + (v.e - v.s).rotright().trunc(r1)); c1.r = c2.r = c3.r = c4.r = r1; c1.p = u1.crosspoint(v1); c2.p = u1.crosspoint(v2); c3.p = u2.crosspoint(v1); c4.p = u2.crosspoint(v2); return 4; } //同时与不相交圆 cx,cy 相切，半径为 r1 的圆 //测试：UVA12304 int getcircle(circle cx, circle cy, double r1, circle &amp;c1, circle &amp;c2) { circle x(cx.p, r1 + cx.r), y(cy.p, r1 + cy.r); int t = x.pointcrosscircle(y, c1.p, c2.p); if (!t) return 0; c1.r = c2.r = r1; return t; } //过一点作圆的切线 (先判断点和圆的关系) //测试：UVA12304 int tangentline(Point q, Line &amp;u, Line &amp;v) { int x = relation(q); if (x == 2) return 0; if (x == 1) { u = Line(q, q + (q - p).rotleft()); v = u; return 1; } double d = p.distance(q); double l = r * r / d; double h = sqrt(r * r - l * l); u = Line(q, p + ((q - p).trunc(l) + (q - p).rotleft().trunc(h))); v = Line(q, p + ((q - p).trunc(l) + (q - p).rotright().trunc(h))); return 2; } //求两圆相交的面积 double areacircle(circle v) { int rel = relationcircle(v); if (rel &gt;= 4) return 0.0; if (rel &lt;= 2) return min(area(), v.area()); double d = p.distance(v.p); double hf = (r + v.r + d) / 2.0; double ss = 2 * sqrt(hf * (hf - r) * (hf - v.r) * (hf - d)); double a1 = acos((r * r + d * d - v.r * v.r) / (2.0 * r * d)); a1 = a1 * r * r; double a2 = acos((v.r * v.r + d * d - r * r) / (2.0 * v.r * d)); a2 = a2 * v.r * v.r; return a1 + a2 - ss; } //求圆和三角形 pab 的相交面积 //测试：POJ3675 HDU3982 HDU2892 double areatriangle(Point a, Point b) { if (sgn((p - a) ^ (p - b)) == 0) return 0.0; Point q[5]; int len = 0; q[len++] = a; Line l(a, b); Point p1, p2; if (pointcrossline(l, q[1], q[2]) == 2) { if (sgn((a - q[1]) * (b - q[1])) &lt; 0) q[len++] = q[1]; if (sgn((a - q[2]) * (b - q[2])) &lt; 0) q[len++] = q[2]; } q[len++] = b; if (len == 4 &amp;&amp; sgn((q[0] - q[1]) * (q[2] - q[1])) &gt; 0) swap(q[1], q[2]); double res = 0; for (int i = 0; i &lt; len - 1; i++) { if (relation(q[i]) == 0 || relation(q[i + 1]) == 0) { double arg = p.rad(q[i], q[i + 1]); res += r * r * arg / 2.0; } else { res += fabs((q[i] - p) ^ (q[i + 1] - p)) / 2.0; } } return res; }}; /* * n,p Line l for each side * input(int _n) - inputs _n size polygon * add(Point q) - adds a point at end of the list * getline() - populates line array * cmp - comparision in convex_hull order * norm() - sorting in convex_hull order * getconvex(polygon &amp;convex) - returns convex hull in convex * Graham(polygon &amp;convex) - returns convex hull in convex * isconvex() - checks if convex * relationpoint(Point q) - returns 3 if q is a vertex * 2 if on a side * 1 if inside * 0 if outside * convexcut(Line u,polygon &amp;po) - left side of u in po * gercircumference() - returns side length * getarea() - returns area * getdir() - returns 0 for cw, 1 for ccw * getbarycentre() - returns barycenter * */ struct polygon { int n; Point p[maxp]; Line l[maxp]; void input(int _n) { n = _n; for (int i = 0; i &lt; n; i++) p[i].input(); } void add(Point q) { p[n++] = q; } void getline() { for (int i = 0; i &lt; n; i++) { l[i] = Line(p[i], p[(i + 1) % n]); } } struct cmp { Point p; cmp(const Point &amp;p0) { p = p0; } bool operator()(const Point &amp;aa, const Point &amp;bb) { Point a = aa, b = bb; int d = sgn((a - p) ^ (b - p)); if (d == 0) { return sgn(a.distance(p) - b.distance(p)) &lt; 0; } return d &gt; 0; } }; //进行极角排序 //首先需要找到最左下角的点 //需要重载号好 Point 的 &lt; 操作符 (min 函数要用) void norm() { Point mi = p[0]; for (int i = 1; i &lt; n; i++) mi = min(mi, p[i]); sort(p, p + n, cmp(mi)); } //得到凸包 //得到的凸包里面的点编号是 0 ∼ n-1 的 //两种凸包的方法 //注意如果有影响，要特判下所有点共点，或者共线的特殊情况 //测试 LightOJ1203 LightOJ1239 void getconvex(polygon &amp;convex) { sort(p, p + n); convex.n = n; for (int i = 0; i &lt; min(n, 2); i++) { convex.p[i] = p[i]; } if (convex.n == 2 &amp;&amp; (convex.p[0] == convex.p[1])) convex.n--; //特判 if (n &lt;= 2) return; int &amp;top = convex.n; top = 1; for (int i = 2; i &lt; n; i++) { while (top &amp;&amp; sgn((convex.p[top] - p[i]) ^ (convex.p[top - 1] - p[i])) &lt;= 0) top--; convex.p[++top] = p[i]; } int temp = top; convex.p[++top] = p[n - 2]; for (int i = n - 3; i &gt;= 0; i--) { while (top != temp &amp;&amp; sgn((convex.p[top] - p[i]) ^ (convex.p[top - 1] - p[i])) &lt;= 0) top--; convex.p[++top] = p[i]; } if (convex.n == 2 &amp;&amp; (convex.p[0] == convex.p[1])) convex.n--; //特判 convex.norm(); //原来得到的是顺时针的点，排序后逆时针 } //得到凸包的另外一种方法 //测试 LightOJ1203 LightOJ1239 void Graham(polygon &amp;convex) { norm(); int &amp;top = convex.n; top = 0; if (n == 1) { top = 1; convex.p[0] = p[0]; return; } if (n == 2) { top = 2; convex.p[0] = p[0]; convex.p[1] = p[1]; if (convex.p[0] == convex.p[1]) top--; return; } convex.p[0] = p[0]; convex.p[1] = p[1]; top = 2; for (int i = 2; i &lt; n; i++) { while (top &gt; 1 &amp;&amp; sgn((convex.p[top - 1] - convex.p[top - 2]) ^ (p[i] - convex.p[top - 2])) &lt;= 0) top--; convex.p[top++] = p[i]; } if (convex.n == 2 &amp;&amp; (convex.p[0] == convex.p[1])) convex.n--; //特判 } //判断是不是凸的 bool isconvex() { bool s[2]; memset(s, false, sizeof(s)); for (int i = 0; i &lt; n; i++) { int j = (i + 1) % n; int k = (j + 1) % n; s[sgn((p[j] - p[i]) ^ (p[k] - p[i])) + 1] = true; if (s[0] &amp;&amp; s[2]) return false; } return true; } //判断点和任意多边形的关系 // 3 点上 // 2 边上 // 1 内部 // 0 外部 int relationpoint(Point q) { for (int i = 0; i &lt; n; i++) { if (p[i] == q) return 3; } getline(); for (int i = 0; i &lt; n; i++) { if (l[i].pointonseg(q)) return 2; } int cnt = 0; for (int i = 0; i &lt; n; i++) { int j = (i + 1) % n; int k = sgn((q - p[j]) ^ (p[i] - p[j])); int u = sgn(p[i].y - q.y); int v = sgn(p[j].y - q.y); if (k &gt; 0 &amp;&amp; u &lt; 0 &amp;&amp; v &gt;= 0) cnt++; if (k &lt; 0 &amp;&amp; v &lt; 0 &amp;&amp; u &gt;= 0) cnt--; } return cnt != 0; } //直线 u 切割凸多边形左侧 //注意直线方向 //测试：HDU3982 void convexcut(Line u, polygon &amp;po) { int &amp;top = po.n; //注意引用 top = 0; for (int i = 0; i &lt; n; i++) { int d1 = sgn((u.e - u.s) ^ (p[i] - u.s)); int d2 = sgn((u.e - u.s) ^ (p[(i + 1) % n] - u.s)); if (d1 &gt;= 0) po.p[top++] = p[i]; if (d1 * d2 &lt; 0) po.p[top++] = u.crosspoint(Line(p[i], p[(i + 1) % n])); } } //得到周长 //测试 LightOJ1239 double getcircumference() { double sum = 0; for (int i = 0; i &lt; n; i++) { sum += p[i].distance(p[(i + 1) % n]); } return sum; } //得到面积面积 double getarea() { double sum = 0; for (int i = 0; i &lt; n; i++) { sum += (p[i] ^ p[(i + 1) % n]); } return fabs(sum) / 2; } //得到方向 // 1 表示逆时针，0 表示顺时针 bool getdir() { double sum = 0; for (int i = 0; i &lt; n; i++) sum += (p[i] ^ p[(i + 1) % n]); if (sgn(sum) &gt; 0) return 1; return 0; } //得到重心 Point getbarycentre() { Point ret(0, 0); double area = 0; for (int i = 1; i &lt; n - 1; i++) { double tmp = (p[i] - p[0]) ^ (p[i + 1] - p[0]); if (sgn(tmp) == 0) continue; area += tmp; ret.x += (p[0].x + p[i].x + p[i + 1].x) / 3 * tmp; ret.y += (p[0].y + p[i].y + p[i + 1].y) / 3 * tmp; } if (sgn(area)) ret = ret / area; return ret; } //多边形和圆交的面积 //测试：POJ3675 HDU3982 HDU2892 double areacircle(circle c) { double ans = 0; for (int i = 0; i &lt; n; i++) { int j = (i + 1) % n; if (sgn((p[j] - c.p) ^ (p[i] - c.p)) &gt;= 0) ans += c.areatriangle(p[i], p[j]); else ans -= c.areatriangle(p[i], p[j]); } return fabs(ans); } //多边形和圆关系 // 2 圆完全在多边形内 // 1 圆在多边形里面，碰到了多边形边界 // 0 其它 int relationcircle(circle c) { getline(); int x = 2; if (relationpoint(c.p) != 1) return 0; //圆心不在内部 for (int i = 0; i &lt; n; i++) { if (c.relationseg(l[i]) == 2) return 0; if (c.relationseg(l[i]) == 1) x = 1; } return x; }};// AB X ACdouble cross(Point A, Point B, Point C) { return (B - A) ^ (C - A);}// AB*ACdouble dot(Point A, Point B, Point C) { return (B - A) * (C - A);}//最小矩形面积覆盖// A 必须是凸包 (而且是逆时针顺序)// 测试 UVA 10173double minRectangleCover(polygon A) { //要特判 A.n &lt; 3 的情况 if (A.n &lt; 3) return 0.0; A.p[A.n] = A.p[0]; double ans = -1; int r = 1, p = 1, q; for (int i = 0; i &lt; A.n; i++) { //卡出离边 A.p[i] - A.p[i+1] 最远的点 while (sgn(cross(A.p[i], A.p[i + 1], A.p[r + 1]) - cross(A.p[i], A.p[i + 1], A.p[r])) &gt;= 0) r = (r + 1) % A.n; //卡出 A.p[i] - A.p[i+1] 方向上正向 n 最远的点 while (sgn(dot(A.p[i], A.p[i + 1], A.p[p + 1]) - dot(A.p[i], A.p[i + 1], A.p[p])) &gt;= 0) p = (p + 1) % A.n; if (i == 0) q = p; //卡出 A.p[i] - A.p[i+1] 方向上负向最远的点 while (sgn(dot(A.p[i], A.p[i + 1], A.p[q + 1]) - dot(A.p[i], A.p[i + 1], A.p[q])) &lt;= 0) q = (q + 1) % A.n; double d = (A.p[i] - A.p[i + 1]).len2(); double tmp = cross(A.p[i], A.p[i + 1], A.p[r]) * (dot(A.p[i], A.p[i + 1], A.p[p]) - dot(A.p[i], A.p[i + 1], A.p[q])) / d; if (ans &lt; 0 || ans &gt; tmp) ans = tmp; } return ans;} //直线切凸多边形//多边形是逆时针的，在 q1q2 的左侧//测试:HDU3982vector&lt;Point&gt; convexCut(const vector&lt;Point&gt; &amp;ps, Point q1, Point q2) { vector&lt;Point&gt; qs; int n = ps.size(); for (int i = 0; i &lt; n; i++) { Point p1 = ps[i], p2 = ps[(i + 1) % n]; int d1 = sgn((q2 - q1) ^ (p1 - q1)), d2 = sgn((q2 - q1) ^ (p2 - q1)); if (d1 &gt;= 0) qs.push_back(p1); if (d1 * d2 &lt; 0) qs.push_back(Line(p1, p2).crosspoint(Line(q1, q2))); } return qs;}double l = 0.00001, r = 3000;double cx, cy;polygon P, P2;double p, q;double area;void slove() { scanf(&quot;%lf%lf&quot;, &amp;cx, &amp;cy); scanf(&quot;%lf%lf&quot;, &amp;p, &amp;q); double a = area * (q - p) / q; // cout &lt;&lt; &quot;a==&quot; &lt;&lt; a &lt;&lt; endl; l = 0.00001, r = 3000; while (l &lt; r) { double mid = (l + r) / 2.0; circle c(cx, cy, mid); double res = P.areacircle(c); if (fabs(res - a) &lt; eps) { printf(&quot;%.8f\\n&quot;, mid); return; } else if (res &lt; a) { l = mid; } else { r = mid; } }} const int maxn = 1e8;const int mod = 32767;int main() { int n, m; scanf(&quot;%d&quot;, &amp;n); P.input(n); area = P.getarea(); scanf(&quot;%d&quot;, &amp;m); // cout &lt;&lt; &quot;area==&quot; &lt;&lt; area &lt;&lt; endl; for (int i = 0; i &lt; m; ++i) { slove(); }}","link":"/%E6%A8%A1%E6%9D%BF/2018/09/05/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF.html"}],"tags":[{"name":"网络赛","slug":"网络赛","link":"/tags/%E7%BD%91%E7%BB%9C%E8%B5%9B/"},{"name":"acm","slug":"acm","link":"/tags/acm/"},{"name":"计划","slug":"计划","link":"/tags/%E8%AE%A1%E5%88%92/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"树形dp","slug":"树形dp","link":"/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"考研","slug":"考研","link":"/tags/%E8%80%83%E7%A0%94/"},{"name":"nlp","slug":"nlp","link":"/tags/nlp/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"dptree","slug":"dptree","link":"/tags/dptree/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"cf","slug":"cf","link":"/tags/cf/"},{"name":"greedy","slug":"greedy","link":"/tags/greedy/"},{"name":"ac自动机","slug":"ac自动机","link":"/tags/ac%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"matrix","slug":"matrix","link":"/tags/matrix/"},{"name":"树状数组，hdoj","slug":"树状数组，hdoj","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%8Chdoj/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"lca","slug":"lca","link":"/tags/lca/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"pat","slug":"pat","link":"/tags/pat/"},{"name":"配置","slug":"配置","link":"/tags/%E9%85%8D%E7%BD%AE/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"范围","slug":"范围","link":"/tags/%E8%8C%83%E5%9B%B4/"},{"name":"缩点","slug":"缩点","link":"/tags/%E7%BC%A9%E7%82%B9/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"graph","slug":"graph","link":"/tags/graph/"},{"name":"开发","slug":"开发","link":"/tags/%E5%BC%80%E5%8F%91/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"struts2","slug":"struts2","link":"/tags/struts2/"},{"name":"echarts","slug":"echarts","link":"/tags/echarts/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"字符串hash","slug":"字符串hash","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2hash/"},{"name":"状压dp","slug":"状压dp","link":"/tags/%E7%8A%B6%E5%8E%8Bdp/"},{"name":"预处理","slug":"预处理","link":"/tags/%E9%A2%84%E5%A4%84%E7%90%86/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"构造","slug":"构造","link":"/tags/%E6%9E%84%E9%80%A0/"},{"name":"爆搜","slug":"爆搜","link":"/tags/%E7%88%86%E6%90%9C/"},{"name":"细节","slug":"细节","link":"/tags/%E7%BB%86%E8%8A%82/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"牛客网","slug":"牛客网","link":"/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/"},{"name":"组合数学","slug":"组合数学","link":"/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"规律","slug":"规律","link":"/tags/%E8%A7%84%E5%BE%8B/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"学习计划","slug":"学习计划","link":"/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"},{"name":"保研","slug":"保研","link":"/tags/%E4%BF%9D%E7%A0%94/"},{"name":"八数码","slug":"八数码","link":"/tags/%E5%85%AB%E6%95%B0%E7%A0%81/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"jsp","slug":"jsp","link":"/tags/jsp/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"最大子段和","slug":"最大子段和","link":"/tags/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/"},{"name":"hdoj","slug":"hdoj","link":"/tags/hdoj/"},{"name":"专题","slug":"专题","link":"/tags/%E4%B8%93%E9%A2%98/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"概率dp","slug":"概率dp","link":"/tags/%E6%A6%82%E7%8E%87dp/"},{"name":"蓝桥杯","slug":"蓝桥杯","link":"/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"人生","slug":"人生","link":"/tags/%E4%BA%BA%E7%94%9F/"},{"name":"补题","slug":"补题","link":"/tags/%E8%A1%A5%E9%A2%98/"},{"name":"模板","slug":"模板","link":"/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"计算几何","slug":"计算几何","link":"/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}],"categories":[{"name":"acm","slug":"acm","link":"/categories/acm/"},{"name":"学习计划","slug":"学习计划","link":"/categories/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"},{"name":"考研","slug":"考研","link":"/categories/%E8%80%83%E7%A0%94/"},{"name":"论解","slug":"论解","link":"/categories/%E8%AE%BA%E8%A7%A3/"},{"name":"线段树","slug":"线段树","link":"/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"cf1500","slug":"cf1500","link":"/categories/cf1500/"},{"name":"cf","slug":"cf","link":"/categories/cf/"},{"name":"ac自动机","slug":"ac自动机","link":"/categories/ac%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"专项练习","slug":"专项练习","link":"/categories/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"pat","slug":"pat","link":"/categories/pat/"},{"name":"搬砖","slug":"搬砖","link":"/categories/%E6%90%AC%E7%A0%96/"},{"name":"dp","slug":"dp","link":"/categories/dp/"},{"name":"1600","slug":"1600","link":"/categories/1600/"},{"name":"开发","slug":"开发","link":"/categories/%E5%BC%80%E5%8F%91/"},{"name":"hash","slug":"hash","link":"/categories/hash/"},{"name":"dfs","slug":"dfs","link":"/categories/dfs/"},{"name":"html","slug":"html","link":"/categories/html/"},{"name":"考研路漫漫","slug":"考研路漫漫","link":"/categories/%E8%80%83%E7%A0%94%E8%B7%AF%E6%BC%AB%E6%BC%AB/"},{"name":"保研","slug":"保研","link":"/categories/%E4%BF%9D%E7%A0%94/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"模板","slug":"模板","link":"/categories/%E6%A8%A1%E6%9D%BF/"},{"name":"概率dp","slug":"概率dp","link":"/categories/%E6%A6%82%E7%8E%87dp/"},{"name":"acm模板","slug":"acm模板","link":"/categories/acm%E6%A8%A1%E6%9D%BF/"},{"name":"蓝桥杯","slug":"蓝桥杯","link":"/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]}